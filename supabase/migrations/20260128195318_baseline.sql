--
-- PostgreSQL database dump
--

\restrict agQE2P5nhkF2FLfZ1Ji654IdC0IJY6medkfclpBX8aj4qCaTvHkwev08wWfJa0o

-- Dumped from database version 15.1 (Ubuntu 15.1-1.pgdg20.04+1)
-- Dumped by pg_dump version 18.1

SET statement_timeout = 0;
SET lock_timeout = 0;
SET idle_in_transaction_session_timeout = 0;
SET transaction_timeout = 0;
SET client_encoding = 'UTF8';
SET standard_conforming_strings = on;
SELECT pg_catalog.set_config('search_path', '', false);
SET check_function_bodies = false;
SET xmloption = content;
SET client_min_messages = warning;
SET row_security = off;

--
-- Name: public; Type: SCHEMA; Schema: -; Owner: -
--

CREATE SCHEMA public;


--
-- Name: SCHEMA public; Type: COMMENT; Schema: -; Owner: -
--

COMMENT ON SCHEMA public IS 'Geocoding queue system deployed - 2025-12-15';


--
-- Name: challenge_recent_item; Type: TYPE; Schema: public; Owner: -
--

CREATE TYPE public.challenge_recent_item AS (
	id bigint,
	title text,
	difficulty text,
	xp numeric,
	completed_at timestamp with time zone
);


--
-- Name: continents; Type: TYPE; Schema: public; Owner: -
--

CREATE TYPE public.continents AS ENUM (
    'Africa',
    'Antarctica',
    'Asia',
    'Europe',
    'Oceania',
    'North America',
    'South America'
);


--
-- Name: location_status; Type: TYPE; Schema: public; Owner: -
--

CREATE TYPE public.location_status AS ENUM (
    'active',
    'inactive'
);


--
-- Name: notification_category; Type: TYPE; Schema: public; Owner: -
--

CREATE TYPE public.notification_category AS ENUM (
    'posts',
    'forum',
    'challenges',
    'comments',
    'chats',
    'social',
    'system',
    'marketing'
);


--
-- Name: notification_channel; Type: TYPE; Schema: public; Owner: -
--

CREATE TYPE public.notification_channel AS ENUM (
    'push',
    'email',
    'sms'
);


--
-- Name: post_activity_type; Type: TYPE; Schema: public; Owner: -
--

CREATE TYPE public.post_activity_type AS ENUM (
    'created',
    'updated',
    'deleted',
    'restored',
    'activated',
    'deactivated',
    'expired',
    'viewed',
    'contacted',
    'arranged',
    'arrangement_cancelled',
    'collected',
    'not_collected',
    'reported',
    'flagged',
    'unflagged',
    'approved',
    'rejected',
    'hidden',
    'unhidden',
    'liked',
    'unliked',
    'shared',
    'bookmarked',
    'unbookmarked',
    'admin_edited',
    'admin_note_added',
    'admin_status_changed',
    'auto_expired',
    'auto_deactivated',
    'location_updated',
    'images_updated'
);


--
-- Name: acknowledge_alert(bigint, uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.acknowledge_alert(p_alert_id bigint, p_user_id uuid) RETURNS boolean
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public', 'pg_temp'
    AS $$
BEGIN
    UPDATE metrics.alerts
    SET acknowledged = true, acknowledged_by = p_user_id, acknowledged_at = now()
    WHERE id = p_alert_id AND acknowledged = false;
    RETURN FOUND;
END;
$$;


--
-- Name: FUNCTION acknowledge_alert(p_alert_id bigint, p_user_id uuid); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.acknowledge_alert(p_alert_id bigint, p_user_id uuid) IS 'Marks an alert as acknowledged by a user';


--
-- Name: add_bookmark_to_collection(integer, uuid, text, text[], timestamp with time zone); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.add_bookmark_to_collection(p_forum_id integer, p_collection_id uuid DEFAULT NULL::uuid, p_notes text DEFAULT NULL::text, p_tags text[] DEFAULT NULL::text[], p_reminder_at timestamp with time zone DEFAULT NULL::timestamp with time zone) RETURNS uuid
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
DECLARE
  v_bookmark_id INTEGER;
  v_default_collection_id UUID;
BEGIN
  -- Get default collection if none specified
  IF p_collection_id IS NULL THEN
    SELECT id INTO v_default_collection_id
    FROM forum_bookmark_collections
    WHERE profile_id = auth.uid() AND is_default = TRUE;
    
    -- Create default if doesn't exist
    IF v_default_collection_id IS NULL THEN
      INSERT INTO forum_bookmark_collections (profile_id, name, description, is_default, icon_name)
      VALUES (auth.uid(), 'All Bookmarks', 'Default collection for all bookmarks', TRUE, 'bookmark')
      RETURNING id INTO v_default_collection_id;
    END IF;
    
    p_collection_id := v_default_collection_id;
  END IF;
  
  -- Insert or update bookmark
  INSERT INTO forum_bookmarks (forum_id, profile_id, collection_id, notes, tags, reminder_at)
  VALUES (p_forum_id, auth.uid(), p_collection_id, p_notes, p_tags, p_reminder_at)
  ON CONFLICT (forum_id, profile_id) 
  DO UPDATE SET 
    collection_id = EXCLUDED.collection_id,
    notes = COALESCE(EXCLUDED.notes, forum_bookmarks.notes),
    tags = COALESCE(EXCLUDED.tags, forum_bookmarks.tags),
    reminder_at = EXCLUDED.reminder_at
  RETURNING id INTO v_bookmark_id;
  
  -- Update collection count
  UPDATE forum_bookmark_collections
  SET bookmarks_count = (
    SELECT COUNT(*) FROM forum_bookmarks WHERE collection_id = p_collection_id
  ),
  updated_at = now()
  WHERE id = p_collection_id;
  
  RETURN p_collection_id;
END;
$$;


--
-- Name: FUNCTION add_bookmark_to_collection(p_forum_id integer, p_collection_id uuid, p_notes text, p_tags text[], p_reminder_at timestamp with time zone); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.add_bookmark_to_collection(p_forum_id integer, p_collection_id uuid, p_notes text, p_tags text[], p_reminder_at timestamp with time zone) IS 'Add a post to a bookmark collection with optional notes and reminder';


--
-- Name: add_post_to_series(uuid, bigint, text, text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.add_post_to_series(p_series_id uuid, p_forum_id bigint, p_chapter_title text DEFAULT NULL::text, p_chapter_description text DEFAULT NULL::text) RETURNS jsonb
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
DECLARE
  v_series_owner UUID;
  v_next_order INTEGER;
  v_result JSONB;
BEGIN
  -- Verify ownership
  SELECT profile_id INTO v_series_owner FROM forum_series WHERE id = p_series_id;
  
  IF v_series_owner != auth.uid() THEN
    RAISE EXCEPTION 'Only the series owner can add posts';
  END IF;
  
  -- Get next order number
  SELECT COALESCE(MAX(sort_order), 0) + 1 INTO v_next_order
  FROM forum_series_posts WHERE series_id = p_series_id;
  
  -- Add to series
  INSERT INTO forum_series_posts (
    series_id,
    forum_id,
    sort_order,
    chapter_title,
    chapter_description
  ) VALUES (
    p_series_id,
    p_forum_id,
    v_next_order,
    p_chapter_title,
    p_chapter_description
  );
  
  -- Update forum post with series reference
  UPDATE forum SET 
    series_id = p_series_id,
    series_order = v_next_order
  WHERE id = p_forum_id;
  
  -- Update series counts
  UPDATE forum_series SET
    posts_count = posts_count + 1,
    updated_at = now()
  WHERE id = p_series_id;
  
  SELECT jsonb_build_object(
    'series_id', p_series_id,
    'forum_id', p_forum_id,
    'order', v_next_order
  ) INTO v_result;
  
  RETURN v_result;
END;
$$;


--
-- Name: add_to_moderation_queue(text, text, integer, integer, uuid, uuid, uuid, text, numeric, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.add_to_moderation_queue(p_queue_type text, p_content_type text, p_forum_id integer DEFAULT NULL::integer, p_comment_id integer DEFAULT NULL::integer, p_message_id uuid DEFAULT NULL::uuid, p_target_profile_id uuid DEFAULT NULL::uuid, p_report_id uuid DEFAULT NULL::uuid, p_flag_reason text DEFAULT NULL::text, p_flag_score numeric DEFAULT NULL::numeric, p_priority integer DEFAULT 0) RETURNS uuid
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
DECLARE
  v_queue_id UUID;
  v_content_snapshot JSONB;
BEGIN
  -- Build content snapshot
  IF p_forum_id IS NOT NULL THEN
    SELECT jsonb_build_object(
      'title', forum_post_name,
      'description', forum_post_description,
      'author_id', profile_id,
      'created_at', forum_post_created_at
    ) INTO v_content_snapshot FROM forum WHERE id = p_forum_id;
  ELSIF p_comment_id IS NOT NULL THEN
    SELECT jsonb_build_object(
      'content', comment,
      'author_id', user_id,
      'created_at', comment_created_at
    ) INTO v_content_snapshot FROM comments WHERE id = p_comment_id;
  ELSIF p_message_id IS NOT NULL THEN
    SELECT jsonb_build_object(
      'content', content,
      'sender_id', sender_id,
      'created_at', created_at
    ) INTO v_content_snapshot FROM forum_messages WHERE id = p_message_id;
  END IF;
  
  INSERT INTO forum_moderation_queue (
    queue_type, content_type, forum_id, comment_id, message_id, profile_id,
    report_id, reporter_id, flag_reason, flag_score, priority, content_snapshot
  ) VALUES (
    p_queue_type, p_content_type, p_forum_id, p_comment_id, p_message_id, p_target_profile_id,
    p_report_id, auth.uid(), p_flag_reason, p_flag_score, p_priority, v_content_snapshot
  )
  RETURNING id INTO v_queue_id;
  
  RETURN v_queue_id;
END;
$$;


--
-- Name: add_to_suppression_list(text, text, text, text, text, text, timestamp with time zone); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.add_to_suppression_list(p_email text, p_reason text, p_provider text DEFAULT NULL::text, p_bounce_type text DEFAULT NULL::text, p_bounce_subtype text DEFAULT NULL::text, p_message_id text DEFAULT NULL::text, p_expires_at timestamp with time zone DEFAULT NULL::timestamp with time zone) RETURNS uuid
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO ''
    AS $$
DECLARE
  v_id uuid;
BEGIN
  INSERT INTO public.email_suppression_list (
    email, reason, provider, bounce_type, bounce_subtype, 
    original_message_id, expires_at
  )
  VALUES (
    lower(p_email), p_reason, p_provider, p_bounce_type, p_bounce_subtype,
    p_message_id, p_expires_at
  )
  ON CONFLICT (email) DO UPDATE SET
    reason = EXCLUDED.reason,
    provider = COALESCE(EXCLUDED.provider, public.email_suppression_list.provider),
    bounce_type = COALESCE(EXCLUDED.bounce_type, public.email_suppression_list.bounce_type),
    bounce_subtype = COALESCE(EXCLUDED.bounce_subtype, public.email_suppression_list.bounce_subtype),
    suppressed_at = now()
  RETURNING id INTO v_id;
  
  RETURN v_id;
END;
$$;


--
-- Name: address_in_view(double precision, double precision, double precision, double precision); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.address_in_view(min_lat double precision, min_long double precision, max_lat double precision, max_long double precision) RETURNS SETOF record
    LANGUAGE sql
    SET search_path TO ''
    AS $$
	select profile_id, address_line_1, st_astext(location) as location
	from public.address
	where location && ST_SetSRID(ST_MakeBox2D(ST_Point(min_long, min_lat), ST_Point(max_long, max_lat)),4326)
$$;


--
-- Name: address_in_view(numeric, numeric, numeric, numeric); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.address_in_view(min_lat numeric, min_long numeric, max_lat numeric, max_long numeric) RETURNS SETOF record
    LANGUAGE plpgsql STABLE
    SET search_path TO ''
    AS $$
BEGIN
  RETURN QUERY
  SELECT *
  FROM public.address
  WHERE lat BETWEEN min_lat AND max_lat
    AND long BETWEEN min_long AND max_long;
END;
$$;


--
-- Name: aggregate_daily_author_analytics(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.aggregate_daily_author_analytics() RETURNS void
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
DECLARE
  v_yesterday DATE := CURRENT_DATE - 1;
BEGIN
  INSERT INTO forum_author_analytics (
    profile_id,
    date,
    total_views,
    total_likes,
    total_comments,
    total_reactions,
    new_posts_count,
    top_post_id,
    engagement_rate
  )
  SELECT 
    f.profile_id,
    v_yesterday,
    COALESCE(SUM(pa.views_count), 0),
    COALESCE(SUM(pa.likes_count), 0),
    COALESCE(SUM(pa.comments_count), 0),
    COALESCE(SUM(pa.reactions_count), 0),
    COUNT(CASE WHEN f.forum_post_created_at::DATE = v_yesterday THEN 1 END),
    (SELECT pa2.forum_id 
     FROM forum_post_analytics pa2 
     JOIN forum f2 ON f2.id = pa2.forum_id
     WHERE f2.profile_id = f.profile_id AND pa2.date = v_yesterday
     ORDER BY pa2.views_count DESC LIMIT 1),
    CASE WHEN SUM(pa.views_count) > 0 
      THEN ((SUM(pa.likes_count) + SUM(pa.comments_count) + SUM(pa.reactions_count))::DECIMAL / SUM(pa.views_count) * 100)
      ELSE 0 
    END
  FROM forum f
  LEFT JOIN forum_post_analytics pa ON pa.forum_id = f.id AND pa.date = v_yesterday
  GROUP BY f.profile_id
  ON CONFLICT (profile_id, date) DO UPDATE SET
    total_views = EXCLUDED.total_views,
    total_likes = EXCLUDED.total_likes,
    total_comments = EXCLUDED.total_comments,
    total_reactions = EXCLUDED.total_reactions,
    new_posts_count = EXCLUDED.new_posts_count,
    top_post_id = EXCLUDED.top_post_id,
    engagement_rate = EXCLUDED.engagement_rate;
END;
$$;


--
-- Name: apply_pending_operation(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.apply_pending_operation(p_operation_id uuid) RETURNS jsonb
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
DECLARE
  v_op record;
  v_result jsonb;
BEGIN
  SELECT * INTO v_op
  FROM pending_operations
  WHERE id = p_operation_id;

  IF v_op IS NULL THEN
    RETURN jsonb_build_object('success', false, 'error', 'OPERATION_NOT_FOUND');
  END IF;

  IF v_op.status = 'conflict' THEN
    RETURN jsonb_build_object('success', false, 'error', 'CONFLICT_UNRESOLVED');
  END IF;

  IF v_op.status != 'pending' THEN
    RETURN jsonb_build_object('success', false, 'error', 'ALREADY_PROCESSED');
  END IF;

  -- Apply operation based on type and table
  BEGIN
    CASE v_op.table_name
      WHEN 'posts' THEN
        CASE v_op.operation_type
          WHEN 'create' THEN
            -- Uses correct column names for posts table
            INSERT INTO posts (profile_id, post_name, post_description, images, post_type, post_address)
            SELECT
              v_op.user_id,
              v_op.payload->>'postName',
              v_op.payload->>'description',
              ARRAY(SELECT jsonb_array_elements_text(v_op.payload->'images')),
              COALESCE(v_op.payload->>'postType', 'food'),
              v_op.payload->>'pickupAddress';

          WHEN 'update' THEN
            UPDATE posts
            SET
              post_name = COALESCE(v_op.payload->>'postName', post_name),
              post_description = COALESCE(v_op.payload->>'description', post_description),
              is_active = COALESCE((v_op.payload->>'isActive')::boolean, is_active),
              updated_at = NOW()
            WHERE id = v_op.record_id AND profile_id = v_op.user_id;

          WHEN 'delete' THEN
            UPDATE posts
            SET is_active = false
            WHERE id = v_op.record_id AND profile_id = v_op.user_id;
        END CASE;

      ELSE
        RAISE EXCEPTION 'Unsupported table: %', v_op.table_name;
    END CASE;

    -- Mark as applied
    UPDATE pending_operations
    SET status = 'applied'
    WHERE id = p_operation_id;

    RETURN jsonb_build_object('success', true, 'status', 'applied');

  EXCEPTION WHEN OTHERS THEN
    UPDATE pending_operations
    SET status = 'rejected', error_message = SQLERRM
    WHERE id = p_operation_id;

    RETURN jsonb_build_object('success', false, 'error', SQLERRM);
  END;
END;
$$;


--
-- Name: FUNCTION apply_pending_operation(p_operation_id uuid); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.apply_pending_operation(p_operation_id uuid) IS 'Applies a pending operation with conflict resolution';


--
-- Name: arrange_post(integer, uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.arrange_post(p_post_id integer, p_requester_id uuid) RETURNS jsonb
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO ''
    AS $$
DECLARE
    v_post RECORD;
    v_result JSONB;
BEGIN
    SELECT * INTO v_post FROM public.posts WHERE id = p_post_id FOR UPDATE;

    IF v_post IS NULL THEN
        RETURN jsonb_build_object('success', false, 'error', jsonb_build_object('code', 'RESOURCE_NOT_FOUND', 'message', 'Post not found'), 'post', NULL, 'notifyUserId', NULL);
    END IF;

    IF v_post.is_arranged THEN
        RETURN jsonb_build_object('success', false, 'error', jsonb_build_object('code', 'RESOURCE_CONFLICT', 'message', 'This post is already arranged'), 'post', NULL, 'notifyUserId', NULL);
    END IF;

    IF NOT v_post.is_active THEN
        RETURN jsonb_build_object('success', false, 'error', jsonb_build_object('code', 'RESOURCE_UNAVAILABLE', 'message', 'This post is no longer available'), 'post', NULL, 'notifyUserId', NULL);
    END IF;

    IF v_post.profile_id = p_requester_id THEN
        RETURN jsonb_build_object('success', false, 'error', jsonb_build_object('code', 'VALIDATION_ERROR', 'message', 'You cannot arrange your own post'), 'post', NULL, 'notifyUserId', NULL);
    END IF;

    IF p_requester_id != auth.uid() THEN
        RETURN jsonb_build_object('success', false, 'error', jsonb_build_object('code', 'AUTH_FORBIDDEN', 'message', 'You can only arrange posts for yourself'), 'post', NULL, 'notifyUserId', NULL);
    END IF;

    UPDATE public.posts SET is_arranged = true, post_arranged_to = p_requester_id, post_arranged_at = now(), updated_at = now() WHERE id = p_post_id;

    INSERT INTO public.post_activity_logs (post_id, actor_id, activity_type, metadata)
    VALUES (p_post_id, p_requester_id, 'arranged', jsonb_build_object('sharer_id', v_post.profile_id, 'requester_id', p_requester_id, 'arranged_at', now()));

    SELECT jsonb_build_object('success', true, 'error', NULL, 'post', jsonb_build_object('id', p.id, 'profileId', p.profile_id, 'postName', p.post_name, 'isArranged', p.is_arranged, 'postArrangedTo', p.post_arranged_to, 'postArrangedAt', p.post_arranged_at), 'notifyUserId', v_post.profile_id)
    INTO v_result FROM public.posts p WHERE p.id = p_post_id;

    RETURN v_result;
END;
$$;


--
-- Name: audit_display_name_override_changes(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.audit_display_name_override_changes() RETURNS trigger
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
BEGIN
  IF TG_OP = 'INSERT' THEN
    INSERT INTO audit.logged_actions (
      schema_name,
      table_name,
      action,
      row_data,
      user_id
    ) VALUES (
      TG_TABLE_SCHEMA,
      TG_TABLE_NAME,
      'INSERT',
      to_jsonb(NEW),
      NEW.overridden_by
    );
    RETURN NEW;
  ELSIF TG_OP = 'UPDATE' THEN
    INSERT INTO audit.logged_actions (
      schema_name,
      table_name,
      action,
      row_data,
      changed_fields,
      user_id
    ) VALUES (
      TG_TABLE_SCHEMA,
      TG_TABLE_NAME,
      'UPDATE',
      to_jsonb(NEW),
      (
        SELECT jsonb_object_agg(key, value)
        FROM jsonb_each(to_jsonb(NEW))
        WHERE to_jsonb(OLD) -> key IS DISTINCT FROM value
      ),
      NEW.overridden_by
    );
    RETURN NEW;
  ELSIF TG_OP = 'DELETE' THEN
    INSERT INTO audit.logged_actions (
      schema_name,
      table_name,
      action,
      row_data,
      user_id
    ) VALUES (
      TG_TABLE_SCHEMA,
      TG_TABLE_NAME,
      'DELETE',
      to_jsonb(OLD),
      OLD.overridden_by
    );
    RETURN OLD;
  END IF;
  RETURN NULL;
END;
$$;


--
-- Name: auto_subscribe_post_author(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.auto_subscribe_post_author() RETURNS trigger
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
BEGIN
  INSERT INTO public.forum_subscriptions (profile_id, forum_id)
  VALUES (NEW.profile_id, NEW.id)
  ON CONFLICT DO NOTHING;
  RETURN NEW;
END;
$$;


--
-- Name: award_reputation(uuid, text, uuid, bigint, bigint, text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.award_reputation(p_profile_id uuid, p_action_key text, p_source_profile_id uuid DEFAULT NULL::uuid, p_source_forum_id bigint DEFAULT NULL::bigint, p_source_comment_id bigint DEFAULT NULL::bigint, p_description text DEFAULT NULL::text) RETURNS integer
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
DECLARE
  v_action forum_reputation_actions%ROWTYPE;
  v_points INTEGER;
  v_today_count INTEGER;
BEGIN
  SELECT * INTO v_action FROM forum_reputation_actions WHERE action_key = p_action_key AND is_active = true;
  IF NOT FOUND THEN RETURN 0; END IF;
  
  IF v_action.daily_limit IS NOT NULL THEN
    SELECT COUNT(*) INTO v_today_count FROM forum_reputation_history
    WHERE profile_id = p_profile_id AND action_key = p_action_key AND created_at >= CURRENT_DATE;
    IF v_today_count >= v_action.daily_limit THEN RETURN 0; END IF;
  END IF;
  
  v_points := v_action.points;
  
  INSERT INTO forum_reputation_history (profile_id, action_key, points, source_profile_id, source_forum_id, source_comment_id, description)
  VALUES (p_profile_id, p_action_key, v_points, p_source_profile_id, p_source_forum_id, p_source_comment_id, COALESCE(p_description, v_action.description));
  
  INSERT INTO forum_user_reputation (profile_id, total_points, positive_points, negative_points, points_this_week, points_this_month)
  VALUES (p_profile_id, v_points, CASE WHEN v_points > 0 THEN v_points ELSE 0 END, CASE WHEN v_points < 0 THEN ABS(v_points) ELSE 0 END, v_points, v_points)
  ON CONFLICT (profile_id) DO UPDATE SET
    total_points = forum_user_reputation.total_points + v_points,
    positive_points = forum_user_reputation.positive_points + CASE WHEN v_points > 0 THEN v_points ELSE 0 END,
    negative_points = forum_user_reputation.negative_points + CASE WHEN v_points < 0 THEN ABS(v_points) ELSE 0 END,
    points_this_week = CASE WHEN forum_user_reputation.week_start_date < date_trunc('week', CURRENT_DATE)::DATE THEN v_points ELSE forum_user_reputation.points_this_week + v_points END,
    points_this_month = CASE WHEN forum_user_reputation.month_start_date < date_trunc('month', CURRENT_DATE)::DATE THEN v_points ELSE forum_user_reputation.points_this_month + v_points END,
    updated_at = now();
  
  PERFORM update_reputation_level(p_profile_id);
  RETURN v_points;
END;
$$;


--
-- Name: batch_delete_notifications(uuid, bigint[], integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.batch_delete_notifications(p_user_id uuid, p_notification_ids bigint[] DEFAULT NULL::bigint[], p_older_than_days integer DEFAULT NULL::integer) RETURNS jsonb
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
DECLARE
  v_deleted_count INTEGER;
BEGIN
  IF p_notification_ids IS NOT NULL THEN
    -- Delete specific notifications
    DELETE FROM user_notifications
    WHERE user_id = p_user_id AND id = ANY(p_notification_ids);
    GET DIAGNOSTICS v_deleted_count = ROW_COUNT;
  ELSIF p_older_than_days IS NOT NULL THEN
    -- Delete old notifications
    DELETE FROM user_notifications
    WHERE user_id = p_user_id 
      AND created_at < NOW() - (p_older_than_days || ' days')::INTERVAL;
    GET DIAGNOSTICS v_deleted_count = ROW_COUNT;
  ELSE
    -- Delete all read notifications
    DELETE FROM user_notifications
    WHERE user_id = p_user_id AND is_read = TRUE;
    GET DIAGNOSTICS v_deleted_count = ROW_COUNT;
  END IF;

  RETURN jsonb_build_object(
    'success', TRUE,
    'deletedCount', v_deleted_count,
    'remainingCount', (SELECT COUNT(*) FROM user_notifications WHERE user_id = p_user_id)
  );
END;
$$;


--
-- Name: batch_mark_notifications_read(uuid, bigint[], text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.batch_mark_notifications_read(p_user_id uuid, p_notification_ids bigint[] DEFAULT NULL::bigint[], p_category text DEFAULT NULL::text) RETURNS jsonb
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
DECLARE
  v_updated_count INTEGER;
BEGIN
  IF p_notification_ids IS NOT NULL THEN
    -- Mark specific notifications as read
    UPDATE user_notifications
    SET is_read = TRUE
    WHERE user_id = p_user_id 
      AND id = ANY(p_notification_ids)
      AND is_read = FALSE;
    GET DIAGNOSTICS v_updated_count = ROW_COUNT;
  ELSIF p_category IS NOT NULL THEN
    -- Mark all in category as read
    UPDATE user_notifications
    SET is_read = TRUE
    WHERE user_id = p_user_id 
      AND is_read = FALSE
      AND (
        (p_category = 'messages' AND notification_type LIKE ANY(ARRAY['message%', 'chat%'])) OR
        (p_category = 'forum' AND notification_type LIKE 'forum%') OR
        (p_category = 'challenges' AND notification_type LIKE 'challenge%') OR
        (p_category = 'transactions' AND notification_type IN ('arrangement_request', 'arrangement_accepted', 'arrangement_completed', 'transaction_completed'))
      );
    GET DIAGNOSTICS v_updated_count = ROW_COUNT;
  ELSE
    -- Mark all as read
    UPDATE user_notifications
    SET is_read = TRUE
    WHERE user_id = p_user_id AND is_read = FALSE;
    GET DIAGNOSTICS v_updated_count = ROW_COUNT;
  END IF;

  RETURN jsonb_build_object(
    'success', TRUE,
    'updatedCount', v_updated_count,
    'remainingUnread', (SELECT COUNT(*) FROM user_notifications WHERE user_id = p_user_id AND is_read = FALSE)
  );
END;
$$;


--
-- Name: batch_record_email_metrics(jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.batch_record_email_metrics(p_metrics jsonb) RETURNS void
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO ''
    AS $$
DECLARE
  metric jsonb;
  v_provider text;
  v_success boolean;
  v_latency_ms integer;
BEGIN
  FOR metric IN SELECT * FROM jsonb_array_elements(p_metrics)
  LOOP
    v_provider := metric->>'provider';
    v_success := (metric->>'success')::boolean;
    v_latency_ms := (metric->>'latencyMs')::integer;
    
    UPDATE public.email_provider_health_metrics
    SET 
      total_requests = total_requests + 1,
      successful_requests = successful_requests + CASE WHEN v_success THEN 1 ELSE 0 END,
      failed_requests = failed_requests + CASE WHEN v_success THEN 0 ELSE 1 END,
      average_latency_ms = (average_latency_ms * total_requests + v_latency_ms) / (total_requests + 1),
      consecutive_failures = CASE WHEN v_success THEN 0 ELSE consecutive_failures + 1 END,
      health_score = CASE 
        WHEN v_success THEN LEAST(100, health_score + 2)
        ELSE GREATEST(0, health_score - 10)
      END,
      last_updated = NOW()
    WHERE provider = v_provider;
    
    IF NOT FOUND THEN
      INSERT INTO public.email_provider_health_metrics (
        provider, total_requests, successful_requests, failed_requests,
        average_latency_ms, consecutive_failures, health_score
      ) VALUES (
        v_provider, 1, 
        CASE WHEN v_success THEN 1 ELSE 0 END,
        CASE WHEN v_success THEN 0 ELSE 1 END,
        v_latency_ms, 
        CASE WHEN v_success THEN 0 ELSE 1 END,
        CASE WHEN v_success THEN 100 ELSE 90 END
      );
    END IF;
  END LOOP;
  
  UPDATE public.email_provider_quota
  SET emails_sent = emails_sent + (
    SELECT COUNT(*) FROM jsonb_array_elements(p_metrics) m 
    WHERE (m->>'success')::boolean = true 
    AND m->>'provider' = public.email_provider_quota.provider
  )
  WHERE date = CURRENT_DATE;
END;
$$;


--
-- Name: billing_cleanup_old_events(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.billing_cleanup_old_events(p_retention_days integer DEFAULT 90) RETURNS jsonb
    LANGUAGE sql SECURITY DEFINER
    SET search_path TO 'billing', 'public'
    AS $$
  SELECT billing.cleanup_old_events(p_retention_days);
$$;


--
-- Name: billing_find_user_for_transaction(uuid, text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.billing_find_user_for_transaction(p_app_account_token uuid, p_original_transaction_id text) RETURNS uuid
    LANGUAGE sql SECURITY DEFINER
    SET search_path TO 'billing', 'public'
    AS $$
  SELECT billing.find_user_for_transaction(p_app_account_token, p_original_transaction_id);
$$;


--
-- Name: billing_get_current_status(text, text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.billing_get_current_status(p_original_transaction_id text, p_platform text) RETURNS text
    LANGUAGE sql SECURITY DEFINER
    SET search_path TO 'billing', 'public'
    AS $$
  SELECT COALESCE(
    (SELECT status FROM billing.subscriptions
     WHERE original_transaction_id = p_original_transaction_id
       AND platform = p_platform
     LIMIT 1),
    'unknown'
  );
$$;


--
-- Name: billing_get_user_subscription(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.billing_get_user_subscription(p_user_id uuid) RETURNS jsonb
    LANGUAGE sql SECURITY DEFINER
    SET search_path TO 'billing', 'public'
    AS $$
  SELECT billing.get_user_subscription(p_user_id);
$$;


--
-- Name: billing_is_user_premium(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.billing_is_user_premium(p_user_id uuid) RETURNS boolean
    LANGUAGE sql SECURITY DEFINER
    SET search_path TO 'billing', 'public'
    AS $$
  SELECT billing.is_user_premium(p_user_id);
$$;


--
-- Name: billing_mark_event_processed(uuid, uuid, text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.billing_mark_event_processed(p_event_id uuid, p_subscription_id uuid DEFAULT NULL::uuid, p_error text DEFAULT NULL::text) RETURNS void
    LANGUAGE sql SECURITY DEFINER
    SET search_path TO 'billing', 'public'
    AS $$
  SELECT billing.mark_event_processed(p_event_id, p_subscription_id, p_error);
$$;


--
-- Name: billing_process_dlq(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.billing_process_dlq() RETURNS jsonb
    LANGUAGE sql SECURITY DEFINER
    SET search_path TO 'billing', 'public'
    AS $$
  SELECT billing.process_dlq();
$$;


--
-- Name: billing_process_webhook_atomically(text, text, text, text, text, text, jsonb, timestamp with time zone, uuid, text, text, text, timestamp with time zone, timestamp with time zone, timestamp with time zone, boolean, text, text, uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.billing_process_webhook_atomically(p_notification_uuid text, p_platform text, p_notification_type text, p_subtype text, p_original_transaction_id text, p_signed_payload text, p_decoded_payload jsonb, p_signed_date timestamp with time zone, p_user_id uuid, p_product_id text, p_bundle_id text, p_status text, p_purchase_date timestamp with time zone, p_original_purchase_date timestamp with time zone, p_expires_date timestamp with time zone, p_auto_renew_status boolean, p_auto_renew_product_id text, p_environment text, p_app_account_token uuid) RETURNS jsonb
    LANGUAGE sql SECURITY DEFINER
    SET search_path TO 'billing', 'public'
    AS $$
  SELECT billing.process_webhook_atomically(
    p_notification_uuid,
    p_platform,
    p_notification_type,
    p_subtype,
    p_original_transaction_id,
    p_signed_payload,
    p_decoded_payload,
    p_signed_date,
    p_user_id,
    p_product_id,
    p_bundle_id,
    p_status,
    p_purchase_date,
    p_original_purchase_date,
    p_expires_date,
    p_auto_renew_status,
    p_auto_renew_product_id,
    p_environment,
    p_app_account_token
  );
$$;


--
-- Name: billing_record_subscription_event(text, text, text, text, text, text, jsonb, timestamp with time zone); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.billing_record_subscription_event(p_notification_uuid text, p_platform text DEFAULT 'apple'::text, p_notification_type text DEFAULT ''::text, p_subtype text DEFAULT NULL::text, p_original_transaction_id text DEFAULT ''::text, p_signed_payload text DEFAULT ''::text, p_decoded_payload jsonb DEFAULT '{}'::jsonb, p_signed_date timestamp with time zone DEFAULT NULL::timestamp with time zone) RETURNS jsonb
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'billing', 'public'
    AS $$
DECLARE
  v_uuid uuid;
  v_result jsonb;
BEGIN
  -- Convert text to UUID (use md5 hash for non-UUID strings)
  BEGIN
    v_uuid := p_notification_uuid::uuid;
  EXCEPTION WHEN invalid_text_representation THEN
    -- Generate deterministic UUID from the string (for idempotency)
    v_uuid := md5(p_notification_uuid)::uuid;
  END;
  
  -- Call the billing schema function
  SELECT billing.record_subscription_event(
    v_uuid,
    p_platform,
    p_notification_type,
    p_subtype,
    p_original_transaction_id,
    p_signed_payload,
    p_decoded_payload,
    p_signed_date
  ) INTO v_result;
  
  RETURN v_result;
END;
$$;


--
-- Name: billing_update_daily_metrics(date); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.billing_update_daily_metrics(p_date date DEFAULT CURRENT_DATE) RETURNS jsonb
    LANGUAGE sql SECURITY DEFINER
    SET search_path TO 'billing', 'public'
    AS $$
  SELECT billing.update_daily_metrics(p_date);
$$;


--
-- Name: billing_upsert_subscription(uuid, text, text, text, text, text, timestamp with time zone, timestamp with time zone, timestamp with time zone, boolean, text, text, uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.billing_upsert_subscription(p_user_id uuid, p_platform text DEFAULT 'apple'::text, p_original_transaction_id text DEFAULT ''::text, p_product_id text DEFAULT ''::text, p_bundle_id text DEFAULT ''::text, p_status text DEFAULT 'unknown'::text, p_purchase_date timestamp with time zone DEFAULT NULL::timestamp with time zone, p_original_purchase_date timestamp with time zone DEFAULT NULL::timestamp with time zone, p_expires_date timestamp with time zone DEFAULT NULL::timestamp with time zone, p_auto_renew_status boolean DEFAULT true, p_auto_renew_product_id text DEFAULT NULL::text, p_environment text DEFAULT 'Production'::text, p_app_account_token uuid DEFAULT NULL::uuid) RETURNS uuid
    LANGUAGE sql SECURITY DEFINER
    SET search_path TO 'billing', 'public'
    AS $$
  SELECT billing.upsert_subscription(
    p_user_id,
    p_platform,
    p_original_transaction_id,
    p_product_id,
    p_bundle_id,
    p_status,
    p_purchase_date,
    p_original_purchase_date,
    p_expires_date,
    p_auto_renew_status,
    p_auto_renew_product_id,
    p_environment,
    p_app_account_token
  );
$$;


--
-- Name: billing_validate_status_transition(text, text, text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.billing_validate_status_transition(p_current_status text, p_new_status text, p_event_type text) RETURNS boolean
    LANGUAGE sql SECURITY DEFINER
    SET search_path TO 'billing', 'public'
    AS $$
  SELECT billing.validate_status_transition(p_current_status, p_new_status, p_event_type);
$$;


--
-- Name: block_user(uuid, text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.block_user(p_blocked_id uuid, p_reason text DEFAULT NULL::text) RETURNS boolean
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
BEGIN
  -- Cannot block yourself
  IF p_blocked_id = auth.uid() THEN
    RAISE EXCEPTION 'Cannot block yourself';
  END IF;
  
  -- Insert block record
  INSERT INTO forum_user_blocks (blocker_id, blocked_id, reason)
  VALUES (auth.uid(), p_blocked_id, p_reason)
  ON CONFLICT (blocker_id, blocked_id) DO UPDATE
  SET reason = EXCLUDED.reason;
  
  -- Remove any existing follow relationships
  DELETE FROM forum_user_follows
  WHERE (follower_id = auth.uid() AND following_id = p_blocked_id)
     OR (follower_id = p_blocked_id AND following_id = auth.uid());
  
  -- Leave any shared 1:1 conversations
  UPDATE forum_conversation_participants
  SET left_at = now()
  WHERE profile_id = auth.uid()
    AND conversation_id IN (
      SELECT c.id
      FROM forum_conversations c
      JOIN forum_conversation_participants cp ON cp.conversation_id = c.id
      WHERE c.is_group = FALSE
        AND cp.profile_id = p_blocked_id
    );
  
  RETURN TRUE;
END;
$$;


--
-- Name: FUNCTION block_user(p_blocked_id uuid, p_reason text); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.block_user(p_blocked_id uuid, p_reason text) IS 'Block a user and remove related connections';


--
-- Name: calculate_hot_score(integer, integer, integer, integer, timestamp with time zone); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.calculate_hot_score(p_likes integer, p_comments integer, p_reactions integer, p_views integer, p_created_at timestamp with time zone) RETURNS numeric
    LANGUAGE plpgsql IMMUTABLE
    SET search_path TO 'public'
    AS $$
DECLARE
  v_engagement NUMERIC;
  v_order NUMERIC;
  v_seconds NUMERIC;
  v_sign INTEGER;
BEGIN
  -- Calculate engagement score (weighted)
  v_engagement := COALESCE(p_likes, 0) + 
                  COALESCE(p_comments, 0) * 2 + 
                  COALESCE(p_reactions, 0) * 1.5 + 
                  COALESCE(p_views, 0) * 0.01;
  
  -- Determine sign
  IF v_engagement > 0 THEN
    v_sign := 1;
  ELSIF v_engagement < 0 THEN
    v_sign := -1;
  ELSE
    v_sign := 0;
  END IF;
  
  -- Calculate order (logarithmic scaling)
  v_order := log(10, GREATEST(ABS(v_engagement), 1));
  
  -- Calculate seconds since epoch (Jan 1, 2024)
  v_seconds := EXTRACT(EPOCH FROM p_created_at) - 1704067200; -- 2024-01-01 00:00:00 UTC
  
  -- Return hot score (higher = hotter)
  RETURN ROUND(v_order + v_sign * v_seconds / 45000, 4);
END;
$$;


--
-- Name: calculate_next_occurrence(text, integer, time without time zone, text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.calculate_next_occurrence(p_recurrence_type text, p_recurrence_day integer, p_recurrence_time time without time zone, p_timezone text) RETURNS timestamp with time zone
    LANGUAGE plpgsql IMMUTABLE
    SET search_path TO ''
    AS $$
DECLARE
  v_next_date DATE;
  v_today DATE := CURRENT_DATE;
  v_current_dow INTEGER := EXTRACT(DOW FROM CURRENT_DATE);
BEGIN
  CASE p_recurrence_type
    WHEN 'daily' THEN
      v_next_date := v_today + 1;
      
    WHEN 'weekly' THEN
      IF p_recurrence_day IS NULL THEN
        p_recurrence_day := v_current_dow;
      END IF;
      v_next_date := v_today + ((7 + p_recurrence_day - v_current_dow) % 7);
      IF v_next_date = v_today THEN
        v_next_date := v_next_date + 7;
      END IF;
      
    WHEN 'biweekly' THEN
      IF p_recurrence_day IS NULL THEN
        p_recurrence_day := v_current_dow;
      END IF;
      v_next_date := v_today + ((7 + p_recurrence_day - v_current_dow) % 7);
      IF v_next_date = v_today THEN
        v_next_date := v_next_date + 14;
      ELSE
        v_next_date := v_next_date + 7;
      END IF;
      
    WHEN 'monthly' THEN
      IF p_recurrence_day IS NULL THEN
        p_recurrence_day := EXTRACT(DAY FROM CURRENT_DATE)::INTEGER;
      END IF;
      v_next_date := make_date(
        EXTRACT(YEAR FROM v_today)::INTEGER,
        EXTRACT(MONTH FROM v_today)::INTEGER,
        LEAST(p_recurrence_day, 28)
      );
      IF v_next_date <= v_today THEN
        v_next_date := v_next_date + INTERVAL '1 month';
      END IF;
      
    ELSE
      v_next_date := v_today + 1;
  END CASE;
  
  RETURN (v_next_date::TEXT || ' ' || p_recurrence_time::TEXT)::TIMESTAMPTZ AT TIME ZONE p_timezone;
END;
$$;


--
-- Name: calculate_provider_health_score(numeric, numeric, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.calculate_provider_health_score(p_success_rate numeric, p_avg_latency_ms numeric, p_consecutive_failures integer) RETURNS integer
    LANGUAGE plpgsql
    SET search_path TO ''
    AS $$
DECLARE
  v_score INTEGER;
  v_success_component DECIMAL;
  v_latency_component DECIMAL;
  v_failure_penalty INTEGER;
BEGIN
  -- Success rate component (0-60 points)
  v_success_component := p_success_rate * 0.6;
  
  -- Latency component (0-30 points)
  -- Lower latency = higher score
  -- < 500ms = 30 points, 500-1000ms = 20 points, 1000-2000ms = 10 points, >2000ms = 0 points
  IF p_avg_latency_ms < 500 THEN
    v_latency_component := 30;
  ELSIF p_avg_latency_ms < 1000 THEN
    v_latency_component := 20;
  ELSIF p_avg_latency_ms < 2000 THEN
    v_latency_component := 10;
  ELSE
    v_latency_component := 0;
  END IF;
  
  -- Consecutive failure penalty (0-10 points penalty)
  v_failure_penalty := LEAST(p_consecutive_failures * 2, 10);
  
  -- Base score: 10 points (provider is operational)
  v_score := 10 + v_success_component + v_latency_component - v_failure_penalty;
  
  -- Clamp to 0-100
  v_score := GREATEST(0, LEAST(100, v_score));
  
  RETURN v_score;
END;
$$;


--
-- Name: FUNCTION calculate_provider_health_score(p_success_rate numeric, p_avg_latency_ms numeric, p_consecutive_failures integer); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.calculate_provider_health_score(p_success_rate numeric, p_avg_latency_ms numeric, p_consecutive_failures integer) IS 'Calculates composite health score (0-100) based on success rate, latency, and failures';


--
-- Name: calculate_trust_level(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.calculate_trust_level(p_profile_id uuid) RETURNS integer
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
DECLARE
  v_stats RECORD;
  v_days_since_join INTEGER;
  v_new_level INTEGER := 0;
  v_level RECORD;
BEGIN
  -- Get user stats
  SELECT * INTO v_stats FROM forum_user_stats WHERE profile_id = p_profile_id;
  
  IF NOT FOUND THEN
    RETURN 0;
  END IF;
  
  -- Check if level is locked
  IF v_stats.trust_level_locked THEN
    RETURN v_stats.trust_level;
  END IF;
  
  -- Check if user is silenced
  IF v_stats.silenced_until IS NOT NULL AND v_stats.silenced_until > now() THEN
    RETURN LEAST(v_stats.trust_level, 0); -- Demote to level 0 while silenced
  END IF;
  
  -- Calculate days since joining forum
  v_days_since_join := EXTRACT(DAY FROM now() - v_stats.joined_forum_at);
  
  -- Find highest qualifying level
  FOR v_level IN 
    SELECT * FROM forum_trust_levels ORDER BY level DESC
  LOOP
    IF v_days_since_join >= v_level.min_days_since_join
       AND COALESCE(v_stats.posts_read, 0) >= v_level.min_posts_read
       AND COALESCE(v_stats.topics_read, 0) >= v_level.min_topics_read
       AND COALESCE(v_stats.posts_count, 0) >= v_level.min_posts_created
       AND COALESCE(v_stats.comments_count, 0) >= v_level.min_topics_created
       AND COALESCE(v_stats.likes_given, 0) >= v_level.min_likes_given
       AND COALESCE(v_stats.likes_received, 0) >= v_level.min_likes_received
       AND COALESCE(v_stats.time_spent_minutes, 0) >= v_level.min_time_spent_minutes
    THEN
      v_new_level := v_level.level;
      EXIT;
    END IF;
  END LOOP;
  
  -- Update if level changed
  IF v_new_level != COALESCE(v_stats.trust_level, 0) THEN
    UPDATE forum_user_stats 
    SET trust_level = v_new_level, updated_at = now()
    WHERE profile_id = p_profile_id;
    
    -- Create notification for level up
    IF v_new_level > COALESCE(v_stats.trust_level, 0) THEN
      INSERT INTO forum_notifications (recipient_id, type, data)
      VALUES (p_profile_id, 'trust_level_up', jsonb_build_object(
        'old_level', v_stats.trust_level,
        'new_level', v_new_level
      ));
    END IF;
  END IF;
  
  RETURN v_new_level;
END;
$$;


--
-- Name: call_update_locations(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.call_update_locations() RETURNS trigger
    LANGUAGE plpgsql
    SET search_path TO 'public'
    AS $$
BEGIN
  PERFORM public.invoke_upstash_health_check();
  RETURN NEW;
END;
$$;


--
-- Name: call_update_post_coordinates(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.call_update_post_coordinates() RETURNS trigger
    LANGUAGE plpgsql
    SET search_path TO 'public'
    AS $$
BEGIN
  PERFORM public.invoke_update_post_coordinates();
  RETURN NEW;
END;
$$;


--
-- Name: cancel_arrangement(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.cancel_arrangement(p_post_id integer) RETURNS jsonb
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO ''
    AS $$
DECLARE
    v_post RECORD;
    v_caller_id UUID;
    v_notify_users UUID[];
BEGIN
    v_caller_id := auth.uid();
    SELECT * INTO v_post FROM public.posts WHERE id = p_post_id FOR UPDATE;

    IF v_post IS NULL THEN
        RETURN jsonb_build_object('success', false, 'error', jsonb_build_object('code', 'RESOURCE_NOT_FOUND', 'message', 'Post not found'), 'notifyUserIds', NULL);
    END IF;

    IF NOT v_post.is_arranged THEN
        RETURN jsonb_build_object('success', false, 'error', jsonb_build_object('code', 'RESOURCE_CONFLICT', 'message', 'This post is not currently arranged'), 'notifyUserIds', NULL);
    END IF;

    IF v_caller_id != v_post.profile_id AND v_caller_id != v_post.post_arranged_to THEN
        RETURN jsonb_build_object('success', false, 'error', jsonb_build_object('code', 'AUTH_FORBIDDEN', 'message', 'Only the owner or arranged user can cancel'), 'notifyUserIds', NULL);
    END IF;

    v_notify_users := ARRAY[]::UUID[];
    IF v_post.profile_id != v_caller_id THEN v_notify_users := array_append(v_notify_users, v_post.profile_id); END IF;
    IF v_post.post_arranged_to IS NOT NULL AND v_post.post_arranged_to != v_caller_id THEN v_notify_users := array_append(v_notify_users, v_post.post_arranged_to); END IF;

    INSERT INTO public.post_activity_logs (post_id, actor_id, activity_type, metadata)
    VALUES (p_post_id, v_caller_id, 'arrangement_cancelled', jsonb_build_object('cancelled_by', v_caller_id, 'previous_sharer', v_post.profile_id, 'previous_requester', v_post.post_arranged_to, 'cancelled_at', now()));

    UPDATE public.posts SET is_arranged = false, post_arranged_to = NULL, post_arranged_at = NULL, updated_at = now() WHERE id = p_post_id;

    RETURN jsonb_build_object('success', true, 'error', NULL, 'postId', p_post_id, 'postName', v_post.post_name, 'notifyUserIds', v_notify_users);
END;
$$;


--
-- Name: cancel_scheduled_post(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.cancel_scheduled_post(p_scheduled_id uuid) RETURNS boolean
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
BEGIN
  -- Verify ownership and status
  IF NOT EXISTS (
    SELECT 1 FROM forum_scheduled_posts 
    WHERE id = p_scheduled_id 
      AND profile_id = auth.uid() 
      AND status = 'scheduled'
  ) THEN
    RETURN false;
  END IF;
  
  -- Update status
  UPDATE forum_scheduled_posts
  SET status = 'cancelled', updated_at = now()
  WHERE id = p_scheduled_id;
  
  -- Remove from queue
  DELETE FROM forum_publication_queue
  WHERE scheduled_post_id = p_scheduled_id AND status = 'pending';
  
  RETURN true;
END;
$$;


--
-- Name: cast_poll_vote(uuid, uuid[]); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.cast_poll_vote(p_poll_id uuid, p_option_ids uuid[]) RETURNS jsonb
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
DECLARE
  v_user_id UUID := auth.uid();
  v_poll RECORD;
  v_option_id UUID;
  v_existing_votes UUID[];
BEGIN
  IF v_user_id IS NULL THEN
    RAISE EXCEPTION 'Not authenticated';
  END IF;
  
  -- Get poll details
  SELECT * INTO v_poll FROM public.forum_polls WHERE id = p_poll_id;
  
  IF v_poll IS NULL THEN
    RAISE EXCEPTION 'Poll not found';
  END IF;
  
  -- Check if poll has ended
  IF v_poll.ends_at IS NOT NULL AND v_poll.ends_at < now() THEN
    RAISE EXCEPTION 'Poll has ended';
  END IF;
  
  -- For single choice, only allow one option
  IF v_poll.poll_type = 'single' AND array_length(p_option_ids, 1) > 1 THEN
    RAISE EXCEPTION 'Single choice poll allows only one vote';
  END IF;
  
  -- Get existing votes
  SELECT array_agg(option_id) INTO v_existing_votes
  FROM public.forum_poll_votes
  WHERE poll_id = p_poll_id AND profile_id = v_user_id;
  
  -- For single choice, remove existing vote first
  IF v_poll.poll_type = 'single' AND v_existing_votes IS NOT NULL THEN
    DELETE FROM public.forum_poll_votes
    WHERE poll_id = p_poll_id AND profile_id = v_user_id;
    
    -- Decrement vote counts
    UPDATE public.forum_poll_options
    SET votes_count = GREATEST(0, votes_count - 1)
    WHERE id = ANY(v_existing_votes);
  END IF;
  
  -- Cast votes
  FOREACH v_option_id IN ARRAY p_option_ids
  LOOP
    -- Verify option belongs to poll
    IF NOT EXISTS (SELECT 1 FROM public.forum_poll_options WHERE id = v_option_id AND poll_id = p_poll_id) THEN
      RAISE EXCEPTION 'Invalid option for this poll';
    END IF;
    
    -- Insert vote (ignore if already exists for multiple choice)
    INSERT INTO public.forum_poll_votes (poll_id, option_id, profile_id)
    VALUES (p_poll_id, v_option_id, v_user_id)
    ON CONFLICT (poll_id, profile_id, option_id) DO NOTHING;
    
    -- Increment vote count if insert succeeded
    IF FOUND THEN
      UPDATE public.forum_poll_options
      SET votes_count = votes_count + 1
      WHERE id = v_option_id;
    END IF;
  END LOOP;
  
  -- Update total votes on poll
  UPDATE public.forum_polls
  SET total_votes = (
    SELECT COUNT(DISTINCT profile_id) FROM public.forum_poll_votes WHERE poll_id = p_poll_id
  ),
  updated_at = now()
  WHERE id = p_poll_id;
  
  -- Return updated poll with results
  RETURN (
    SELECT jsonb_build_object(
      'poll_id', p.id,
      'total_votes', p.total_votes,
      'user_votes', (
        SELECT array_agg(option_id) FROM public.forum_poll_votes 
        WHERE poll_id = p_poll_id AND profile_id = v_user_id
      ),
      'options', (
        SELECT jsonb_agg(jsonb_build_object(
          'id', o.id,
          'option_text', o.option_text,
          'votes_count', o.votes_count,
          'percentage', CASE WHEN p.total_votes > 0 
            THEN ROUND((o.votes_count::NUMERIC / p.total_votes) * 100, 1)
            ELSE 0 END
        ) ORDER BY o.sort_order)
        FROM public.forum_poll_options o WHERE o.poll_id = p_poll_id
      )
    )
    FROM public.forum_polls p WHERE p.id = p_poll_id
  );
END;
$$;


--
-- Name: check_and_award_badges(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.check_and_award_badges(p_profile_id uuid) RETURNS SETOF text
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
DECLARE
  v_stats RECORD;
  v_badge RECORD;
  v_awarded TEXT;
BEGIN
  -- Get user stats
  SELECT * INTO v_stats FROM public.forum_user_stats WHERE profile_id = p_profile_id;
  
  IF v_stats IS NULL THEN
    RETURN;
  END IF;
  
  -- Check each milestone badge
  FOR v_badge IN 
    SELECT * FROM public.forum_badges 
    WHERE badge_type = 'milestone' AND is_active = true
  LOOP
    -- Skip if already has badge
    IF EXISTS (
      SELECT 1 FROM public.forum_user_badges 
      WHERE profile_id = p_profile_id AND badge_id = v_badge.id
    ) THEN
      CONTINUE;
    END IF;
    
    -- Check criteria
    IF (v_badge.criteria->>'posts_count')::INT IS NOT NULL 
       AND v_stats.posts_count >= (v_badge.criteria->>'posts_count')::INT THEN
      INSERT INTO public.forum_user_badges (profile_id, badge_id)
      VALUES (p_profile_id, v_badge.id);
      
      -- Award reputation points
      IF v_badge.points > 0 THEN
        UPDATE public.forum_user_stats
        SET reputation_score = reputation_score + v_badge.points
        WHERE profile_id = p_profile_id;
      END IF;
      
      v_awarded := v_badge.name;
      RETURN NEXT v_awarded;
      
    ELSIF (v_badge.criteria->>'comments_count')::INT IS NOT NULL 
          AND v_stats.comments_count >= (v_badge.criteria->>'comments_count')::INT THEN
      INSERT INTO public.forum_user_badges (profile_id, badge_id)
      VALUES (p_profile_id, v_badge.id);
      
      IF v_badge.points > 0 THEN
        UPDATE public.forum_user_stats
        SET reputation_score = reputation_score + v_badge.points
        WHERE profile_id = p_profile_id;
      END IF;
      
      v_awarded := v_badge.name;
      RETURN NEXT v_awarded;
      
    ELSIF (v_badge.criteria->>'helpful_count')::INT IS NOT NULL 
          AND v_stats.helpful_count >= (v_badge.criteria->>'helpful_count')::INT THEN
      INSERT INTO public.forum_user_badges (profile_id, badge_id)
      VALUES (p_profile_id, v_badge.id);
      
      IF v_badge.points > 0 THEN
        UPDATE public.forum_user_stats
        SET reputation_score = reputation_score + v_badge.points
        WHERE profile_id = p_profile_id;
      END IF;
      
      v_awarded := v_badge.name;
      RETURN NEXT v_awarded;
      
    ELSIF (v_badge.criteria->>'reputation_score')::INT IS NOT NULL 
          AND v_stats.reputation_score >= (v_badge.criteria->>'reputation_score')::INT THEN
      INSERT INTO public.forum_user_badges (profile_id, badge_id)
      VALUES (p_profile_id, v_badge.id);
      
      v_awarded := v_badge.name;
      RETURN NEXT v_awarded;
      
    ELSIF (v_badge.criteria->>'followers_count')::INT IS NOT NULL 
          AND v_stats.followers_count >= (v_badge.criteria->>'followers_count')::INT THEN
      INSERT INTO public.forum_user_badges (profile_id, badge_id)
      VALUES (p_profile_id, v_badge.id);
      
      IF v_badge.points > 0 THEN
        UPDATE public.forum_user_stats
        SET reputation_score = reputation_score + v_badge.points
        WHERE profile_id = p_profile_id;
      END IF;
      
      v_awarded := v_badge.name;
      RETURN NEXT v_awarded;
    END IF;
  END LOOP;
  
  RETURN;
END;
$$;


--
-- Name: check_client_compatibility(text, text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.check_client_compatibility(p_platform text, p_version text) RETURNS jsonb
    LANGUAGE plpgsql STABLE SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
DECLARE
  v_req record;
  v_is_supported boolean;
  v_needs_update boolean;
BEGIN
  SELECT * INTO v_req
  FROM app_version_requirements
  WHERE platform = p_platform;

  IF v_req IS NULL THEN
    RETURN jsonb_build_object(
      'success', true,
      'supported', true,
      'needsUpdate', false,
      'forceUpdate', false
    );
  END IF;

  -- Compare versions (simple string comparison works for semver)
  v_is_supported := p_version >= v_req.min_version;
  v_needs_update := p_version < v_req.recommended_version;

  RETURN jsonb_build_object(
    'success', true,
    'supported', v_is_supported,
    'needsUpdate', v_needs_update,
    'forceUpdate', NOT v_is_supported,
    'currentVersion', p_version,
    'minVersion', v_req.min_version,
    'recommendedVersion', v_req.recommended_version,
    'message', CASE
      WHEN NOT v_is_supported THEN v_req.force_update_message
      WHEN v_needs_update THEN v_req.soft_update_message
      ELSE NULL
    END,
    'meta', jsonb_build_object('timestamp', NOW())
  );
END;
$$;


--
-- Name: FUNCTION check_client_compatibility(p_platform text, p_version text); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.check_client_compatibility(p_platform text, p_version text) IS 'Checks if client version is supported';


--
-- Name: check_for_duplicate_like(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.check_for_duplicate_like() RETURNS trigger
    LANGUAGE plpgsql
    SET search_path TO 'public'
    AS $$
BEGIN
  IF EXISTS (
    SELECT 1 FROM public.likes
    WHERE profile_id = NEW.profile_id
      AND post_id = NEW.post_id
  ) THEN
    RAISE EXCEPTION 'Duplicate like detected';
  END IF;
  RETURN NEW;
END;
$$;


--
-- Name: check_mfa_rate_limit(uuid, inet, text, integer, interval); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.check_mfa_rate_limit(p_profile_id uuid, p_ip_address inet, p_limit_type text, p_max_attempts integer DEFAULT 5, p_window_duration interval DEFAULT '00:15:00'::interval) RETURNS jsonb
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO ''
    AS $$
DECLARE
  v_record RECORD;
  v_is_allowed BOOLEAN;
  v_remaining INTEGER;
BEGIN
  SELECT * INTO v_record
  FROM mfa_rate_limits
  WHERE profile_id = p_profile_id
    AND ip_address = p_ip_address
    AND limit_type = p_limit_type
    AND window_start > (NOW() - p_window_duration)
  ORDER BY window_start DESC
  LIMIT 1;

  IF v_record.is_locked_out AND v_record.locked_until > NOW() THEN
    RETURN jsonb_build_object(
      'allowed', FALSE,
      'remaining', 0,
      'locked_until', v_record.locked_until,
      'reason', 'locked_out'
    );
  END IF;

  IF v_record.window_start IS NULL OR v_record.window_start <= (NOW() - p_window_duration) THEN
    INSERT INTO mfa_rate_limits (
      profile_id, ip_address, limit_type, max_attempts, window_duration
    ) VALUES (
      p_profile_id, p_ip_address, p_limit_type, p_max_attempts, p_window_duration
    )
    ON CONFLICT (profile_id, ip_address, limit_type, window_start)
    DO UPDATE SET attempt_count = 1, last_attempt_at = NOW();

    RETURN jsonb_build_object(
      'allowed', TRUE,
      'remaining', p_max_attempts - 1,
      'window_reset_at', NOW() + p_window_duration
    );
  END IF;

  v_remaining := p_max_attempts - v_record.attempt_count;
  v_is_allowed := v_record.attempt_count < p_max_attempts;

  UPDATE mfa_rate_limits
  SET
    attempt_count = attempt_count + 1,
    last_attempt_at = NOW(),
    is_locked_out = CASE WHEN attempt_count + 1 >= p_max_attempts THEN TRUE ELSE FALSE END,
    locked_until = CASE WHEN attempt_count + 1 >= p_max_attempts THEN NOW() + INTERVAL '1 hour' ELSE NULL END
  WHERE id = v_record.id;

  RETURN jsonb_build_object(
    'allowed', v_is_allowed,
    'remaining', GREATEST(v_remaining - 1, 0),
    'window_reset_at', v_record.window_start + p_window_duration,
    'attempts', v_record.attempt_count + 1
  );
END;
$$;


--
-- Name: check_platform_rate_limit(character varying, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.check_platform_rate_limit(p_identifier character varying, p_platform character varying) RETURNS jsonb
    LANGUAGE plpgsql
    SET search_path TO ''
    AS $$
DECLARE
  v_config RECORD;
  v_current_count INTEGER;
  v_window_start TIMESTAMPTZ;
  v_result JSONB;
BEGIN
  -- Get platform config
  SELECT * INTO v_config
  FROM translation_platform_config
  WHERE platform = p_platform;
  
  -- Use default if platform not found
  IF NOT FOUND THEN
    SELECT * INTO v_config
    FROM translation_platform_config
    WHERE platform = 'unknown';
  END IF;
  
  -- Get current rate limit record
  SELECT request_count, window_start
  INTO v_current_count, v_window_start
  FROM rate_limits
  WHERE identifier = p_identifier;
  
  -- If no record exists, create one
  IF NOT FOUND THEN
    INSERT INTO rate_limits (identifier, request_count, window_start)
    VALUES (p_identifier, 1, NOW())
    ON CONFLICT (identifier) DO UPDATE
    SET request_count = 1, window_start = NOW();
    
    RETURN jsonb_build_object(
      'allowed', true,
      'remaining', v_config.rate_limit_requests - 1,
      'reset_at', NOW() + (v_config.rate_limit_window_seconds || ' seconds')::INTERVAL
    );
  END IF;
  
  -- Check if window has expired
  IF v_window_start + (v_config.rate_limit_window_seconds || ' seconds')::INTERVAL < NOW() THEN
    UPDATE rate_limits
    SET request_count = 1, window_start = NOW()
    WHERE identifier = p_identifier;
    
    RETURN jsonb_build_object(
      'allowed', true,
      'remaining', v_config.rate_limit_requests - 1,
      'reset_at', NOW() + (v_config.rate_limit_window_seconds || ' seconds')::INTERVAL
    );
  END IF;
  
  -- Check if under limit
  IF v_current_count < v_config.rate_limit_requests THEN
    UPDATE rate_limits
    SET request_count = request_count + 1
    WHERE identifier = p_identifier;
    
    RETURN jsonb_build_object(
      'allowed', true,
      'remaining', v_config.rate_limit_requests - v_current_count - 1,
      'reset_at', v_window_start + (v_config.rate_limit_window_seconds || ' seconds')::INTERVAL
    );
  END IF;
  
  -- Rate limit exceeded
  RETURN jsonb_build_object(
    'allowed', false,
    'remaining', 0,
    'reset_at', v_window_start + (v_config.rate_limit_window_seconds || ' seconds')::INTERVAL,
    'retry_after', EXTRACT(EPOCH FROM (v_window_start + (v_config.rate_limit_window_seconds || ' seconds')::INTERVAL - NOW()))::INTEGER
  );
END;
$$;


--
-- Name: check_provider_quota(text, date); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.check_provider_quota(p_provider text, p_date date DEFAULT CURRENT_DATE) RETURNS boolean
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO ''
    AS $$
DECLARE
  v_emails_sent INTEGER;
  v_daily_limit INTEGER;
BEGIN
  SELECT emails_sent, daily_limit
  INTO v_emails_sent, v_daily_limit
  FROM public.email_provider_quota
  WHERE provider = p_provider AND date = p_date;

  IF NOT FOUND THEN
    RETURN true;
  END IF;

  RETURN v_emails_sent < v_daily_limit;
END;
$$;


--
-- Name: check_provider_rate_limit(text, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.check_provider_rate_limit(p_provider text, p_max_per_minute integer DEFAULT 10) RETURNS boolean
    LANGUAGE plpgsql
    SET search_path TO ''
    AS $$
DECLARE
  v_current_count INTEGER;
  v_window_start TIMESTAMP WITH TIME ZONE;
BEGIN
  -- Get current metrics
  SELECT requests_in_current_minute, minute_window_start
  INTO v_current_count, v_window_start
  FROM email_provider_health_metrics
  WHERE provider = p_provider;
  
  IF NOT FOUND THEN
    RETURN TRUE; -- No metrics yet, allow
  END IF;
  
  -- Check if we're in a new minute window
  IF NOW() - v_window_start > INTERVAL '1 minute' THEN
    -- Reset counter for new window
    UPDATE email_provider_health_metrics
    SET 
      requests_in_current_minute = 1,
      minute_window_start = NOW()
    WHERE provider = p_provider;
    RETURN TRUE;
  END IF;
  
  -- Check if under limit
  IF v_current_count < p_max_per_minute THEN
    -- Increment counter
    UPDATE email_provider_health_metrics
    SET requests_in_current_minute = requests_in_current_minute + 1
    WHERE provider = p_provider;
    RETURN TRUE;
  END IF;
  
  -- Rate limit exceeded
  RETURN FALSE;
END;
$$;


--
-- Name: FUNCTION check_provider_rate_limit(p_provider text, p_max_per_minute integer); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.check_provider_rate_limit(p_provider text, p_max_per_minute integer) IS 'Checks if provider is within rate limit (default 10 req/min)';


--
-- Name: check_quiet_hours(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.check_quiet_hours(p_user_id uuid) RETURNS boolean
    LANGUAGE plpgsql STABLE SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
DECLARE
  v_prefs jsonb;
  v_enabled boolean;
  v_start time;
  v_end time;
  v_now time;
BEGIN
  SELECT notification_preferences INTO v_prefs
  FROM profiles
  WHERE id = p_user_id;

  v_enabled := COALESCE((v_prefs->>'quiet_hours_enabled')::boolean, false);

  IF NOT v_enabled THEN
    RETURN false;
  END IF;

  v_start := COALESCE(v_prefs->>'quiet_hours_start', '22:00')::time;
  v_end := COALESCE(v_prefs->>'quiet_hours_end', '08:00')::time;
  v_now := LOCALTIME;

  -- Handle time range spanning midnight
  IF v_start > v_end THEN
    -- e.g., 22:00 to 08:00
    RETURN v_now >= v_start OR v_now < v_end;
  ELSE
    -- e.g., 01:00 to 06:00
    RETURN v_now >= v_start AND v_now < v_end;
  END IF;
END;
$$;


--
-- Name: FUNCTION check_quiet_hours(p_user_id uuid); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.check_quiet_hours(p_user_id uuid) IS 'Checks if user is currently in quiet hours';


--
-- Name: check_rate_limit(text, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.check_rate_limit(p_identifier text, p_max_requests integer DEFAULT 100, p_window_seconds integer DEFAULT 3600) RETURNS boolean
    LANGUAGE plpgsql
    SET search_path TO ''
    AS $$
DECLARE
  v_current_count INTEGER;
  v_window_start_time TIMESTAMPTZ;
BEGIN
  -- Get current rate limit record
  SELECT request_count, window_start
  INTO v_current_count, v_window_start_time
  FROM rate_limits
  WHERE identifier = p_identifier;

  -- If no record exists, create one
  IF NOT FOUND THEN
    INSERT INTO rate_limits (identifier, request_count, window_start)
    VALUES (p_identifier, 1, NOW())
    ON CONFLICT (identifier) DO UPDATE
    SET request_count = 1, window_start = NOW();
    RETURN TRUE;
  END IF;

  -- Check if window has expired
  IF v_window_start_time + (p_window_seconds || ' seconds')::INTERVAL < NOW() THEN
    -- Reset window
    UPDATE rate_limits
    SET request_count = 1, window_start = NOW()
    WHERE identifier = p_identifier;
    RETURN TRUE;
  END IF;

  -- Check if under limit
  IF v_current_count < p_max_requests THEN
    -- Increment counter
    UPDATE rate_limits
    SET request_count = request_count + 1
    WHERE identifier = p_identifier;
    RETURN TRUE;
  END IF;

  -- Rate limit exceeded
  RETURN FALSE;
END;
$$;


--
-- Name: check_rate_limit(uuid, text, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.check_rate_limit(user_id uuid, operation text, max_requests integer, time_window_seconds integer) RETURNS boolean
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO ''
    AS $$
DECLARE
  request_count integer;
  is_within_limit boolean;
BEGIN
  -- Count recent requests for this user and operation
  SELECT COUNT(*) INTO request_count
  FROM audit.vault_access_log
  WHERE vault_access_log.user_id = check_rate_limit.user_id
    AND vault_access_log.secret_name = check_rate_limit.operation
    AND accessed_at > NOW() - (time_window_seconds || ' seconds')::interval;

  -- Check if under limit
  is_within_limit := request_count < max_requests;

  -- Return true if within limit, false if exceeded
  RETURN is_within_limit;
END;
$$;


--
-- Name: FUNCTION check_rate_limit(user_id uuid, operation text, max_requests integer, time_window_seconds integer); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.check_rate_limit(user_id uuid, operation text, max_requests integer, time_window_seconds integer) IS 'Check if user has exceeded rate limit for a specific operation.

SECURITY:
- Used by Edge Functions to prevent abuse
- Queries audit log for recent requests
- Returns boolean (true = within limit, false = exceeded)

USAGE (Edge Functions):
  const withinLimit = await supabase.rpc("check_rate_limit", {
    user_id: user.id,
    operation: "cache_operation",
    max_requests: 60,
    time_window_seconds: 60
  });

  if (!withinLimit) {
    return new Response("Rate limit exceeded", { status: 429 });
  }

PARAMETERS:
- user_id: UUID of user
- operation: Operation name (e.g., "cache_operation", "geocode")
- max_requests: Maximum requests allowed
- time_window_seconds: Time window for rate limit

RETURNS:
- true if within limit
- false if exceeded';


--
-- Name: check_trust_permission(uuid, text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.check_trust_permission(p_profile_id uuid, p_permission text) RETURNS boolean
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $_$
DECLARE
  v_trust_level INTEGER;
  v_can_do BOOLEAN;
BEGIN
  -- Get user's trust level
  SELECT trust_level INTO v_trust_level 
  FROM forum_user_stats 
  WHERE profile_id = p_profile_id;
  
  v_trust_level := COALESCE(v_trust_level, 0);
  
  -- Check permission based on trust level
  EXECUTE format(
    'SELECT %I FROM forum_trust_levels WHERE level = $1',
    p_permission
  ) INTO v_can_do USING v_trust_level;
  
  RETURN COALESCE(v_can_do, false);
END;
$_$;


--
-- Name: check_vault_secret_exists(text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.check_vault_secret_exists(secret_name text) RETURNS boolean
    LANGUAGE sql SECURITY DEFINER
    SET search_path TO 'vault'
    AS $$
  SELECT EXISTS (
    SELECT 1 FROM vault.decrypted_secrets WHERE name = secret_name
  );
$$;


--
-- Name: FUNCTION check_vault_secret_exists(secret_name text); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.check_vault_secret_exists(secret_name text) IS 'Check if a secret exists in Vault without revealing its value.

SECURITY:
- Accessible by service_role only
- Does not return secret values
- Safe for existence checks

USAGE (Edge Functions):
  const exists = await supabase.rpc("check_vault_secret_exists", {
    secret_name: "RESEND_API_KEY"
  });

PARAMETERS:
- secret_name: Name of secret to check

RETURNS:
- true if secret exists
- false if secret does not exist';


--
-- Name: claim_challenge_reward(uuid, uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.claim_challenge_reward(p_user_id uuid, p_challenge_id uuid) RETURNS jsonb
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
DECLARE
  v_challenge RECORD;
  v_activity RECORD;
  v_points_awarded INT;
  v_new_total_points INT;
BEGIN
  -- Get challenge details
  SELECT * INTO v_challenge
  FROM challenges
  WHERE id = p_challenge_id;

  IF NOT FOUND THEN
    RETURN jsonb_build_object(
      'success', FALSE,
      'error', 'Challenge not found'
    );
  END IF;

  -- Get user's activity for this challenge
  SELECT * INTO v_activity
  FROM challenge_activities
  WHERE challenge_id = p_challenge_id
    AND user_completed_challenge = p_user_id
  LIMIT 1;

  IF NOT FOUND THEN
    RETURN jsonb_build_object(
      'success', FALSE,
      'error', 'Challenge not completed'
    );
  END IF;

  -- Award points (simplified - extend as needed)
  v_points_awarded := v_challenge.challenge_score;
  
  -- Calculate new total (would update user profile in real implementation)
  SELECT COALESCE(SUM(c.challenge_score), 0) + v_points_awarded
  INTO v_new_total_points
  FROM challenge_activities ca
  JOIN challenges c ON c.id = ca.challenge_id
  WHERE ca.user_completed_challenge = p_user_id;

  RETURN jsonb_build_object(
    'success', TRUE,
    'points_awarded', v_points_awarded,
    'new_total_points', v_new_total_points,
    'badge_id', NULL,
    'badge_name', NULL,
    'badge_icon_url', NULL
  );
END;
$$;


--
-- Name: FUNCTION claim_challenge_reward(p_user_id uuid, p_challenge_id uuid); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.claim_challenge_reward(p_user_id uuid, p_challenge_id uuid) IS 'Claims reward for completed challenge';


--
-- Name: claim_queue_item(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.claim_queue_item(p_queue_id uuid) RETURNS boolean
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
BEGIN
  UPDATE forum_moderation_queue
  SET assigned_to = auth.uid(), assigned_at = now(), status = 'in_review', updated_at = now()
  WHERE id = p_queue_id AND status = 'pending';
  
  RETURN FOUND;
END;
$$;


--
-- Name: clean_blog_content(text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.clean_blog_content(content text) RETURNS text
    LANGUAGE plpgsql
    SET search_path TO ''
    AS $_$
DECLARE
  result text := content;
BEGIN
  -- Remove Twitter hashtag links
  result := regexp_replace(result, '<a\s+href="[^"]*twitter\.com/hashtag[^"]*"[^>]*>#\w+</a>\s*', '', 'gi');
  
  -- Remove LinkedIn hashtag links
  result := regexp_replace(result, '<a\s+href="[^"]*linkedin\.com/feed/hashtag[^"]*"[^>]*>#\w+</a>\s*', '', 'gi');
  
  -- Remove plain hashtag paragraphs at end
  result := regexp_replace(result, '<p>\s*(#\w+\s*)+</p>\s*$', '', 'gi');
  
  -- Remove inline hashtag sequences (3+ hashtags in a row)
  result := regexp_replace(result, '(<br\s*/?>|\n)\s*(#\w+\s*){3,}', '', 'gi');
  
  -- Remove signature lines
  result := regexp_replace(result, '<br\s*/?>--<br\s*/?>Join us on our foodshare\.club[^<]*', '', 'gi');
  result := regexp_replace(result, '--<br\s*/?>Join us on our foodshare\.club[^<]*', '', 'gi');
  result := regexp_replace(result, '<br\s*/?>Join us on our foodshare\.club[^<]*', '', 'gi');
  result := regexp_replace(result, 'Join us on our foodshare\.club[^<]*', '', 'gi');
  
  -- Clean up empty paragraphs
  result := regexp_replace(result, '<p>\s*</p>', '', 'gi');
  result := regexp_replace(result, '<p>\s*<br\s*/?>\s*</p>', '', 'gi');
  
  -- Clean up multiple br tags
  result := regexp_replace(result, '(<br\s*/?>\s*){3,}', '<br><br>', 'gi');
  
  -- Clean up trailing br before /p
  result := regexp_replace(result, '(<br\s*/?>\s*)+</p>', '</p>', 'gi');
  
  RETURN trim(result);
END;
$_$;


--
-- Name: cleanup_cron_logs(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.cleanup_cron_logs(retention_days integer DEFAULT 7) RETURNS TABLE(status text, action text, details text)
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public', 'cron'
    AS $$
BEGIN
  RETURN QUERY
  WITH deleted AS (
    DELETE FROM cron.job_run_details
    WHERE end_time < NOW() - (retention_days || ' days')::interval
    RETURNING *
  )
  SELECT 
    'success'::text,
    'cleanup'::text,
    'Deleted ' || COUNT(*)::text || ' old cron logs' as details
  FROM deleted;
END;
$$;


--
-- Name: cleanup_expired_feed_cells(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.cleanup_expired_feed_cells() RETURNS integer
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
DECLARE
  v_deleted integer;
BEGIN
  -- Delete expired cells that haven't been accessed recently
  DELETE FROM precomputed_feed_cells
  WHERE expires_at < NOW() - INTERVAL '1 hour'
    OR (expires_at < NOW() AND access_count < 5);

  GET DIAGNOSTICS v_deleted = ROW_COUNT;

  RETURN v_deleted;
END;
$$;


--
-- Name: FUNCTION cleanup_expired_feed_cells(); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.cleanup_expired_feed_cells() IS 'Cleans up expired feed cache cells';


--
-- Name: cleanup_expired_translations(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.cleanup_expired_translations() RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
  v_deleted_count INTEGER;
BEGIN
  DELETE FROM content_translations
  WHERE expires_at < NOW()
    AND hit_count < 5; -- Keep popular translations even if expired
  
  GET DIAGNOSTICS v_deleted_count = ROW_COUNT;
  RETURN v_deleted_count;
END;
$$;


--
-- Name: FUNCTION cleanup_expired_translations(); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.cleanup_expired_translations() IS 'Run daily via pg_cron: SELECT cron.schedule(''cleanup-translations'', ''0 2 * * *'', ''SELECT cleanup_expired_translations()'')';


--
-- Name: cleanup_forum_rate_limits(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.cleanup_forum_rate_limits() RETURNS integer
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
DECLARE
  v_deleted INTEGER;
BEGIN
  DELETE FROM forum_rate_limits
  WHERE window_end < now() - INTERVAL '1 day'
     OR created_at < now() - INTERVAL '7 days';
  
  GET DIAGNOSTICS v_deleted = ROW_COUNT;
  RETURN v_deleted;
END;
$$;


--
-- Name: cleanup_old_analytics(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.cleanup_old_analytics(p_days integer DEFAULT 90) RETURNS jsonb
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
DECLARE v_views INT; v_api INT;
BEGIN WITH dv AS (DELETE FROM post_views WHERE created_at < NOW() - (p_days || ' days')::INTERVAL RETURNING id) SELECT COUNT(*) INTO v_views FROM dv; WITH da AS (DELETE FROM api_analytics WHERE created_at < NOW() - (p_days || ' days')::INTERVAL RETURNING id) SELECT COUNT(*) INTO v_api FROM da; RETURN jsonb_build_object('success', true, 'views_deleted', v_views, 'api_deleted', v_api);
EXCEPTION WHEN OTHERS THEN RETURN jsonb_build_object('success', false, 'error', jsonb_build_object('code', 'SERVER_ERROR', 'message', SQLERRM));
END;
$$;


--
-- Name: cleanup_old_audit_logs(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.cleanup_old_audit_logs() RETURNS void
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
BEGIN
  DELETE FROM email_audit_log
  WHERE created_at < NOW() - INTERVAL '1 year'
  AND severity = 'info'; -- Keep warning and critical longer

  DELETE FROM email_audit_log
  WHERE created_at < NOW() - INTERVAL '2 years'
  AND severity IN ('warning', 'critical');
END;
$$;


--
-- Name: FUNCTION cleanup_old_audit_logs(); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.cleanup_old_audit_logs() IS 'Clean up audit logs older than retention period (1 year for info, 2 years for warning/critical)';


--
-- Name: cleanup_old_digest_queue(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.cleanup_old_digest_queue(p_days_old integer DEFAULT 7) RETURNS integer
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
DECLARE
  v_count integer;
BEGIN
  DELETE FROM notification_digest_queue
  WHERE status IN ('sent', 'failed', 'expired')
    AND (sent_at < NOW() - (p_days_old || ' days')::interval
         OR (sent_at IS NULL AND created_at < NOW() - (p_days_old || ' days')::interval));

  GET DIAGNOSTICS v_count = ROW_COUNT;
  RETURN v_count;
END;
$$;


--
-- Name: FUNCTION cleanup_old_digest_queue(p_days_old integer); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.cleanup_old_digest_queue(p_days_old integer) IS 'Removes old processed digest queue entries for cleanup';


--
-- Name: cleanup_old_drafts(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.cleanup_old_drafts() RETURNS integer
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
DECLARE
  v_deleted INT;
BEGIN
  DELETE FROM public.forum_drafts
  WHERE last_saved_at < now() - INTERVAL '30 days';
  
  GET DIAGNOSTICS v_deleted = ROW_COUNT;
  RETURN v_deleted;
END;
$$;


--
-- Name: cleanup_old_events(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.cleanup_old_events(p_days integer DEFAULT 90) RETURNS integer
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
DECLARE
  v_deleted integer;
BEGIN
  DELETE FROM user_events
  WHERE created_at < NOW() - (p_days || ' days')::interval;

  GET DIAGNOSTICS v_deleted = ROW_COUNT;

  RETURN v_deleted;
END;
$$;


--
-- Name: FUNCTION cleanup_old_events(p_days integer); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.cleanup_old_events(p_days integer) IS 'Removes old user events for data retention';


--
-- Name: cleanup_old_geocode_queue(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.cleanup_old_geocode_queue(days_old integer DEFAULT 30) RETURNS integer
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO ''
    AS $$
DECLARE
  deleted_count INTEGER;
BEGIN
  DELETE FROM public.location_update_queue
  WHERE status = 'completed'
    AND completed_at < NOW() - (days_old || ' days')::INTERVAL;

  GET DIAGNOSTICS deleted_count = ROW_COUNT;

  RAISE LOG 'Cleaned up % old geocode queue entries', deleted_count;

  RETURN deleted_count;
END;
$$;


--
-- Name: FUNCTION cleanup_old_geocode_queue(days_old integer); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.cleanup_old_geocode_queue(days_old integer) IS 'Delete completed geocode queue entries older than specified days (default 30)';


--
-- Name: cleanup_old_health_events(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.cleanup_old_health_events() RETURNS void
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO ''
    AS $$
BEGIN
  DELETE FROM email_health_events
  WHERE created_at < NOW() - INTERVAL '30 days';
END;
$$;


--
-- Name: cleanup_old_image_metrics(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.cleanup_old_image_metrics() RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
  DELETE FROM image_upload_metrics
  WHERE uploaded_at < NOW() - INTERVAL '90 days';
END;
$$;


--
-- Name: cleanup_old_metrics(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.cleanup_old_metrics() RETURNS integer
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public', 'pg_temp'
    AS $$
DECLARE
    v_deleted INT := 0;
    v_count INT;
BEGIN
    DELETE FROM metrics.api_requests WHERE created_at < now() - interval '7 days';
    GET DIAGNOSTICS v_count = ROW_COUNT; v_deleted := v_deleted + v_count;

    DELETE FROM metrics.circuit_breaker_events WHERE created_at < now() - interval '30 days';
    GET DIAGNOSTICS v_count = ROW_COUNT; v_deleted := v_deleted + v_count;

    DELETE FROM metrics.health_checks WHERE created_at < now() - interval '7 days';
    GET DIAGNOSTICS v_count = ROW_COUNT; v_deleted := v_deleted + v_count;

    DELETE FROM metrics.api_hourly_stats WHERE hour < now() - interval '90 days';
    GET DIAGNOSTICS v_count = ROW_COUNT; v_deleted := v_deleted + v_count;

    DELETE FROM metrics.alerts WHERE acknowledged = true AND created_at < now() - interval '30 days';
    GET DIAGNOSTICS v_count = ROW_COUNT; v_deleted := v_deleted + v_count;

    RETURN v_deleted;
END;
$$;


--
-- Name: FUNCTION cleanup_old_metrics(); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.cleanup_old_metrics() IS 'Removes old metrics data to prevent unbounded growth';


--
-- Name: cleanup_old_notifications(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.cleanup_old_notifications() RETURNS void
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
BEGIN
    -- Delete delivered notifications older than 90 days
    DELETE FROM notification_delivery_log
    WHERE created_at < NOW() - INTERVAL '90 days'
        AND status = 'delivered';

    -- Delete failed notifications older than 30 days
    DELETE FROM notification_delivery_log
    WHERE created_at < NOW() - INTERVAL '30 days'
        AND status = 'failed';

    -- Delete old queue items
    DELETE FROM notification_queue
    WHERE created_at < NOW() - INTERVAL '30 days'
        AND status IN ('delivered', 'failed', 'cancelled');

    -- Delete sent digest items older than 7 days
    DELETE FROM notification_digest_queue
    WHERE created_at < NOW() - INTERVAL '7 days'
        AND status = 'sent';

    -- Delete read in-app notifications older than 30 days
    DELETE FROM in_app_notifications
    WHERE read_at < NOW() - INTERVAL '30 days';

    -- Delete expired email suppressions
    DELETE FROM email_suppressions
    WHERE expires_at IS NOT NULL
        AND expires_at < NOW();
END;
$$;


--
-- Name: FUNCTION cleanup_old_notifications(); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.cleanup_old_notifications() IS 'Cleanup old notification records (run via cron)';


--
-- Name: cleanup_old_queue_items(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.cleanup_old_queue_items() RETURNS integer
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO ''
    AS $$
DECLARE
  v_deleted_count INTEGER;
BEGIN
  DELETE FROM public.email_queue
  WHERE status IN ('completed', 'failed')
    AND created_at < now() - INTERVAL '30 days';

  GET DIAGNOSTICS v_deleted_count = ROW_COUNT;
  RETURN v_deleted_count;
END;
$$;


--
-- Name: cleanup_old_telegram_states(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.cleanup_old_telegram_states() RETURNS void
    LANGUAGE plpgsql
    SET search_path TO ''
    AS $$
BEGIN
  DELETE FROM telegram_user_states 
  WHERE updated_at < NOW() - INTERVAL '24 hours';
END;
$$;


--
-- Name: clear_forum_search_history(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.clear_forum_search_history() RETURNS boolean
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
BEGIN
  DELETE FROM forum_search_history WHERE profile_id = auth.uid();
  RETURN true;
END;
$$;


--
-- Name: clear_reading_history(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.clear_reading_history() RETURNS boolean
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
BEGIN
  DELETE FROM forum_reading_history WHERE profile_id = auth.uid();
  DELETE FROM forum_reading_progress WHERE profile_id = auth.uid();
  RETURN true;
END;
$$;


--
-- Name: complete_challenge(uuid, bigint, jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.complete_challenge(p_user_id uuid, p_challenge_id bigint, p_proof_data jsonb DEFAULT NULL::jsonb) RETURNS jsonb
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
DECLARE
  v_participation RECORD;
  v_challenge RECORD;
  v_new_total_score INTEGER;
BEGIN
  SELECT * INTO v_participation
  FROM challenge_participants
  WHERE challenge_id = p_challenge_id AND profile_id = p_user_id;

  IF v_participation IS NULL THEN
    RETURN jsonb_build_object('success', FALSE, 'error', 'You have not joined this challenge');
  END IF;

  IF v_participation.is_completed THEN
    RETURN jsonb_build_object('success', FALSE, 'error', 'Challenge already completed');
  END IF;

  SELECT * INTO v_challenge FROM challenges WHERE id = p_challenge_id;

  UPDATE challenge_participants
  SET is_completed = TRUE, completed_at = NOW()
  WHERE challenge_id = p_challenge_id AND profile_id = p_user_id;

  SELECT COALESCE(SUM(c.challenge_score), 0) INTO v_new_total_score
  FROM challenge_participants cp
  JOIN challenges c ON cp.challenge_id = c.id
  WHERE cp.profile_id = p_user_id AND cp.is_completed = TRUE;

  INSERT INTO user_notifications (
    user_id, notification_type, title, body, data, created_at
  ) VALUES (
    p_user_id,
    'challenge_completed',
    'Challenge Completed! ',
    'You completed "' || v_challenge.challenge_title || '" and earned ' || v_challenge.challenge_score || ' points!',
    jsonb_build_object('challengeId', p_challenge_id, 'score', v_challenge.challenge_score, 'totalScore', v_new_total_score),
    NOW()
  );

  RETURN jsonb_build_object(
    'success', TRUE,
    'message', 'Challenge completed!',
    'reward', jsonb_build_object(
      'score', v_challenge.challenge_score,
      'totalScore', v_new_total_score
    )
  );
END;
$$;


--
-- Name: complete_transaction(bigint, uuid, uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.complete_transaction(p_post_id bigint, p_sharer_id uuid, p_receiver_id uuid) RETURNS jsonb
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
DECLARE
  v_post_owner_id UUID;
BEGIN
  -- Verify sharer owns the post
  SELECT profile_id INTO v_post_owner_id FROM posts WHERE id = p_post_id;
  
  IF v_post_owner_id != p_sharer_id THEN
    RETURN jsonb_build_object('success', FALSE, 'error', 'Not authorized');
  END IF;

  -- Update post
  UPDATE posts SET
    is_arranged = TRUE,
    post_arranged_to = p_receiver_id,
    post_arranged_at = NOW(),
    is_active = FALSE
  WHERE id = p_post_id;

  -- Update sharer stats
  INSERT INTO profile_stats (profile_id, items_shared, created_at, updated_at)
  VALUES (p_sharer_id, 1, NOW(), NOW())
  ON CONFLICT (profile_id) DO UPDATE SET
    items_shared = COALESCE(profile_stats.items_shared, 0) + 1,
    updated_at = NOW();

  -- Update receiver stats
  INSERT INTO profile_stats (profile_id, items_received, created_at, updated_at)
  VALUES (p_receiver_id, 1, NOW(), NOW())
  ON CONFLICT (profile_id) DO UPDATE SET
    items_received = COALESCE(profile_stats.items_received, 0) + 1,
    updated_at = NOW();

  -- Notifications handled by trigger (notify_post_arranged)

  RETURN jsonb_build_object(
    'success', TRUE,
    'post_id', p_post_id,
    'completed_at', NOW()
  );
END;
$$;


--
-- Name: compute_feed_for_cell(text, double precision, double precision, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.compute_feed_for_cell(p_cell_id text, p_lat double precision, p_lng double precision, p_radius_km integer DEFAULT 10, p_limit integer DEFAULT 50) RETURNS jsonb
    LANGUAGE plpgsql STABLE SECURITY DEFINER
    SET search_path TO 'public', 'extensions'
    AS $$
DECLARE
  v_items jsonb;
  v_start_time timestamptz := clock_timestamp();
  v_computation_ms integer;
  v_search_point geography;
BEGIN
  -- Create search point for distance calculations
  v_search_point := ST_SetSRID(ST_MakePoint(p_lng, p_lat), 4326)::geography;

  SELECT COALESCE(jsonb_agg(item ORDER BY (item->>'score')::integer DESC), '[]'::jsonb)
  INTO v_items
  FROM (
    SELECT jsonb_build_object(
      'id', po.id,
      'postName', po.post_name,
      'description', CASE
        WHEN length(po.post_description) > 100
        THEN substring(po.post_description, 1, 100) || '...'
        ELSE po.post_description
      END,
      'postType', po.post_type,
      'thumbnail', CASE
        WHEN po.images IS NOT NULL AND array_length(po.images, 1) > 0
        THEN po.images[1]
        ELSE NULL
      END,
      'images', po.images,
      'location', jsonb_build_object(
        'latitude', ST_Y(po.location::geometry),
        'longitude', ST_X(po.location::geometry),
        'address', po.post_address
      ),
      'categoryId', po.category_id,
      'createdAt', po.created_at,
      'distanceKm', ROUND((ST_Distance(po.location, v_search_point) / 1000)::numeric, 1),
      'profile', jsonb_build_object(
        'id', p.id,
        'nickname', p.nickname,
        'avatarUrl', p.avatar_url,
        'rating', COALESCE(ps.rating_average, 0)
      ),
      'freshnessDays', EXTRACT(DAY FROM NOW() - po.created_at)::integer,
      'score', (
        GREATEST(0, 40 - ((ST_Distance(po.location, v_search_point) / 1000) / p_radius_km * 40))
        + GREATEST(0, 30 - (EXTRACT(DAY FROM NOW() - po.created_at) * 2))
        + (COALESCE(ps.rating_average, 0) / 5 * 30)
      )::integer
    ) AS item
    FROM posts po
    LEFT JOIN profiles p ON p.id = po.profile_id
    LEFT JOIN profile_stats ps ON ps.profile_id = po.profile_id
    WHERE po.is_active = true
      AND po.post_type = 'food'
      AND po.location IS NOT NULL
      AND ST_DWithin(po.location, v_search_point, p_radius_km * 1000)
    ORDER BY (
      GREATEST(0, 40 - ((ST_Distance(po.location, v_search_point) / 1000) / p_radius_km * 40))
      + GREATEST(0, 30 - (EXTRACT(DAY FROM NOW() - po.created_at) * 2))
      + (COALESCE(ps.rating_average, 0) / 5 * 30)
    ) DESC
    LIMIT p_limit
  ) sub;

  v_computation_ms := EXTRACT(MILLISECONDS FROM (clock_timestamp() - v_start_time))::integer;

  INSERT INTO precomputed_feed_cells (
    cell_id, center_lat, center_lng, radius_km,
    feed_data, item_count, computed_at, expires_at,
    computation_time_ms, access_count, last_accessed_at
  ) VALUES (
    p_cell_id, p_lat, p_lng, p_radius_km,
    v_items, jsonb_array_length(v_items), NOW(), NOW() + INTERVAL '5 minutes',
    v_computation_ms, 1, NOW()
  )
  ON CONFLICT (cell_id) DO UPDATE SET
    feed_data = EXCLUDED.feed_data,
    item_count = EXCLUDED.item_count,
    computed_at = EXCLUDED.computed_at,
    expires_at = EXCLUDED.expires_at,
    computation_time_ms = EXCLUDED.computation_time_ms,
    version = precomputed_feed_cells.version + 1;

  RETURN v_items;
END;
$$;


--
-- Name: count_new_profiles_within_radius(double precision, double precision, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.count_new_profiles_within_radius(lat double precision, lng double precision, radius_meters integer DEFAULT 10000, days_ago integer DEFAULT 30) RETURNS integer
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
DECLARE
  count_result INTEGER;
BEGIN
  SELECT COUNT(*)::INTEGER INTO count_result
  FROM profiles p
  WHERE p.location IS NOT NULL
    AND ST_DWithin(
      p.location::geography,
      ST_SetSRID(ST_MakePoint(lng, lat), 4326)::geography,
      radius_meters
    )
    AND p.deleted_at IS NULL
    AND p.created_at >= NOW() - (days_ago || ' days')::INTERVAL;

  RETURN COALESCE(count_result, 0);
END;
$$;


--
-- Name: FUNCTION count_new_profiles_within_radius(lat double precision, lng double precision, radius_meters integer, days_ago integer); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.count_new_profiles_within_radius(lat double precision, lng double precision, radius_meters integer, days_ago integer) IS 'Count new profiles within a given radius created in the last N days';


--
-- Name: count_posts_within_radius(double precision, double precision, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.count_posts_within_radius(lat double precision, lng double precision, radius_meters integer DEFAULT 10000, days_ago integer DEFAULT 7) RETURNS integer
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
DECLARE
  count_result INTEGER;
BEGIN
  SELECT COUNT(*)::INTEGER INTO count_result
  FROM posts p
  WHERE p.location IS NOT NULL
    AND ST_DWithin(
      p.location::geography,
      ST_SetSRID(ST_MakePoint(lng, lat), 4326)::geography,
      radius_meters
    )
    AND p.is_active = true
    AND p.deleted_at IS NULL
    AND p.created_at >= NOW() - (days_ago || ' days')::INTERVAL;

  RETURN COALESCE(count_result, 0);
END;
$$;


--
-- Name: FUNCTION count_posts_within_radius(lat double precision, lng double precision, radius_meters integer, days_ago integer); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.count_posts_within_radius(lat double precision, lng double precision, radius_meters integer, days_ago integer) IS 'Count active posts within a given radius created in the last N days';


--
-- Name: count_profiles_within_radius(double precision, double precision, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.count_profiles_within_radius(lat double precision, lng double precision, radius_meters integer DEFAULT 10000) RETURNS integer
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
DECLARE
  count_result INTEGER;
BEGIN
  SELECT COUNT(*)::INTEGER INTO count_result
  FROM profiles p
  WHERE p.location IS NOT NULL
    AND ST_DWithin(
      p.location::geography,
      ST_SetSRID(ST_MakePoint(lng, lat), 4326)::geography,
      radius_meters
    )
    AND p.deleted_at IS NULL;

  RETURN COALESCE(count_result, 0);
END;
$$;


--
-- Name: FUNCTION count_profiles_within_radius(lat double precision, lng double precision, radius_meters integer); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.count_profiles_within_radius(lat double precision, lng double precision, radius_meters integer) IS 'Count profiles within a given radius (in meters) from a lat/lng point';


--
-- Name: create_announcement(text, text, text, text, text, boolean, integer, timestamp with time zone, timestamp with time zone, boolean); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.create_announcement(p_title text, p_content text, p_announcement_type text DEFAULT 'info'::text, p_display_location text DEFAULT 'banner'::text, p_target_type text DEFAULT 'all'::text, p_is_dismissible boolean DEFAULT true, p_priority integer DEFAULT 0, p_starts_at timestamp with time zone DEFAULT now(), p_ends_at timestamp with time zone DEFAULT NULL::timestamp with time zone, p_publish_immediately boolean DEFAULT false) RETURNS uuid
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
DECLARE
  v_announcement_id UUID;
BEGIN
  IF get_user_trust_level() < 4 THEN
    RAISE EXCEPTION 'Only users with trust level 4+ can create announcements';
  END IF;
  
  INSERT INTO forum_announcements (
    title, content, announcement_type, display_location,
    target_type, is_dismissible, priority,
    starts_at, ends_at, is_published, created_by
  ) VALUES (
    p_title, p_content, p_announcement_type, p_display_location,
    p_target_type, p_is_dismissible, p_priority,
    p_starts_at, p_ends_at, p_publish_immediately, auth.uid()
  )
  RETURNING id INTO v_announcement_id;
  
  RETURN v_announcement_id;
END;
$$;


--
-- Name: create_bookmark_collection(text, text, text, text, boolean); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.create_bookmark_collection(p_name text, p_description text DEFAULT NULL::text, p_color text DEFAULT '#6366f1'::text, p_icon_name text DEFAULT 'folder'::text, p_is_private boolean DEFAULT true) RETURNS uuid
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
DECLARE
  v_collection_id UUID;
  v_max_order INTEGER;
BEGIN
  -- Get max sort order
  SELECT COALESCE(MAX(sort_order), 0) + 1 INTO v_max_order
  FROM forum_bookmark_collections
  WHERE profile_id = auth.uid();
  
  INSERT INTO forum_bookmark_collections (profile_id, name, description, color, icon_name, is_private, sort_order)
  VALUES (auth.uid(), p_name, p_description, p_color, p_icon_name, p_is_private, v_max_order)
  RETURNING id INTO v_collection_id;
  
  RETURN v_collection_id;
END;
$$;


--
-- Name: create_default_address(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.create_default_address() RETURNS trigger
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO ''
    AS $$
BEGIN
  -- Insert empty address record for the new profile
  -- Using fully qualified table reference (public.address)
  -- ON CONFLICT ensures idempotency (won't fail if address already exists)
  INSERT INTO public.address (profile_id)
  VALUES (NEW.id)
  ON CONFLICT (profile_id) DO NOTHING;

  RETURN NEW;
END;
$$;


--
-- Name: FUNCTION create_default_address(); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.create_default_address() IS 'Automatically creates an empty address record when a new profile is created. Uses SECURITY DEFINER with pinned search_path for security.';


--
-- Name: create_default_bookmark_collection(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.create_default_bookmark_collection() RETURNS trigger
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
BEGIN
  INSERT INTO forum_bookmark_collections (profile_id, name, description, is_default, icon_name)
  VALUES (NEW.profile_id, 'All Bookmarks', 'Default collection for all bookmarks', TRUE, 'bookmark')
  ON CONFLICT (profile_id, name) DO NOTHING;
  RETURN NEW;
END;
$$;


--
-- Name: create_default_email_preferences(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.create_default_email_preferences() RETURNS trigger
    LANGUAGE plpgsql
    SET search_path TO ''
    AS $$
BEGIN
  INSERT INTO public.email_preferences (profile_id)
  VALUES (NEW.id)
  ON CONFLICT (profile_id) DO NOTHING;
  RETURN NEW;
END;
$$;


--
-- Name: create_forum_comment(uuid, bigint, text, bigint, jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.create_forum_comment(p_user_id uuid, p_forum_id bigint, p_content text, p_parent_id bigint DEFAULT NULL::bigint, p_rich_content jsonb DEFAULT NULL::jsonb) RETURNS jsonb
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
DECLARE
  v_comment_id BIGINT;
  v_post_author_id UUID;
  v_parent_author_id UUID;
  v_depth INTEGER;
  v_result JSONB;
BEGIN
  SELECT profile_id INTO v_post_author_id
  FROM forum
  WHERE id = p_forum_id AND forum_published = TRUE AND (is_locked IS NULL OR is_locked = FALSE);
  
  IF v_post_author_id IS NULL THEN
    RETURN jsonb_build_object('success', FALSE, 'error', 'Post not found or is locked');
  END IF;

  IF p_parent_id IS NOT NULL THEN
    SELECT COALESCE(depth, 0) + 1, user_id INTO v_depth, v_parent_author_id
    FROM comments WHERE id = p_parent_id;
    
    IF v_depth IS NULL THEN
      RETURN jsonb_build_object('success', FALSE, 'error', 'Parent comment not found');
    END IF;
    
    IF v_depth > 3 THEN
      v_depth := 3;
    END IF;
  ELSE
    v_depth := 0;
  END IF;

  INSERT INTO comments (
    forum_id, user_id, comment, parent_id, depth, rich_content, comment_created_at
  ) VALUES (
    p_forum_id, p_user_id, p_content, p_parent_id, v_depth, p_rich_content, NOW()
  ) RETURNING id INTO v_comment_id;

  UPDATE forum 
  SET forum_comments_counter = COALESCE(forum_comments_counter, 0) + 1,
      last_activity_at = NOW()
  WHERE id = p_forum_id;

  IF p_parent_id IS NOT NULL THEN
    UPDATE comments 
    SET replies_count = COALESCE(replies_count, 0) + 1
    WHERE id = p_parent_id;
  END IF;

  IF v_post_author_id != p_user_id THEN
    INSERT INTO user_notifications (
      user_id, notification_type, title, body, data, created_at
    ) VALUES (
      v_post_author_id,
      'forum_comment',
      'New comment on your post',
      (SELECT COALESCE(nickname, first_name, 'Someone') FROM profiles WHERE id = p_user_id) || ' commented on your post',
      jsonb_build_object('forumId', p_forum_id, 'commentId', v_comment_id, 'userId', p_user_id),
      NOW()
    );
  END IF;

  IF p_parent_id IS NOT NULL AND v_parent_author_id IS NOT NULL AND v_parent_author_id != p_user_id THEN
    INSERT INTO user_notifications (
      user_id, notification_type, title, body, data, created_at
    ) VALUES (
      v_parent_author_id,
      'forum_reply',
      'New reply to your comment',
      (SELECT COALESCE(nickname, first_name, 'Someone') FROM profiles WHERE id = p_user_id) || ' replied to your comment',
      jsonb_build_object('forumId', p_forum_id, 'commentId', v_comment_id, 'parentId', p_parent_id, 'userId', p_user_id),
      NOW()
    );
  END IF;

  SELECT jsonb_build_object(
    'success', TRUE,
    'comment', jsonb_build_object(
      'id', c.id,
      'content', c.comment,
      'authorId', c.user_id,
      'authorName', COALESCE(p.nickname, p.first_name, 'User'),
      'authorAvatar', p.avatar_url,
      'parentId', c.parent_id,
      'depth', c.depth,
      'createdAt', c.comment_created_at
    )
  ) INTO v_result
  FROM comments c
  JOIN profiles p ON c.user_id = p.id
  WHERE c.id = v_comment_id;

  RETURN v_result;
END;
$$;


--
-- Name: create_forum_notification(uuid, uuid, text, bigint, bigint, jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.create_forum_notification(p_recipient_id uuid, p_actor_id uuid, p_type text, p_forum_id bigint DEFAULT NULL::bigint, p_comment_id bigint DEFAULT NULL::bigint, p_data jsonb DEFAULT '{}'::jsonb) RETURNS uuid
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
DECLARE
  v_notification_id UUID;
BEGIN
  -- Don't notify yourself
  IF p_recipient_id = p_actor_id THEN
    RETURN NULL;
  END IF;
  
  INSERT INTO public.forum_notifications (
    recipient_id, actor_id, type, forum_id, comment_id, data
  ) VALUES (
    p_recipient_id, p_actor_id, p_type, p_forum_id, p_comment_id, p_data
  )
  RETURNING id INTO v_notification_id;
  
  RETURN v_notification_id;
END;
$$;


--
-- Name: create_forum_poll(bigint, text, text[], text, timestamp with time zone, boolean, boolean); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.create_forum_poll(p_forum_id bigint, p_question text, p_options text[], p_poll_type text DEFAULT 'single'::text, p_ends_at timestamp with time zone DEFAULT NULL::timestamp with time zone, p_is_anonymous boolean DEFAULT false, p_show_results_before_vote boolean DEFAULT false) RETURNS jsonb
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
DECLARE
  v_user_id UUID := auth.uid();
  v_poll_id UUID;
  v_option TEXT;
  v_sort_order INT := 0;
BEGIN
  -- Verify user owns the post
  IF NOT EXISTS (
    SELECT 1 FROM public.forum WHERE id = p_forum_id AND profile_id = v_user_id
  ) THEN
    RAISE EXCEPTION 'Not authorized to create poll for this post';
  END IF;
  
  -- Validate options (min 2)
  IF array_length(p_options, 1) < 2 THEN
    RAISE EXCEPTION 'Poll must have at least 2 options';
  END IF;
  
  -- Create poll
  INSERT INTO public.forum_polls (forum_id, question, poll_type, ends_at, is_anonymous, show_results_before_vote)
  VALUES (p_forum_id, p_question, p_poll_type, p_ends_at, p_is_anonymous, p_show_results_before_vote)
  RETURNING id INTO v_poll_id;
  
  -- Create options
  FOREACH v_option IN ARRAY p_options
  LOOP
    INSERT INTO public.forum_poll_options (poll_id, option_text, sort_order)
    VALUES (v_poll_id, v_option, v_sort_order);
    v_sort_order := v_sort_order + 1;
  END LOOP;
  
  RETURN jsonb_build_object('poll_id', v_poll_id, 'success', true);
END;
$$;


--
-- Name: create_forum_series(text, text, integer, text, text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.create_forum_series(p_title text, p_description text DEFAULT NULL::text, p_category_id integer DEFAULT NULL::integer, p_difficulty_level text DEFAULT 'beginner'::text, p_cover_image text DEFAULT NULL::text) RETURNS uuid
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
DECLARE
  v_series_id UUID;
  v_slug TEXT;
  v_base_slug TEXT;
  v_counter INTEGER := 0;
BEGIN
  -- Generate slug from title
  v_base_slug := lower(regexp_replace(p_title, '[^a-zA-Z0-9]+', '-', 'g'));
  v_base_slug := trim(both '-' from v_base_slug);
  v_slug := v_base_slug;
  
  -- Ensure unique slug
  WHILE EXISTS (SELECT 1 FROM forum_series WHERE slug = v_slug) LOOP
    v_counter := v_counter + 1;
    v_slug := v_base_slug || '-' || v_counter;
  END LOOP;
  
  INSERT INTO forum_series (
    profile_id,
    title,
    slug,
    description,
    category_id,
    difficulty_level,
    cover_image
  ) VALUES (
    auth.uid(),
    p_title,
    v_slug,
    p_description,
    p_category_id,
    p_difficulty_level,
    p_cover_image
  )
  RETURNING id INTO v_series_id;
  
  RETURN v_series_id;
END;
$$;


--
-- Name: create_listing_transactional(uuid, text, text, text, text[], double precision, double precision, text, text, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.create_listing_transactional(p_profile_id uuid, p_title text, p_description text DEFAULT NULL::text, p_post_type text DEFAULT 'food'::text, p_images text[] DEFAULT NULL::text[], p_latitude double precision DEFAULT NULL::double precision, p_longitude double precision DEFAULT NULL::double precision, p_pickup_address text DEFAULT NULL::text, p_pickup_time text DEFAULT NULL::text, p_category_id integer DEFAULT NULL::integer) RETURNS jsonb
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO ''
    AS $$
DECLARE
    v_validation JSONB;
    v_post_id INT;
    v_result JSONB;
    v_sanitized JSONB;
BEGIN
    IF p_profile_id != auth.uid() THEN
        RETURN jsonb_build_object(
            'success', false,
            'error', jsonb_build_object('code', 'AUTH_FORBIDDEN', 'message', 'You can only create listings for yourself'),
            'listing', NULL
        );
    END IF;

    v_validation := public.validate_listing(p_title, p_description, p_images, p_post_type, p_latitude, p_longitude, p_pickup_address, p_pickup_time);

    IF NOT (v_validation->>'valid')::BOOLEAN THEN
        RETURN jsonb_build_object(
            'success', false,
            'error', jsonb_build_object('code', 'VALIDATION_ERROR', 'message', 'Listing validation failed', 'details', v_validation->'errors'),
            'listing', NULL
        );
    END IF;

    v_sanitized := v_validation->'sanitized';

    INSERT INTO public.posts (profile_id, post_name, post_description, post_type, images, latitude, longitude, post_address, pickup_time, category_id, is_active, is_arranged, post_views, post_like_counter)
    VALUES (p_profile_id, v_sanitized->>'title', NULLIF(v_sanitized->>'description', ''), v_sanitized->>'postType', p_images, (v_sanitized->>'latitude')::DOUBLE PRECISION, (v_sanitized->>'longitude')::DOUBLE PRECISION, NULLIF(v_sanitized->>'pickupAddress', ''), NULLIF(v_sanitized->>'pickupTime', ''), p_category_id, true, false, 0, 0)
    RETURNING id INTO v_post_id;

    INSERT INTO public.post_activity_logs (post_id, actor_id, activity_type, metadata)
    VALUES (v_post_id, p_profile_id, 'created', jsonb_build_object('post_type', v_sanitized->>'postType', 'has_images', array_length(p_images, 1) > 0));

    SELECT jsonb_build_object('success', true, 'error', NULL, 'listing', jsonb_build_object('id', p.id, 'profileId', p.profile_id, 'postName', p.post_name, 'postDescription', p.post_description, 'postType', p.post_type, 'images', p.images, 'latitude', p.latitude, 'longitude', p.longitude, 'postAddress', p.post_address, 'pickupTime', p.pickup_time, 'categoryId', p.category_id, 'isActive', p.is_active, 'isArranged', p.is_arranged, 'postViews', p.post_views, 'postLikeCounter', p.post_like_counter, 'createdAt', p.created_at))
    INTO v_result FROM public.posts p WHERE p.id = v_post_id;

    RETURN v_result;
END;
$$;


--
-- Name: create_mfa_challenge(uuid, text, inet, text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.create_mfa_challenge(p_profile_id uuid, p_method text, p_ip_address inet DEFAULT NULL::inet, p_user_agent text DEFAULT NULL::text) RETURNS jsonb
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO ''
    AS $$
DECLARE
  v_code TEXT;
  v_code_hash TEXT;
  v_challenge_id UUID;
  v_rate_limit JSONB;
BEGIN
  v_rate_limit := check_mfa_rate_limit(
    p_profile_id,
    COALESCE(p_ip_address, '0.0.0.0'::INET),
    'mfa_attempts',
    5,
    INTERVAL '15 minutes'
  );

  IF NOT (v_rate_limit->>'allowed')::BOOLEAN THEN
    RETURN jsonb_build_object(
      'success', FALSE,
      'error', 'rate_limit_exceeded',
      'locked_until', v_rate_limit->>'locked_until'
    );
  END IF;

  UPDATE mfa_verification_attempts
  SET is_expired = TRUE
  WHERE profile_id = p_profile_id
    AND is_verified = FALSE
    AND is_expired = FALSE;

  v_code := generate_mfa_code();
  v_code_hash := hash_mfa_code(v_code);

  INSERT INTO mfa_verification_attempts (
    profile_id, verification_method, code_hash, ip_address, user_agent
  ) VALUES (
    p_profile_id, p_method, v_code_hash, p_ip_address, p_user_agent
  )
  RETURNING id INTO v_challenge_id;

  RETURN jsonb_build_object(
    'success', TRUE,
    'challenge_id', v_challenge_id,
    'code', v_code,
    'expires_at', NOW() + INTERVAL '5 minutes',
    'method', p_method
  );
END;
$$;


--
-- Name: create_profile_stats(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.create_profile_stats() RETURNS trigger
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
BEGIN
    INSERT INTO public.profile_stats (profile_id)
    VALUES (NEW.id)
    ON CONFLICT (profile_id) DO NOTHING;
    RETURN NEW;
END;
$$;


--
-- Name: FUNCTION create_profile_stats(); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.create_profile_stats() IS 'Automatically creates profile_stats entry when a new profile is created';


--
-- Name: create_profile_stats_on_profile_insert(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.create_profile_stats_on_profile_insert() RETURNS trigger
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
BEGIN
  INSERT INTO public.profile_stats (profile_id)
  VALUES (NEW.id)
  ON CONFLICT (profile_id) DO NOTHING;
  RETURN NEW;
END;
$$;


--
-- Name: create_recurring_post(text, text, text, time without time zone, integer, integer, text, integer, date); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.create_recurring_post(p_title_template text, p_description_template text, p_recurrence_type text, p_recurrence_time time without time zone, p_category_id integer DEFAULT NULL::integer, p_recurrence_day integer DEFAULT NULL::integer, p_timezone text DEFAULT 'UTC'::text, p_max_occurrences integer DEFAULT NULL::integer, p_end_date date DEFAULT NULL::date) RETURNS uuid
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
DECLARE
  v_recurring_id UUID;
  v_next_scheduled TIMESTAMPTZ;
BEGIN
  -- Calculate next scheduled time based on recurrence settings
  v_next_scheduled := calculate_next_occurrence(
    p_recurrence_type, 
    p_recurrence_day, 
    p_recurrence_time, 
    p_timezone
  );
  
  INSERT INTO forum_recurring_posts (
    profile_id, title_template, description_template, category_id,
    recurrence_type, recurrence_day, recurrence_time, timezone,
    max_occurrences, end_date, next_scheduled_at
  ) VALUES (
    auth.uid(), p_title_template, p_description_template, p_category_id,
    p_recurrence_type, p_recurrence_day, p_recurrence_time, p_timezone,
    p_max_occurrences, p_end_date, v_next_scheduled
  )
  RETURNING id INTO v_recurring_id;
  
  RETURN v_recurring_id;
END;
$$;


--
-- Name: create_user_notification(uuid, uuid, text, text, text, integer, uuid, integer, jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.create_user_notification(p_recipient_id uuid, p_actor_id uuid, p_type text, p_title text, p_body text DEFAULT NULL::text, p_post_id integer DEFAULT NULL::integer, p_room_id uuid DEFAULT NULL::uuid, p_review_id integer DEFAULT NULL::integer, p_data jsonb DEFAULT '{}'::jsonb) RETURNS uuid
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO ''
    AS $$
DECLARE
  v_notification_id uuid;
BEGIN
  -- Don't notify yourself
  IF p_recipient_id = p_actor_id THEN
    RETURN NULL;
  END IF;

  INSERT INTO user_notifications (
    recipient_id,
    actor_id,
    type,
    title,
    body,
    post_id,
    room_id,
    review_id,
    data
  ) VALUES (
    p_recipient_id,
    p_actor_id,
    p_type,
    p_title,
    p_body,
    p_post_id,
    p_room_id,
    p_review_id,
    p_data
  )
  RETURNING id INTO v_notification_id;

  RETURN v_notification_id;
END;
$$;


--
-- Name: deactivate_expired_posts(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.deactivate_expired_posts(p_days_old integer DEFAULT 30) RETURNS jsonb
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
DECLARE v_count INT;
BEGIN WITH deactivated AS (UPDATE posts SET is_active = false WHERE is_active = true AND is_arranged = false AND created_at < NOW() - (p_days_old || ' days')::INTERVAL RETURNING id) SELECT COUNT(*) INTO v_count FROM deactivated; RETURN jsonb_build_object('success', true, 'deactivated_count', v_count);
EXCEPTION WHEN OTHERS THEN RETURN jsonb_build_object('success', false, 'error', jsonb_build_object('code', 'SERVER_ERROR', 'message', SQLERRM));
END;
$$;


--
-- Name: deactivate_post(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.deactivate_post(p_post_id integer) RETURNS jsonb
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO ''
    AS $$
DECLARE
    v_post RECORD;
    v_caller_id UUID;
BEGIN
    v_caller_id := auth.uid();
    SELECT * INTO v_post FROM public.posts WHERE id = p_post_id;

    IF v_post IS NULL THEN
        RETURN jsonb_build_object('success', false, 'error', jsonb_build_object('code', 'RESOURCE_NOT_FOUND', 'message', 'Post not found'));
    END IF;

    IF v_caller_id != v_post.profile_id AND v_caller_id != v_post.post_arranged_to THEN
        RETURN jsonb_build_object('success', false, 'error', jsonb_build_object('code', 'AUTH_FORBIDDEN', 'message', 'Only the owner or arranged user can deactivate'));
    END IF;

    UPDATE public.posts SET is_active = false, updated_at = now() WHERE id = p_post_id;

    INSERT INTO public.post_activity_logs (post_id, actor_id, activity_type, metadata)
    VALUES (p_post_id, v_caller_id, 'deactivated', jsonb_build_object('deactivated_by', v_caller_id, 'was_arranged', v_post.is_arranged, 'deactivated_at', now()));

    RETURN jsonb_build_object('success', true, 'error', NULL, 'postId', p_post_id);
END;
$$;


--
-- Name: decrement_forum_likes(bigint); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.decrement_forum_likes(forum_id bigint) RETURNS void
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
BEGIN
  UPDATE forum
  SET forum_likes_counter = GREATEST(COALESCE(forum_likes_counter, 0) - 1, 0)
  WHERE id = forum_id;
END;
$$;


--
-- Name: decrypt_pii(text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.decrypt_pii(encrypted_data text) RETURNS text
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO ''
    AS $$
BEGIN
  RETURN pgp_sym_decrypt(decode(encrypted_data, 'base64'), current_setting('app.encryption_key', TRUE));
EXCEPTION WHEN OTHERS THEN RETURN '[DECRYPTION_ERROR]';
END;
$$;


--
-- Name: deep_merge_jsonb(jsonb, jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.deep_merge_jsonb(base_obj jsonb, merge_obj jsonb) RETURNS jsonb
    LANGUAGE sql IMMUTABLE
    AS $$
  SELECT
    CASE
      WHEN jsonb_typeof(base_obj) = 'object' AND jsonb_typeof(merge_obj) = 'object' THEN
        (SELECT jsonb_object_agg(
          COALESCE(bo.key, mo.key),
          CASE
            WHEN bo.value IS NULL THEN mo.value
            WHEN mo.value IS NULL THEN bo.value
            WHEN jsonb_typeof(bo.value) = 'object' AND jsonb_typeof(mo.value) = 'object'
              THEN deep_merge_jsonb(bo.value, mo.value)
            ELSE mo.value
          END
        )
        FROM jsonb_each(base_obj) bo
        FULL OUTER JOIN jsonb_each(merge_obj) mo ON bo.key = mo.key)
      ELSE merge_obj
    END
$$;


--
-- Name: delete_notification(uuid, uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.delete_notification(p_user_id uuid, p_notification_id uuid) RETURNS jsonb
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
DECLARE
  v_affected integer;
BEGIN
  DELETE FROM user_notifications
  WHERE id = p_notification_id
    AND recipient_id = p_user_id;

  GET DIAGNOSTICS v_affected = ROW_COUNT;

  IF v_affected = 0 THEN
    RETURN jsonb_build_object('success', false, 'error', 'NOT_FOUND');
  END IF;

  RETURN jsonb_build_object(
    'success', true,
    'deletedId', p_notification_id
  );
END;
$$;


--
-- Name: detect_forum_spam_patterns(text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.detect_forum_spam_patterns(p_content text) RETURNS TABLE(is_spam boolean, spam_score numeric, reasons text[])
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
DECLARE
  v_score DECIMAL := 0;
  v_reasons TEXT[] := '{}';
  v_url_count INTEGER;
  v_caps_ratio DECIMAL;
BEGIN
  -- Check for excessive URLs
  v_url_count := (LENGTH(p_content) - LENGTH(REPLACE(REPLACE(p_content, 'http://', ''), 'https://', ''))) / 7;
  IF v_url_count > 3 THEN
    v_score := v_score + 0.3;
    v_reasons := array_append(v_reasons, 'excessive_urls');
  END IF;
  
  -- Check for excessive caps
  IF LENGTH(p_content) > 10 THEN
    v_caps_ratio := LENGTH(REGEXP_REPLACE(p_content, '[^A-Z]', '', 'g'))::DECIMAL / LENGTH(p_content);
    IF v_caps_ratio > 0.5 THEN
      v_score := v_score + 0.2;
      v_reasons := array_append(v_reasons, 'excessive_caps');
    END IF;
  END IF;
  
  -- Check for repeated characters
  IF p_content ~ '(.)\1{5,}' THEN
    v_score := v_score + 0.2;
    v_reasons := array_append(v_reasons, 'repeated_characters');
  END IF;
  
  -- Check for very short content with links
  IF LENGTH(p_content) < 10 AND v_url_count > 0 THEN
    v_score := v_score + 0.3;
    v_reasons := array_append(v_reasons, 'short_with_link');
  END IF;
  
  RETURN QUERY SELECT 
    v_score >= 0.5,
    v_score,
    v_reasons;
END;
$$;


--
-- Name: dismiss_announcement(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.dismiss_announcement(p_announcement_id uuid) RETURNS boolean
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM forum_announcements 
    WHERE id = p_announcement_id AND is_dismissible = true
  ) THEN
    RETURN false;
  END IF;
  
  INSERT INTO forum_announcement_dismissals (announcement_id, profile_id)
  VALUES (p_announcement_id, auth.uid())
  ON CONFLICT (announcement_id, profile_id) DO NOTHING;
  
  UPDATE forum_announcements
  SET dismissals_count = dismissals_count + 1
  WHERE id = p_announcement_id;
  
  RETURN true;
END;
$$;


--
-- Name: email_template_version_trigger(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.email_template_version_trigger() RETURNS trigger
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
BEGIN
  IF OLD.html_content IS DISTINCT FROM NEW.html_content
     OR OLD.subject IS DISTINCT FROM NEW.subject
     OR OLD.text_content IS DISTINCT FROM NEW.text_content
     OR OLD.variables IS DISTINCT FROM NEW.variables THEN

    INSERT INTO email_template_versions (
      template_id, version, subject, html_content, text_content, variables, changed_by, change_reason
    ) VALUES (
      OLD.id, OLD.version, OLD.subject, OLD.html_content, OLD.text_content, OLD.variables, NEW.updated_by,
      COALESCE(current_setting('app.change_reason', true), 'Content update')
    );
    NEW.version = OLD.version + 1;
  END IF;
  RETURN NEW;
END;
$$;


--
-- Name: encrypt_pii(text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.encrypt_pii(data text) RETURNS text
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO ''
    AS $$
BEGIN
  RETURN encode(pgp_sym_encrypt(data, current_setting('app.encryption_key', TRUE)), 'base64');
END;
$$;


--
-- Name: enforce_max_drafts(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.enforce_max_drafts() RETURNS trigger
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
DECLARE
  v_draft_count INT;
BEGIN
  SELECT COUNT(*) INTO v_draft_count
  FROM public.forum_drafts
  WHERE profile_id = NEW.profile_id;
  
  IF v_draft_count >= 10 THEN
    RAISE EXCEPTION 'Maximum 10 drafts allowed. Please delete some drafts first.';
  END IF;
  
  RETURN NEW;
END;
$$;


--
-- Name: enroll_user_in_automation(uuid, uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.enroll_user_in_automation(p_flow_id uuid, p_profile_id uuid) RETURNS uuid
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
DECLARE
  v_enrollment_id uuid;
  v_flow record;
  v_first_step jsonb;
  v_delay_minutes integer;
BEGIN
  -- Get flow details
  SELECT * INTO v_flow FROM public.email_automation_flows WHERE id = p_flow_id AND status = 'active';
  
  IF v_flow IS NULL THEN
    RAISE EXCEPTION 'Automation flow not found or not active';
  END IF;
  
  -- Check if user is already enrolled
  IF EXISTS (
    SELECT 1 FROM public.automation_enrollments 
    WHERE flow_id = p_flow_id AND profile_id = p_profile_id AND status = 'active'
  ) THEN
    RETURN NULL; -- Already enrolled
  END IF;
  
  -- Create enrollment
  INSERT INTO public.automation_enrollments (flow_id, profile_id, status, current_step)
  VALUES (p_flow_id, p_profile_id, 'active', 0)
  RETURNING id INTO v_enrollment_id;
  
  -- Update flow stats
  UPDATE public.email_automation_flows 
  SET total_enrolled = total_enrolled + 1, updated_at = now()
  WHERE id = p_flow_id;
  
  -- Schedule first step if exists
  IF jsonb_array_length(v_flow.steps) > 0 THEN
    v_first_step := v_flow.steps->0;
    v_delay_minutes := COALESCE((v_first_step->>'delay_minutes')::integer, 0);
    
    INSERT INTO public.email_automation_queue (
      enrollment_id, flow_id, profile_id, step_index, 
      scheduled_for, email_data
    ) VALUES (
      v_enrollment_id, p_flow_id, p_profile_id, 0,
      now() + (v_delay_minutes || ' minutes')::interval,
      v_first_step
    );
  END IF;
  
  RETURN v_enrollment_id;
END;
$$;


--
-- Name: ensure_forum_user_stats(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.ensure_forum_user_stats(p_profile_id uuid) RETURNS void
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
BEGIN
  INSERT INTO public.forum_user_stats (profile_id)
  VALUES (p_profile_id)
  ON CONFLICT (profile_id) DO NOTHING;
END;
$$;


--
-- Name: execute_readonly_query(text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.execute_readonly_query(query_text text) RETURNS jsonb
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO ''
    SET statement_timeout TO '10s'
    AS $_$
DECLARE
  result JSONB;
  clean_query TEXT;
BEGIN
  clean_query := TRIM(query_text);
  
  IF NOT (clean_query ~* '^\s*(SELECT|WITH)\s') THEN
    RAISE EXCEPTION 'Only SELECT queries are allowed';
  END IF;
  
  IF clean_query ~* '\b(DROP|DELETE|TRUNCATE|INSERT|UPDATE|ALTER|CREATE|GRANT|REVOKE|EXEC|EXECUTE)\b' THEN
    RAISE EXCEPTION 'Query contains forbidden operations';
  END IF;
  
  IF clean_query ~ ';.*\S' THEN
    RAISE EXCEPTION 'Multiple statements not allowed';
  END IF;
  
  EXECUTE 'SELECT COALESCE(jsonb_agg(row_to_json(t)), ''[]''::jsonb) FROM (' || 
          regexp_replace(clean_query, ';\s*$', '') || 
          ') t'
  INTO result;
  
  RETURN result;
END;
$_$;


--
-- Name: FUNCTION execute_readonly_query(query_text text); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.execute_readonly_query(query_text text) IS 'Executes read-only SQL queries for AI deep analysis. Only SELECT statements allowed.';


--
-- Name: extract_coordinates(extensions.geography); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.extract_coordinates(geog extensions.geography) RETURNS TABLE(latitude numeric, longitude numeric)
    LANGUAGE plpgsql STABLE
    SET search_path TO ''
    AS $$
BEGIN
  RETURN QUERY
  SELECT 
    ST_Y(geog::geometry) as latitude,
    ST_X(geog::geometry) as longitude;
END;
$$;


--
-- Name: extract_mentions(text, uuid, bigint, bigint); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.extract_mentions(p_text text, p_mentioner_id uuid, p_forum_id bigint DEFAULT NULL::bigint, p_comment_id bigint DEFAULT NULL::bigint) RETURNS SETOF uuid
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
DECLARE
  v_username TEXT;
  v_profile_id UUID;
  v_mentioned_ids UUID[] := '{}';
BEGIN
  -- Extract @username patterns (alphanumeric and underscores)
  FOR v_username IN
    SELECT DISTINCT (regexp_matches(p_text, '@([a-zA-Z0-9_]+)', 'g'))[1]
  LOOP
    -- Look up profile by username
    SELECT id INTO v_profile_id
    FROM public.profiles
    WHERE LOWER(username) = LOWER(v_username)
      AND id != p_mentioner_id; -- Don't mention yourself
    
    IF v_profile_id IS NOT NULL AND NOT (v_profile_id = ANY(v_mentioned_ids)) THEN
      v_mentioned_ids := array_append(v_mentioned_ids, v_profile_id);
      
      -- Insert the mention
      INSERT INTO public.forum_mentions (
        mentioned_profile_id,
        mentioner_profile_id,
        forum_id,
        comment_id
      ) VALUES (
        v_profile_id,
        p_mentioner_id,
        p_forum_id,
        p_comment_id
      )
      ON CONFLICT DO NOTHING;
      
      RETURN NEXT v_profile_id;
    END IF;
  END LOOP;
  
  RETURN;
END;
$$;


--
-- Name: feature_forum_post(bigint, integer, text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.feature_forum_post(p_forum_id bigint, p_duration_hours integer DEFAULT 24, p_reason text DEFAULT NULL::text) RETURNS boolean
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
DECLARE
  v_is_moderator BOOLEAN;
BEGIN
  -- Check if user is a moderator
  SELECT EXISTS (
    SELECT 1 FROM user_roles ur
    JOIN roles r ON ur.role_id = r.id
    WHERE ur.profile_id = auth.uid()
    AND r.name IN ('admin', 'super_admin', 'moderator')
  ) INTO v_is_moderator;
  
  IF NOT v_is_moderator THEN
    RAISE EXCEPTION 'Only moderators can feature posts';
  END IF;
  
  UPDATE forum
  SET 
    is_featured = true,
    featured_at = now(),
    featured_until = now() + (p_duration_hours || ' hours')::INTERVAL,
    featured_by = auth.uid()
  WHERE id = p_forum_id;
  
  -- Log the action
  PERFORM log_moderator_action(
    'post_pin', -- Using pin as feature equivalent
    'post',
    p_forum_id::TEXT,
    NULL,
    p_reason,
    jsonb_build_object('duration_hours', p_duration_hours)
  );
  
  RETURN true;
END;
$$;


--
-- Name: filter_blocked_content(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.filter_blocked_content(p_profile_id uuid) RETURNS boolean
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
BEGIN
  -- If not authenticated, show all content
  IF auth.uid() IS NULL THEN
    RETURN TRUE;
  END IF;
  
  -- Check if there's any block relationship
  RETURN NOT EXISTS (
    SELECT 1 FROM forum_user_blocks
    WHERE (blocker_id = auth.uid() AND blocked_id = p_profile_id)
       OR (blocker_id = p_profile_id AND blocked_id = auth.uid())
  );
END;
$$;


--
-- Name: find_nearby_posts_geography(extensions.geography, numeric, text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.find_nearby_posts_geography(user_location extensions.geography, radius_km numeric DEFAULT 5, p_post_type text DEFAULT NULL::text) RETURNS TABLE(id bigint, post_name text, post_description text, post_type text, post_address text, post_stripped_address text, location extensions.geography, images text[], distance_km numeric)
    LANGUAGE plpgsql STABLE SECURITY DEFINER
    SET search_path TO 'public', 'extensions'
    AS $$
BEGIN
  RETURN QUERY
  SELECT 
    p.id,
    p.post_name,
    p.post_description,
    p.post_type,
    p.post_address,
    p.post_stripped_address,
    p.location,
    p.images,
    ROUND((ST_Distance(p.location, user_location) / 1000)::numeric, 2) as distance_km
  FROM posts p
  WHERE 
    p.is_active = true
    AND (p_post_type IS NULL OR p.post_type = p_post_type)
    AND ST_DWithin(p.location, user_location, radius_km * 1000)
  ORDER BY ST_Distance(p.location, user_location);
END;
$$;


--
-- Name: forum_check_rate_limit(text, boolean); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.forum_check_rate_limit(p_action_type text, p_consume boolean DEFAULT true) RETURNS TABLE(allowed boolean, remaining integer, reset_at timestamp with time zone, retry_after_seconds integer)
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
DECLARE
  v_config RECORD;
  v_user_trust_level INTEGER;
  v_multiplier DECIMAL;
  v_effective_max INTEGER;
  v_current_count INTEGER;
  v_window_start TIMESTAMP WITH TIME ZONE;
  v_window_end TIMESTAMP WITH TIME ZONE;
  v_remaining INTEGER;
  v_allowed BOOLEAN;
BEGIN
  -- Get rate limit config
  SELECT * INTO v_config
  FROM forum_rate_limit_config
  WHERE action_type = p_action_type AND is_active = TRUE;
  
  IF NOT FOUND THEN
    RETURN QUERY SELECT TRUE, 999999, NULL::TIMESTAMP WITH TIME ZONE, 0;
    RETURN;
  END IF;
  
  -- Get user's trust level
  SELECT COALESCE(trust_level, 0) INTO v_user_trust_level
  FROM forum_user_stats
  WHERE profile_id = auth.uid();
  
  v_user_trust_level := COALESCE(v_user_trust_level, 0);
  
  -- Calculate effective max based on trust level
  v_multiplier := COALESCE(
    (v_config.trust_level_multipliers->>v_user_trust_level::TEXT)::DECIMAL,
    1
  );
  v_effective_max := CEIL(v_config.max_actions * v_multiplier)::INTEGER;
  
  -- Calculate window boundaries
  v_window_start := date_trunc('second', now()) - (v_config.window_seconds || ' seconds')::INTERVAL;
  v_window_end := now() + (v_config.window_seconds || ' seconds')::INTERVAL;
  
  -- Get current action count in window
  SELECT COALESCE(SUM(action_count), 0)::INTEGER INTO v_current_count
  FROM forum_rate_limits
  WHERE profile_id = auth.uid()
    AND action_type = p_action_type
    AND created_at > v_window_start;
  
  -- Check if allowed
  v_allowed := v_current_count < v_effective_max;
  v_remaining := GREATEST(v_effective_max - v_current_count - (CASE WHEN p_consume AND v_allowed THEN 1 ELSE 0 END), 0);
  
  -- Record action if consuming and allowed
  IF p_consume AND v_allowed THEN
    INSERT INTO forum_rate_limits (profile_id, action_type, action_count, window_start, window_end)
    VALUES (auth.uid(), p_action_type, 1, now(), v_window_end)
    ON CONFLICT (profile_id, action_type, window_start) 
    DO UPDATE SET 
      action_count = forum_rate_limits.action_count + 1,
      updated_at = now();
  END IF;
  
  RETURN QUERY SELECT 
    v_allowed,
    v_remaining,
    v_window_end,
    CASE WHEN NOT v_allowed 
      THEN GREATEST(
        EXTRACT(EPOCH FROM (v_window_end - now()))::INTEGER + v_config.cooldown_seconds,
        v_config.cooldown_seconds
      )
      ELSE 0 
    END;
END;
$$;


--
-- Name: FUNCTION forum_check_rate_limit(p_action_type text, p_consume boolean); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.forum_check_rate_limit(p_action_type text, p_consume boolean) IS 'Check if an action is allowed and optionally consume a rate limit token';


--
-- Name: generate_backup_codes(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.generate_backup_codes(count integer DEFAULT 10) RETURNS text[]
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO ''
    AS $$
DECLARE
  codes TEXT[] := ARRAY[]::TEXT[];
  i INTEGER;
BEGIN
  FOR i IN 1..count LOOP
    codes := array_append(codes, encode(gen_random_bytes(6), 'base64')::TEXT);
  END LOOP;
  RETURN codes;
END;
$$;


--
-- Name: generate_forum_slug(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.generate_forum_slug() RETURNS trigger
    LANGUAGE plpgsql
    SET search_path TO 'public'
    AS $_$
DECLARE
  base_slug TEXT;
  final_slug TEXT;
BEGIN
  -- Skip if slug is already provided (client-side generation)
  IF NEW.slug IS NOT NULL AND NEW.slug != '' THEN
    RETURN NEW;
  END IF;
  
  -- Generate base slug from title only if not provided
  IF NEW.forum_post_name IS NOT NULL THEN
    base_slug := lower(regexp_replace(NEW.forum_post_name, '[^a-zA-Z0-9]+', '-', 'g'));
    base_slug := regexp_replace(base_slug, '^-|-$', '', 'g');
    base_slug := left(base_slug, 80);
    
    -- Add timestamp to ensure uniqueness without loop
    final_slug := base_slug || '-' || extract(epoch from now())::bigint;
    NEW.slug := final_slug;
  END IF;
  
  RETURN NEW;
END;
$_$;


--
-- Name: FUNCTION generate_forum_slug(); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.generate_forum_slug() IS 'Optimized: skips generation when slug provided by client';


--
-- Name: generate_mfa_code(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.generate_mfa_code() RETURNS text
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO ''
    AS $$
BEGIN
  RETURN LPAD(FLOOR(RANDOM() * 1000000)::TEXT, 6, '0');
END;
$$;


--
-- Name: generate_translation_etag(character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.generate_translation_etag(p_locale character varying) RETURNS character varying
    LANGUAGE plpgsql
    SET search_path TO ''
    AS $$
DECLARE
  v_etag VARCHAR(64);
BEGIN
  SELECT encode(sha256(
    (locale || version || updated_at::text)::bytea
  ), 'hex')
  INTO v_etag
  FROM translations
  WHERE locale = p_locale;
  
  RETURN COALESCE(v_etag, 'default');
END;
$$;


--
-- Name: geocode_address(text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.geocode_address(address text) RETURNS TABLE(latitude numeric, longitude numeric)
    LANGUAGE plpgsql STABLE
    SET search_path TO 'public'
    AS $$
BEGIN
  -- Placeholder for geocoding logic
  -- In production, this would call an external geocoding service
  RETURN QUERY SELECT NULL::numeric, NULL::numeric;
END;
$$;


--
-- Name: geocode_and_update_location(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.geocode_and_update_location() RETURNS trigger
    LANGUAGE plpgsql
    SET search_path TO ''
    AS $$
DECLARE
  osm_result json;
  _lat double precision;
  _lon double precision;
  nominatim_url text;
  curl_command text;
BEGIN
  -- Construct the Nominatim API URL 
  nominatim_url := 'https://nominatim.openstreetmap.org/search?q=' 
                   || replace(NEW.post_address, ' ', '+') 
                   || '&format=json';

  -- Construct the curl command
  curl_command := 'curl -s "' || nominatim_url || '"'; 

  -- Execute the curl command 
  osm_result := plsh_run_command(curl_command)::json;

  -- Enhanced Debugging:
  RAISE NOTICE 'Curl output: %', osm_result;  
  RAISE NOTICE 'JSON type: %', json_typeof(osm_result);
  RAISE NOTICE 'Array length: %', json_array_length(osm_result);

  -- Check for results 
  IF json_array_length(osm_result) > 0 THEN
    -- Try alternative extraction method
    _lat := osm_result->0->>'lat'; 
    _lon := osm_result->0->>'lon'; 

    RAISE NOTICE 'Latitude: %, Longitude: %', _lat, _lon;
    RAISE NOTICE 'Latitude type: %, Longitude type: %', pg_typeof(_lat), pg_typeof(_lon);

    NEW.latitude := _lat;
    NEW.longitude := _lon;
    NEW := update_location();
  ELSE
    RAISE NOTICE 'Geocoding failed for address: %', NEW.post_address;
  END IF;

  RETURN NEW;
END;
$$;


--
-- Name: geocode_and_update_location(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.geocode_and_update_location(post_id integer) RETURNS void
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO ''
    AS $$
DECLARE
  post_address text;
  lat numeric;
  lng numeric;
BEGIN
  SELECT p.post_address INTO post_address
  FROM public.posts p
  WHERE p.id = post_id;
  
  IF post_address IS NOT NULL THEN
    SELECT latitude, longitude INTO lat, lng
    FROM public.geocode_address(post_address);
    
    IF lat IS NOT NULL AND lng IS NOT NULL THEN
      UPDATE public.posts
      SET latitude = lat,
          longitude = lng,
          location = ST_SetSRID(ST_MakePoint(lng, lat), 4326)
      WHERE id = post_id;
    END IF;
  END IF;
END;
$$;


--
-- Name: get_active_announcements(integer, text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_active_announcements(p_category_id integer DEFAULT NULL::integer, p_location text DEFAULT NULL::text) RETURNS TABLE(id uuid, title text, content text, rich_content jsonb, announcement_type text, icon_name text, background_color text, text_color text, display_location text, is_dismissible boolean, is_pinned boolean, priority integer, cta_text text, cta_url text, cta_style text, starts_at timestamp with time zone, ends_at timestamp with time zone)
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
DECLARE
  v_user_id UUID := auth.uid();
  v_user_trust_level INTEGER;
BEGIN
  v_user_trust_level := get_user_trust_level(v_user_id);
  
  RETURN QUERY
  SELECT 
    a.id,
    a.title,
    a.content,
    a.rich_content,
    a.announcement_type,
    a.icon_name,
    a.background_color,
    a.text_color,
    a.display_location,
    a.is_dismissible,
    a.is_pinned,
    a.priority,
    a.cta_text,
    a.cta_url,
    a.cta_style,
    a.starts_at,
    a.ends_at
  FROM forum_announcements a
  WHERE a.is_active = true
    AND a.is_published = true
    AND a.starts_at <= now()
    AND (a.ends_at IS NULL OR a.ends_at > now())
    AND NOT EXISTS (
      SELECT 1 FROM forum_announcement_dismissals d
      WHERE d.announcement_id = a.id AND d.profile_id = v_user_id
    )
    AND (p_location IS NULL OR a.display_location = p_location)
    AND (
      a.target_type = 'all'
      OR (a.target_type = 'category' AND a.target_category_id = p_category_id)
      OR (a.target_type = 'trust_level' AND v_user_trust_level = ANY(a.target_trust_levels))
    )
  ORDER BY a.is_pinned DESC, a.priority DESC, a.starts_at DESC;
END;
$$;


--
-- Name: get_admin_users(text, text, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_admin_users(p_search_query text DEFAULT NULL::text, p_role_filter text DEFAULT NULL::text, p_limit integer DEFAULT 20, p_offset integer DEFAULT 0) RETURNS TABLE(id uuid, nickname text, email text, avatar_url text, is_verified boolean, is_active boolean, created_time timestamp with time zone, last_seen_at timestamp with time zone, user_roles jsonb)
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public', 'pg_temp'
    AS $$
BEGIN
  RETURN QUERY
  SELECT 
    p.id,
    p.nickname,
    p.email,
    p.avatar_url,
    p.is_verified,
    p.is_active,
    p.created_time,
    p.last_seen_at,
    COALESCE(
      (
        SELECT jsonb_agg(
          jsonb_build_object(
            'role_id', ur.role_id,
            'role', jsonb_build_object(
              'id', r.id,
              'name', r.name
            )
          )
        )
        FROM user_roles ur
        JOIN roles r ON r.id = ur.role_id
        WHERE ur.profile_id = p.id
      ),
      '[]'::jsonb
    ) AS user_roles
  FROM profiles p
  WHERE 
    -- Search filter
    (p_search_query IS NULL OR p_search_query = '' OR 
     p.nickname ILIKE '%' || p_search_query || '%' OR 
     p.email ILIKE '%' || p_search_query || '%')
    -- Role filter
    AND (p_role_filter IS NULL OR p_role_filter = '' OR EXISTS (
      SELECT 1 
      FROM user_roles ur 
      JOIN roles r ON r.id = ur.role_id 
      WHERE ur.profile_id = p.id AND r.name = p_role_filter
    ))
  ORDER BY p.created_time DESC
  LIMIT p_limit
  OFFSET p_offset;
END;
$$;


--
-- Name: get_airtable_api_token(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_airtable_api_token() RETURNS text
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
BEGIN
  RETURN vault.read_secret('AIRTABLE_API_TOKEN');
END;
$$;


--
-- Name: get_airtable_key(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_airtable_key() RETURNS text
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
BEGIN
  RETURN vault.read_secret('AIRTABLE_API_KEY');
END;
$$;


--
-- Name: get_all_provider_health(date); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_all_provider_health(p_date date DEFAULT CURRENT_DATE) RETURNS TABLE(provider text, health_score integer, emails_sent integer, avg_latency_ms numeric, success_rate numeric, circuit_state text, is_available boolean, consecutive_failures integer)
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO ''
    AS $$
BEGIN
  RETURN QUERY
  WITH quota AS (
    SELECT 
      q.provider,
      COALESCE(q.emails_sent, 0) as emails_sent
    FROM public.email_provider_quota q
    WHERE q.date = p_date
  ),
  health AS (
    SELECT 
      h.provider,
      h.health_score,
      h.average_latency_ms,
      CASE 
        WHEN h.total_requests > 0 
        THEN (h.successful_requests::numeric / h.total_requests)
        ELSE 1.0
      END as success_rate,
      COALESCE(h.consecutive_failures, 0) as consecutive_failures
    FROM public.email_provider_health_metrics h
  ),
  circuit AS (
    SELECT 
      c.provider,
      c.state as circuit_state
    FROM public.email_circuit_breaker_state c
  )
  SELECT 
    p.provider::text,
    COALESCE(h.health_score, 100)::integer,
    COALESCE(q.emails_sent, 0)::integer,
    COALESCE(h.average_latency_ms, 500)::numeric,
    COALESCE(h.success_rate, 1.0)::numeric,
    COALESCE(c.circuit_state, 'closed')::text,
    (COALESCE(c.circuit_state, 'closed') != 'open' 
     AND COALESCE(h.health_score, 100) >= 20)::boolean as is_available,
    COALESCE(h.consecutive_failures, 0)::integer
  FROM (
    SELECT unnest(ARRAY['resend', 'brevo', 'aws_ses']) as provider
  ) p
  LEFT JOIN quota q ON q.provider = p.provider
  LEFT JOIN health h ON h.provider = p.provider
  LEFT JOIN circuit c ON c.provider = p.provider;
END;
$$;


--
-- Name: get_app_config(text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_app_config(p_platform text DEFAULT 'ios'::text) RETURNS jsonb
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public', 'pg_temp'
    AS $$
DECLARE
  config jsonb := '{}'::jsonb;
  row_data RECORD;
BEGIN
  FOR row_data IN
    SELECT DISTINCT ON (key) key, value, category
    FROM public.app_config
    WHERE platform = p_platform OR platform = 'all'
    ORDER BY key, (platform = p_platform) DESC
  LOOP
    IF NOT config ? row_data.category THEN
      config := config || jsonb_build_object(row_data.category, '{}'::jsonb);
    END IF;
    config := jsonb_set(
      config,
      ARRAY[row_data.category, row_data.key],
      row_data.value
    );
  END LOOP;
  RETURN config;
END;
$$;


--
-- Name: get_app_settings(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_app_settings() RETURNS jsonb
    LANGUAGE plpgsql STABLE SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
BEGIN
  RETURN jsonb_build_object(
    'success', true,
    'app', jsonb_build_object(
      'name', 'FoodShare',
      'version', '1.0.0',
      'minSupportedVersion', '0.9.0'
    ),
    'features', jsonb_build_object(
      'pushNotifications', true,
      'emailNotifications', true,
      'locationServices', true,
      'messaging', true,
      'ratings', true,
      'challenges', true
    ),
    'defaults', jsonb_build_object(
      'searchRadiusKm', 10,
      'maxSearchRadiusKm', 50,
      'maxImagesPerListing', 5,
      'maxDescriptionLength', 2000,
      'listingExpiryDays', 7
    ),
    'support', jsonb_build_object(
      'email', 'support@foodshare.app',
      'helpUrl', 'https://help.foodshare.app',
      'termsUrl', 'https://foodshare.app/terms',
      'privacyUrl', 'https://foodshare.app/privacy'
    ),
    'legal', jsonb_build_object(
      'termsVersion', '2024-01-01',
      'privacyVersion', '2024-01-01'
    ),
    'meta', jsonb_build_object(
      'timestamp', NOW(),
      'cacheTTL', 3600
    )
  );
END;
$$;


--
-- Name: FUNCTION get_app_settings(); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.get_app_settings() IS 'Returns app-wide configuration for clients';


--
-- Name: get_audit_stats(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_audit_stats(hours integer DEFAULT 24) RETURNS jsonb
    LANGUAGE sql STABLE SECURITY DEFINER
    AS $$
  SELECT jsonb_build_object(
    'total_events', COUNT(*),
    'by_severity', jsonb_object_agg(
      severity,
      severity_count
    ),
    'by_event_type', (
      SELECT jsonb_object_agg(event_type, event_count)
      FROM (
        SELECT event_type, COUNT(*) as event_count
        FROM email_audit_log
        WHERE created_at > NOW() - (hours || ' hours')::INTERVAL
        GROUP BY event_type
        ORDER BY event_count DESC
        LIMIT 10
      ) top_events
    ),
    'critical_count', (
      SELECT COUNT(*)
      FROM email_audit_log
      WHERE severity = 'critical'
      AND created_at > NOW() - (hours || ' hours')::INTERVAL
    )
  )
  FROM (
    SELECT severity, COUNT(*) as severity_count
    FROM email_audit_log
    WHERE created_at > NOW() - (hours || ' hours')::INTERVAL
    GROUP BY severity
  ) severity_stats;
$$;


--
-- Name: FUNCTION get_audit_stats(hours integer); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.get_audit_stats(hours integer) IS 'Get aggregated audit statistics for the last N hours';


--
-- Name: get_author_dashboard(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_author_dashboard(p_days integer DEFAULT 30) RETURNS TABLE(total_views bigint, total_likes bigint, total_comments bigint, total_followers integer, views_trend numeric, likes_trend numeric, top_posts jsonb, daily_stats jsonb, audience_growth jsonb)
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
DECLARE
  v_current_views BIGINT;
  v_previous_views BIGINT;
  v_current_likes BIGINT;
  v_previous_likes BIGINT;
BEGIN
  -- Get current period stats
  SELECT 
    COALESCE(SUM(views_count), 0),
    COALESCE(SUM(likes_count), 0)
  INTO v_current_views, v_current_likes
  FROM forum_post_analytics pa
  JOIN forum f ON f.id = pa.forum_id
  WHERE f.profile_id = auth.uid()
    AND pa.date >= CURRENT_DATE - p_days;
  
  -- Get previous period stats for comparison
  SELECT 
    COALESCE(SUM(views_count), 0),
    COALESCE(SUM(likes_count), 0)
  INTO v_previous_views, v_previous_likes
  FROM forum_post_analytics pa
  JOIN forum f ON f.id = pa.forum_id
  WHERE f.profile_id = auth.uid()
    AND pa.date >= CURRENT_DATE - (p_days * 2)
    AND pa.date < CURRENT_DATE - p_days;
  
  RETURN QUERY
  SELECT 
    v_current_views,
    v_current_likes,
    (SELECT COALESCE(SUM(pa.comments_count), 0)::BIGINT
     FROM forum_post_analytics pa
     JOIN forum f ON f.id = pa.forum_id
     WHERE f.profile_id = auth.uid()
       AND pa.date >= CURRENT_DATE - p_days),
    (SELECT COALESCE(followers_count, 0)
     FROM forum_user_stats
     WHERE profile_id = auth.uid()),
    CASE WHEN v_previous_views > 0 
      THEN ((v_current_views - v_previous_views)::DECIMAL / v_previous_views * 100)
      ELSE 0 
    END,
    CASE WHEN v_previous_likes > 0 
      THEN ((v_current_likes - v_previous_likes)::DECIMAL / v_previous_likes * 100)
      ELSE 0 
    END,
    (SELECT jsonb_agg(post_data)
     FROM (
       SELECT jsonb_build_object(
         'id', f.id,
         'title', f.forum_post_name,
         'views', COALESCE(SUM(pa.views_count), 0),
         'likes', f.forum_likes_counter,
         'comments', f.forum_comments_counter
       ) AS post_data
       FROM forum f
       LEFT JOIN forum_post_analytics pa ON pa.forum_id = f.id AND pa.date >= CURRENT_DATE - p_days
       WHERE f.profile_id = auth.uid()
       GROUP BY f.id, f.forum_post_name, f.forum_likes_counter, f.forum_comments_counter
       ORDER BY COALESCE(SUM(pa.views_count), 0) DESC
       LIMIT 5
     ) top),
    (SELECT jsonb_agg(daily_data ORDER BY date)
     FROM (
       SELECT jsonb_build_object(
         'date', pa.date,
         'views', SUM(pa.views_count),
         'likes', SUM(pa.likes_count),
         'comments', SUM(pa.comments_count)
       ) AS daily_data,
       pa.date
       FROM forum_post_analytics pa
       JOIN forum f ON f.id = pa.forum_id
       WHERE f.profile_id = auth.uid()
         AND pa.date >= CURRENT_DATE - p_days
       GROUP BY pa.date
     ) daily),
    (SELECT jsonb_agg(growth_data ORDER BY date)
     FROM (
       SELECT jsonb_build_object(
         'date', aa.date,
         'gained', aa.total_followers_gained,
         'lost', aa.total_followers_lost,
         'net', aa.total_followers_gained - aa.total_followers_lost
       ) AS growth_data,
       aa.date
       FROM forum_author_analytics aa
       WHERE aa.profile_id = auth.uid()
         AND aa.date >= CURRENT_DATE - p_days
     ) growth);
END;
$$;


--
-- Name: FUNCTION get_author_dashboard(p_days integer); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.get_author_dashboard(p_days integer) IS 'Get comprehensive author analytics dashboard data';


--
-- Name: get_badge_collection(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_badge_collection(p_profile_id uuid) RETURNS jsonb
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
DECLARE
  v_all_badges jsonb;
  v_earned_badges jsonb;
BEGIN
  -- Fetch all active badges
  SELECT COALESCE(jsonb_agg(
    jsonb_build_object(
      'id', fb.id,
      'name', fb.name,
      'slug', fb.slug,
      'description', fb.description,
      'icon_name', fb.icon_name,
      'color', fb.color,
      'badge_type', fb.badge_type,
      'criteria', fb.criteria,
      'points', fb.points,
      'is_active', fb.is_active,
      'created_at', fb.created_at
    ) ORDER BY fb.badge_type, fb.points DESC
  ), '[]'::jsonb)
  INTO v_all_badges
  FROM forum_badges fb
  WHERE fb.is_active = true;
  
  -- Fetch user's earned badges with badge details
  SELECT COALESCE(jsonb_agg(
    jsonb_build_object(
      'user_badge', jsonb_build_object(
        'id', fub.id,
        'profile_id', fub.profile_id,
        'badge_id', fub.badge_id,
        'awarded_at', fub.awarded_at,
        'awarded_by', fub.awarded_by,
        'is_featured', COALESCE(fub.is_featured, false)
      ),
      'badge', jsonb_build_object(
        'id', fb.id,
        'name', fb.name,
        'slug', fb.slug,
        'description', fb.description,
        'icon_name', fb.icon_name,
        'color', fb.color,
        'badge_type', fb.badge_type,
        'criteria', fb.criteria,
        'points', fb.points,
        'is_active', fb.is_active,
        'created_at', fb.created_at
      )
    ) ORDER BY fub.awarded_at DESC
  ), '[]'::jsonb)
  INTO v_earned_badges
  FROM forum_user_badges fub
  JOIN forum_badges fb ON fb.id = fub.badge_id
  WHERE fub.profile_id = p_profile_id;
  
  RETURN jsonb_build_object(
    'all_badges', v_all_badges,
    'earned_badges', v_earned_badges
  );
END;
$$;


--
-- Name: FUNCTION get_badge_collection(p_profile_id uuid); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.get_badge_collection(p_profile_id uuid) IS 'Returns all badges and user earned badges in a single call. Replaces 2 separate queries.';


--
-- Name: get_batch_engagement_status(integer[]); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_batch_engagement_status(p_post_ids integer[]) RETURNS json
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
DECLARE
    v_user_id UUID;
    v_result JSON;
BEGIN
    v_user_id := auth.uid();

    IF array_length(p_post_ids, 1) IS NULL OR array_length(p_post_ids, 1) = 0 THEN
        RETURN json_build_object(
            'success', false,
            'error', json_build_object('code', 'INVALID_INPUT', 'message', 'Post IDs required')
        );
    END IF;

    IF array_length(p_post_ids, 1) > 100 THEN
        RETURN json_build_object(
            'success', false,
            'error', json_build_object('code', 'TOO_MANY_POSTS', 'message', 'Maximum 100 posts allowed')
        );
    END IF;

    -- Use unified likes and bookmarks tables
    SELECT json_build_object(
        'success', true,
        'statuses', COALESCE(json_agg(
            json_build_object(
                'post_id', p.id,
                'is_liked', COALESCE(ul.is_liked, false),
                'is_bookmarked', COALESCE(ub.is_bookmarked, false),
                'like_count', COALESCE(lc.like_count, 0)
            )
        ), '[]'::json)
    ) INTO v_result
    FROM unnest(p_post_ids) AS p(id)
    LEFT JOIN (
        SELECT post_id, true as is_liked
        FROM likes
        WHERE profile_id = v_user_id
          AND post_id = ANY(p_post_ids)
          AND forum_id = 0 AND challenge_id = 0 AND comment_id = 0
    ) ul ON ul.post_id = p.id
    LEFT JOIN (
        SELECT post_id, true as is_bookmarked
        FROM bookmarks
        WHERE profile_id = v_user_id
          AND post_id = ANY(p_post_ids)
          AND forum_id = 0
    ) ub ON ub.post_id = p.id
    LEFT JOIN (
        SELECT post_id, COUNT(*) as like_count
        FROM likes
        WHERE post_id = ANY(p_post_ids)
          AND forum_id = 0 AND challenge_id = 0 AND comment_id = 0
        GROUP BY post_id
    ) lc ON lc.post_id = p.id;

    RETURN v_result;
END;
$$;


--
-- Name: FUNCTION get_batch_engagement_status(p_post_ids integer[]); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.get_batch_engagement_status(p_post_ids integer[]) IS 'Get engagement status for multiple posts. Uses unified likes/bookmarks tables.';


--
-- Name: get_bff_feed_data(uuid, double precision, double precision, double precision, integer, timestamp with time zone, text, bigint); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_bff_feed_data(p_user_id uuid, p_lat double precision, p_lng double precision, p_radius_km double precision DEFAULT 10, p_limit integer DEFAULT 20, p_cursor timestamp with time zone DEFAULT NULL::timestamp with time zone, p_post_type text DEFAULT NULL::text, p_category_id bigint DEFAULT NULL::bigint) RETURNS jsonb
    LANGUAGE plpgsql STABLE SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
DECLARE
  v_search_radius_m DOUBLE PRECISION;
  v_unread_notifications INTEGER;
  v_unread_messages INTEGER;
  v_total_count INTEGER;
  v_listings JSONB;
BEGIN
  v_search_radius_m := p_radius_km * 1000;

  -- Get unread counts in parallel-friendly CTEs
  SELECT COUNT(*)::INTEGER INTO v_unread_notifications
  FROM user_notifications
  WHERE recipient_id = p_user_id AND is_read = FALSE;

  SELECT COUNT(*)::INTEGER INTO v_unread_messages
  FROM rooms r
  WHERE (r.sharer = p_user_id OR r.requester = p_user_id)
    AND r.last_message_sent_by IS NOT NULL
    AND r.last_message_sent_by != p_user_id
    AND (r.last_message_seen_by IS NULL OR r.last_message_seen_by != p_user_id);

  -- Get total count for pagination
  SELECT COUNT(*)::INTEGER INTO v_total_count
  FROM posts p
  WHERE extensions.ST_DWithin(
      p.location,
      extensions.ST_SetSRID(extensions.ST_MakePoint(p_lng, p_lat), 4326)::extensions.geography,
      v_search_radius_m
    )
    AND p.is_arranged = FALSE
    AND p.is_active = TRUE
    AND p.location IS NOT NULL
    AND (p_post_type IS NULL OR p.post_type = p_post_type)
    AND (p_category_id IS NULL OR p.category_id = p_category_id);

  -- Get listings with owner profiles and categories
  SELECT COALESCE(jsonb_agg(listing_data ORDER BY listing_data->>'created_at' DESC), '[]'::jsonb)
  INTO v_listings
  FROM (
    SELECT jsonb_build_object(
      'id', p.id::TEXT,
      'post_name', p.post_name,
      'post_description', p.post_description,
      'images', COALESCE(p.images, ARRAY[]::TEXT[]),
      'post_type', p.post_type,
      'latitude', extensions.ST_Y(p.location::extensions.geometry),
      'longitude', extensions.ST_X(p.location::extensions.geometry),
      'distance_km', ROUND((extensions.ST_Distance(
        p.location,
        extensions.ST_SetSRID(extensions.ST_MakePoint(p_lng, p_lat), 4326)::extensions.geography
      ) / 1000)::NUMERIC, 2),
      'pickup_address', p.post_address,
      'pickup_time', p.pickup_time,
      'category_id', p.category_id,
      'category_name', c.name,
      'category_icon', c.icon_url,
      'profile_id', p.profile_id,
      'owner_name', pr.nickname,
      'owner_avatar', pr.avatar_url,
      'owner_rating', ps.rating_average,
      'created_at', p.created_at,
      'expires_at', NULL::TIMESTAMPTZ,
      'view_count', COALESCE(p.post_views, 0)
    ) AS listing_data
    FROM posts p
    LEFT JOIN categories c ON c.id = p.category_id
    LEFT JOIN profiles pr ON pr.id = p.profile_id
    LEFT JOIN profile_stats ps ON ps.profile_id = p.profile_id
    WHERE extensions.ST_DWithin(
        p.location,
        extensions.ST_SetSRID(extensions.ST_MakePoint(p_lng, p_lat), 4326)::extensions.geography,
        v_search_radius_m
      )
      AND p.is_arranged = FALSE
      AND p.is_active = TRUE
      AND p.location IS NOT NULL
      AND (p_post_type IS NULL OR p.post_type = p_post_type)
      AND (p_category_id IS NULL OR p.category_id = p_category_id)
      AND (p_cursor IS NULL OR p.created_at < p_cursor)
    ORDER BY p.created_at DESC
    LIMIT p_limit
  ) sub;

  RETURN jsonb_build_object(
    'listings', v_listings,
    'unread_notifications', v_unread_notifications,
    'unread_messages', v_unread_messages,
    'total_count', v_total_count
  );
END;
$$;


--
-- Name: FUNCTION get_bff_feed_data(p_user_id uuid, p_lat double precision, p_lng double precision, p_radius_km double precision, p_limit integer, p_cursor timestamp with time zone, p_post_type text, p_category_id bigint); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.get_bff_feed_data(p_user_id uuid, p_lat double precision, p_lng double precision, p_radius_km double precision, p_limit integer, p_cursor timestamp with time zone, p_post_type text, p_category_id bigint) IS 'BFF aggregated feed data for cross-platform clients. Returns listings with owner profiles, categories, and unread counts in a single call.';


--
-- Name: get_bff_messages_data(uuid, integer, timestamp with time zone, boolean); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_bff_messages_data(p_user_id uuid, p_limit integer DEFAULT 20, p_cursor timestamp with time zone DEFAULT NULL::timestamp with time zone, p_include_archived boolean DEFAULT false) RETURNS jsonb
    LANGUAGE plpgsql STABLE SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
DECLARE
  v_total_unread INTEGER;
  v_rooms JSONB;
BEGIN
  -- Get total unread count
  SELECT COUNT(*)::INTEGER INTO v_total_unread
  FROM rooms r
  WHERE (r.sharer = p_user_id OR r.requester = p_user_id)
    AND r.last_message_sent_by IS NOT NULL
    AND r.last_message_sent_by != p_user_id
    AND (r.last_message_seen_by IS NULL OR r.last_message_seen_by != p_user_id);

  -- Get rooms with participants and last message
  SELECT COALESCE(jsonb_agg(room_data ORDER BY room_data->>'updated_at' DESC NULLS LAST), '[]'::jsonb)
  INTO v_rooms
  FROM (
    SELECT jsonb_build_object(
      'room_id', r.id,
      'room_name', COALESCE(
        (SELECT p.post_name FROM posts p WHERE p.id = r.post_id),
        'Direct Message'
      ),
      'room_type', CASE 
        WHEN r.post_id IS NOT NULL THEN 'listing'
        ELSE 'direct'
      END,
      'post_id', r.post_id,
      'participants', (
        SELECT jsonb_agg(jsonb_build_object(
          'id', pr.id,
          'display_name', pr.nickname,
          'avatar_url', pr.avatar_url,
          'is_online', COALESCE(pr.last_seen_at > NOW() - INTERVAL '5 minutes', FALSE)
        ))
        FROM profiles pr
        WHERE pr.id IN (r.sharer, r.requester)
          AND pr.id != p_user_id
      ),
      'last_message_id', NULL::UUID,
      'last_message_content', r.last_message,
      'last_message_sender_id', r.last_message_sent_by,
      'last_message_sender_name', (
        SELECT pr.nickname FROM profiles pr WHERE pr.id = r.last_message_sent_by
      ),
      'last_message_at', r.last_message_time,
      'last_message_read', CASE 
        WHEN r.last_message_sent_by = p_user_id THEN TRUE
        WHEN r.last_message_seen_by = p_user_id THEN TRUE
        ELSE FALSE
      END,
      'unread_count', CASE 
        WHEN r.last_message_sent_by IS NOT NULL 
          AND r.last_message_sent_by != p_user_id 
          AND (r.last_message_seen_by IS NULL OR r.last_message_seen_by != p_user_id)
        THEN 1
        ELSE 0
      END,
      'is_muted', FALSE,
      'is_pinned', FALSE,
      'updated_at', COALESCE(r.last_message_time, NOW())
    ) AS room_data
    FROM rooms r
    WHERE (r.sharer = p_user_id OR r.requester = p_user_id)
      AND (p_cursor IS NULL OR COALESCE(r.last_message_time, NOW()) < p_cursor)
    ORDER BY r.last_message_time DESC NULLS LAST
    LIMIT p_limit
  ) sub;

  RETURN jsonb_build_object(
    'rooms', v_rooms,
    'total_unread', v_total_unread
  );
END;
$$;


--
-- Name: FUNCTION get_bff_messages_data(p_user_id uuid, p_limit integer, p_cursor timestamp with time zone, p_include_archived boolean); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.get_bff_messages_data(p_user_id uuid, p_limit integer, p_cursor timestamp with time zone, p_include_archived boolean) IS 'BFF aggregated messages data for cross-platform clients. Returns chat rooms with participants, last messages, and unread counts.';


--
-- Name: get_bff_notifications_data(uuid, text, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_bff_notifications_data(p_user_id uuid, p_filter text DEFAULT 'all'::text, p_page_limit integer DEFAULT 50, p_page_offset integer DEFAULT 0) RETURNS jsonb
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
DECLARE
  v_result JSONB;
  v_notifications JSONB;
  v_counts JSONB;
BEGIN
  -- Get notifications with filtering
  WITH notification_data AS (
    SELECT 
      n.id,
      n.notification_type,
      n.title,
      n.body,
      n.data,
      n.is_read,
      n.created_at,
      -- Group by type for filtering
      CASE 
        WHEN n.notification_type LIKE 'message%' OR n.notification_type LIKE 'chat%' THEN 'messages'
        WHEN n.notification_type LIKE 'forum%' THEN 'forum'
        WHEN n.notification_type LIKE 'challenge%' THEN 'challenges'
        WHEN n.notification_type IN ('arrangement_request', 'arrangement_accepted', 'arrangement_completed', 'transaction_completed') THEN 'transactions'
        ELSE 'other'
      END AS category
    FROM user_notifications n
    WHERE n.user_id = p_user_id
      AND (p_filter = 'all' OR 
           (p_filter = 'unread' AND n.is_read = FALSE) OR
           (p_filter = 'messages' AND n.notification_type LIKE ANY(ARRAY['message%', 'chat%'])) OR
           (p_filter = 'forum' AND n.notification_type LIKE 'forum%') OR
           (p_filter = 'challenges' AND n.notification_type LIKE 'challenge%') OR
           (p_filter = 'transactions' AND n.notification_type IN ('arrangement_request', 'arrangement_accepted', 'arrangement_completed', 'transaction_completed'))
      )
    ORDER BY n.created_at DESC
    LIMIT p_page_limit
    OFFSET p_page_offset
  )
  SELECT COALESCE(jsonb_agg(
    jsonb_build_object(
      'id', id,
      'type', notification_type,
      'category', category,
      'title', title,
      'body', body,
      'data', COALESCE(data, '{}'::jsonb),
      'isRead', is_read,
      'createdAt', created_at,
      'timeAgo', CASE 
        WHEN created_at > NOW() - INTERVAL '1 minute' THEN 'just now'
        WHEN created_at > NOW() - INTERVAL '1 hour' THEN EXTRACT(MINUTE FROM NOW() - created_at)::text || 'm ago'
        WHEN created_at > NOW() - INTERVAL '1 day' THEN EXTRACT(HOUR FROM NOW() - created_at)::text || 'h ago'
        WHEN created_at > NOW() - INTERVAL '7 days' THEN EXTRACT(DAY FROM NOW() - created_at)::text || 'd ago'
        ELSE TO_CHAR(created_at, 'Mon DD')
      END
    )
  ), '[]'::jsonb) INTO v_notifications FROM notification_data;

  -- Get counts by category
  SELECT jsonb_build_object(
    'total', (SELECT COUNT(*) FROM user_notifications WHERE user_id = p_user_id),
    'unread', (SELECT COUNT(*) FROM user_notifications WHERE user_id = p_user_id AND is_read = FALSE),
    'messages', (SELECT COUNT(*) FROM user_notifications WHERE user_id = p_user_id AND is_read = FALSE AND notification_type LIKE ANY(ARRAY['message%', 'chat%'])),
    'forum', (SELECT COUNT(*) FROM user_notifications WHERE user_id = p_user_id AND is_read = FALSE AND notification_type LIKE 'forum%'),
    'challenges', (SELECT COUNT(*) FROM user_notifications WHERE user_id = p_user_id AND is_read = FALSE AND notification_type LIKE 'challenge%'),
    'transactions', (SELECT COUNT(*) FROM user_notifications WHERE user_id = p_user_id AND is_read = FALSE AND notification_type IN ('arrangement_request', 'arrangement_accepted', 'arrangement_completed', 'transaction_completed'))
  ) INTO v_counts;

  -- Build final response
  v_result := jsonb_build_object(
    'success', TRUE,
    'notifications', v_notifications,
    'counts', v_counts,
    'pagination', jsonb_build_object(
      'limit', p_page_limit,
      'offset', p_page_offset,
      'hasMore', jsonb_array_length(v_notifications) = p_page_limit
    )
  );

  RETURN v_result;
END;
$$;


--
-- Name: get_bff_profile_data(uuid, uuid, boolean, boolean, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_bff_profile_data(p_profile_id uuid, p_viewer_id uuid, p_include_listings boolean DEFAULT true, p_include_reviews boolean DEFAULT true, p_listings_limit integer DEFAULT 6, p_reviews_limit integer DEFAULT 5) RETURNS jsonb
    LANGUAGE plpgsql STABLE SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
DECLARE
  v_profile JSONB;
  v_stats JSONB;
  v_impact JSONB;
  v_badges JSONB;
  v_listings JSONB;
  v_reviews JSONB;
BEGIN
  -- Get profile
  SELECT jsonb_build_object(
    'id', p.id,
    'display_name', p.nickname,
    'avatar_url', p.avatar_url,
    'bio', p.about_me,
    'city', NULL::TEXT, -- Could extract from location if needed
    'is_verified', COALESCE(p.is_verified, FALSE),
    'created_at', p.created_time
  ) INTO v_profile
  FROM profiles p
  WHERE p.id = p_profile_id AND p.is_active = TRUE;

  IF v_profile IS NULL THEN
    RETURN NULL;
  END IF;

  -- Get stats
  SELECT jsonb_build_object(
    'items_shared', COALESCE(ps.items_shared, 0),
    'items_received', COALESCE(ps.items_received, 0),
    'active_listings', (
      SELECT COUNT(*)::INTEGER 
      FROM posts 
      WHERE profile_id = p_profile_id AND is_active = TRUE AND is_arranged = FALSE
    ),
    'rating_average', ps.rating_average,
    'rating_count', COALESCE(ps.rating_count, 0),
    'completed_transactions', COALESCE(ps.items_shared, 0) + COALESCE(ps.items_received, 0),
    'response_rate', NULL::NUMERIC,
    'response_time_minutes', NULL::INTEGER
  ) INTO v_stats
  FROM profile_stats ps
  WHERE ps.profile_id = p_profile_id;

  IF v_stats IS NULL THEN
    v_stats := jsonb_build_object(
      'items_shared', 0,
      'items_received', 0,
      'active_listings', 0,
      'rating_average', NULL,
      'rating_count', 0,
      'completed_transactions', 0,
      'response_rate', NULL,
      'response_time_minutes', NULL
    );
  END IF;

  -- Calculate impact metrics (estimated)
  v_impact := jsonb_build_object(
    'food_saved_kg', COALESCE((v_stats->>'items_shared')::INTEGER * 2, 0), -- ~2kg per item estimate
    'co2_saved_kg', COALESCE((v_stats->>'items_shared')::INTEGER * 4, 0), -- ~4kg CO2 per item estimate
    'meals_provided', COALESCE((v_stats->>'items_shared')::INTEGER * 3, 0), -- ~3 meals per item estimate
    'monthly_rank', NULL::INTEGER
  );

  -- Get badges (simplified - could be expanded)
  v_badges := '[]'::JSONB;
  IF (v_stats->>'items_shared')::INTEGER >= 10 THEN
    v_badges := v_badges || '"food_hero"'::JSONB;
  END IF;
  IF (v_stats->>'rating_count')::INTEGER >= 5 AND (v_stats->>'rating_average')::NUMERIC >= 4.5 THEN
    v_badges := v_badges || '"top_rated"'::JSONB;
  END IF;

  -- Get listings if requested
  IF p_include_listings THEN
    SELECT COALESCE(jsonb_agg(jsonb_build_object(
      'id', p.id::TEXT,
      'post_name', p.post_name,
      'images', COALESCE(p.images, ARRAY[]::TEXT[]),
      'is_active', p.is_active,
      'is_arranged', p.is_arranged,
      'view_count', COALESCE(p.post_views, 0),
      'created_at', p.created_at,
      'expires_at', NULL::TIMESTAMPTZ
    ) ORDER BY p.created_at DESC), '[]'::JSONB)
    INTO v_listings
    FROM posts p
    WHERE p.profile_id = p_profile_id
    LIMIT p_listings_limit;
  ELSE
    v_listings := '[]'::JSONB;
  END IF;

  -- Get reviews if requested
  IF p_include_reviews THEN
    SELECT COALESCE(jsonb_agg(jsonb_build_object(
      'id', r.id,
      'rating', r.reviewed_rating,
      'comment', r.feedback,
      'reviewer_id', r.profile_id,
      'reviewer_name', pr.nickname,
      'reviewer_avatar', pr.avatar_url,
      'transaction_type', 'shared',
      'created_at', r.created_at
    ) ORDER BY r.created_at DESC), '[]'::JSONB)
    INTO v_reviews
    FROM reviews r
    LEFT JOIN profiles pr ON pr.id = r.profile_id
    WHERE r.post_id IN (SELECT id FROM posts WHERE profile_id = p_profile_id)
    LIMIT p_reviews_limit;
  ELSE
    v_reviews := '[]'::JSONB;
  END IF;

  RETURN jsonb_build_object(
    'profile', v_profile,
    'stats', v_stats,
    'impact', v_impact,
    'badges', v_badges,
    'listings', v_listings,
    'reviews', v_reviews
  );
END;
$$;


--
-- Name: FUNCTION get_bff_profile_data(p_profile_id uuid, p_viewer_id uuid, p_include_listings boolean, p_include_reviews boolean, p_listings_limit integer, p_reviews_limit integer); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.get_bff_profile_data(p_profile_id uuid, p_viewer_id uuid, p_include_listings boolean, p_include_reviews boolean, p_listings_limit integer, p_reviews_limit integer) IS 'BFF aggregated profile data for cross-platform clients. Returns profile, stats, impact metrics, badges, listings, and reviews.';


--
-- Name: get_bff_unread_counts(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_bff_unread_counts(p_user_id uuid) RETURNS jsonb
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
BEGIN
  RETURN jsonb_build_object(
    'success', TRUE,
    'total', (SELECT COUNT(*) FROM user_notifications WHERE user_id = p_user_id AND is_read = FALSE),
    'messages', (SELECT COUNT(*) FROM user_notifications WHERE user_id = p_user_id AND is_read = FALSE AND notification_type LIKE ANY(ARRAY['message%', 'chat%'])),
    'forum', (SELECT COUNT(*) FROM user_notifications WHERE user_id = p_user_id AND is_read = FALSE AND notification_type LIKE 'forum%'),
    'challenges', (SELECT COUNT(*) FROM user_notifications WHERE user_id = p_user_id AND is_read = FALSE AND notification_type LIKE 'challenge%'),
    'transactions', (SELECT COUNT(*) FROM user_notifications WHERE user_id = p_user_id AND is_read = FALSE AND notification_type IN ('arrangement_request', 'arrangement_accepted', 'arrangement_completed', 'transaction_completed')),
    'unreadMessages', (SELECT COUNT(*) FROM chat_rooms cr WHERE cr.participant_ids @> ARRAY[p_user_id] AND EXISTS(
      SELECT 1 FROM messages m WHERE m.room_id = cr.id AND m.sender_id != p_user_id AND m.is_read = FALSE
    ))
  );
END;
$$;


--
-- Name: get_blocked_users(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_blocked_users() RETURNS TABLE(blocked_id uuid, blocked_first_name text, blocked_avatar_url text, reason text, blocked_at timestamp with time zone)
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
BEGIN
  RETURN QUERY
  SELECT 
    b.blocked_id,
    p.first_name,
    p.avatar_url,
    b.reason,
    b.created_at
  FROM forum_user_blocks b
  JOIN profiles p ON p.id = b.blocked_id
  WHERE b.blocker_id = auth.uid()
  ORDER BY b.created_at DESC;
END;
$$;


--
-- Name: get_bookmark_reminders(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_bookmark_reminders() RETURNS TABLE(bookmark_id integer, forum_id integer, forum_title text, notes text, reminder_at timestamp with time zone, collection_name text)
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
BEGIN
  RETURN QUERY
  SELECT 
    b.id,
    b.forum_id,
    f.forum_post_name,
    b.notes,
    b.reminder_at,
    bc.name
  FROM forum_bookmarks b
  JOIN forum f ON f.id = b.forum_id
  LEFT JOIN forum_bookmark_collections bc ON bc.id = b.collection_id
  WHERE b.profile_id = auth.uid()
    AND b.reminder_at IS NOT NULL
    AND b.reminder_at <= now() + INTERVAL '24 hours'
  ORDER BY b.reminder_at ASC;
END;
$$;


--
-- Name: get_campaign_fairness_metrics(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_campaign_fairness_metrics(p_campaign_id uuid) RETURNS jsonb
    LANGUAGE sql STABLE SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
  WITH stats AS (
    SELECT
      COUNT(DISTINCT user_id) AS total_users,
      COUNT(*) FILTER (WHERE status = 'queued') AS pending,
      COUNT(*) FILTER (WHERE status = 'sent') AS sent,
      COUNT(*) FILTER (WHERE status IN ('delivered', 'opened', 'clicked')) AS delivered,
      COUNT(*) FILTER (WHERE status IN ('opened', 'clicked')) AS opened,
      COUNT(*) FILTER (WHERE status = 'clicked') AS clicked,
      COUNT(*) FILTER (WHERE status = 'bounced') AS bounced,
      COUNT(*) FILTER (WHERE status = 'failed') AS failed,
      MIN(sent_at) AS first_sent,
      MAX(sent_at) AS last_sent,
      AVG(EXTRACT(EPOCH FROM (sent_at - queued_at))) AS avg_queue_time_sec
    FROM email_delivery_log
    WHERE campaign_id = p_campaign_id
  ),
  campaign_info AS (
    SELECT
      id,
      name,
      subject,
      status AS campaign_status,
      created_at,
      sent_at AS campaign_sent_at
    FROM newsletter_campaigns
    WHERE id = p_campaign_id
  )
  SELECT jsonb_build_object(
    'campaignId', p_campaign_id,
    'campaignName', ci.name,
    'campaignSubject', ci.subject,
    'campaignStatus', ci.campaign_status,
    'totalUsers', s.total_users,
    'pending', s.pending,
    'sent', s.sent,
    'delivered', s.delivered,
    'opened', s.opened,
    'clicked', s.clicked,
    'bounced', s.bounced,
    'failed', s.failed,
    'deliveryRate', ROUND(s.delivered::numeric / NULLIF(s.total_users, 0) * 100, 2),
    'openRate', ROUND(s.opened::numeric / NULLIF(s.delivered, 0) * 100, 2),
    'clickRate', ROUND(s.clicked::numeric / NULLIF(s.opened, 0) * 100, 2),
    'bounceRate', ROUND(s.bounced::numeric / NULLIF(s.total_users, 0) * 100, 2),
    'firstSent', s.first_sent,
    'lastSent', s.last_sent,
    'avgQueueTimeSec', ROUND(s.avg_queue_time_sec::numeric, 2),
    'isComplete', s.pending = 0
  )
  FROM stats s
  CROSS JOIN campaign_info ci;
$$;


--
-- Name: FUNCTION get_campaign_fairness_metrics(p_campaign_id uuid); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.get_campaign_fairness_metrics(p_campaign_id uuid) IS 'Gets delivery fairness metrics for a campaign';


--
-- Name: get_challenge_detail(bigint, uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_challenge_detail(p_challenge_id bigint, p_user_id uuid DEFAULT NULL::uuid) RETURNS jsonb
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
DECLARE
  v_result JSONB;
  v_challenge JSONB;
  v_participants JSONB;
  v_related JSONB;
BEGIN
  -- Increment view count
  UPDATE challenges SET challenge_views = challenge_views + 1 WHERE id = p_challenge_id;

  -- Get challenge with full details
  SELECT jsonb_build_object(
    'id', c.id,
    'title', c.challenge_title,
    'description', c.challenge_description,
    'image', c.challenge_image,
    'difficulty', c.challenge_difficulty,
    'score', c.challenge_score,
    'action', c.challenge_action,
    'participantsCount', c.challenged_people,
    'viewsCount', c.challenge_views,
    'likesCount', c.challenge_likes_counter,
    'createdAt', c.challenge_created_at,
    'updatedAt', c.challenge_updated_at,
    'creator', jsonb_build_object(
      'id', p.id,
      'name', COALESCE(p.nickname, p.first_name, 'User'),
      'avatar', p.avatar_url,
      'isVerified', COALESCE(p.is_verified, FALSE)
    ),
    'userParticipation', CASE WHEN p_user_id IS NOT NULL THEN (
      SELECT jsonb_build_object(
        'hasJoined', TRUE,
        'isCompleted', cp.is_completed,
        'joinedAt', cp.accepted_at,
        'completedAt', cp.completed_at
      )
      FROM challenge_participants cp
      WHERE cp.challenge_id = c.id AND cp.profile_id = p_user_id
    ) ELSE jsonb_build_object('hasJoined', FALSE) END,
    'completionRate', CASE WHEN c.challenged_people > 0 THEN
      ROUND((SELECT COUNT(*)::numeric FROM challenge_participants cp WHERE cp.challenge_id = c.id AND cp.is_completed = TRUE) / c.challenged_people * 100, 1)
    ELSE 0 END
  ) INTO v_challenge
  FROM challenges c
  JOIN profiles p ON c.profile_id = p.id
  WHERE c.id = p_challenge_id AND c.challenge_published = TRUE;

  IF v_challenge IS NULL THEN
    RETURN jsonb_build_object('success', FALSE, 'error', 'Challenge not found');
  END IF;

  -- Get recent participants
  SELECT COALESCE(jsonb_agg(
    jsonb_build_object(
      'userId', p.id,
      'name', COALESCE(p.nickname, p.first_name, 'User'),
      'avatar', p.avatar_url,
      'isCompleted', cp.is_completed,
      'joinedAt', cp.accepted_at,
      'completedAt', cp.completed_at
    ) ORDER BY cp.accepted_at DESC
  ), '[]'::jsonb) INTO v_participants
  FROM challenge_participants cp
  JOIN profiles p ON cp.profile_id = p.id
  WHERE cp.challenge_id = p_challenge_id
  LIMIT 20;

  -- Get related challenges (same difficulty)
  SELECT COALESCE(jsonb_agg(
    jsonb_build_object(
      'id', c.id,
      'title', c.challenge_title,
      'image', c.challenge_image,
      'difficulty', c.challenge_difficulty,
      'score', c.challenge_score,
      'participantsCount', c.challenged_people
    )
  ), '[]'::jsonb) INTO v_related
  FROM challenges c
  WHERE c.id != p_challenge_id
    AND c.challenge_published = TRUE
    AND c.challenge_difficulty = (SELECT challenge_difficulty FROM challenges WHERE id = p_challenge_id)
  ORDER BY c.challenged_people DESC
  LIMIT 5;

  -- Build final response
  v_result := jsonb_build_object(
    'success', TRUE,
    'challenge', v_challenge,
    'participants', v_participants,
    'relatedChallenges', v_related
  );

  RETURN v_result;
END;
$$;


--
-- Name: get_challenge_leaderboard(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_challenge_leaderboard(limit_count integer DEFAULT 10) RETURNS TABLE(profile_id uuid, nickname text, first_name text, avatar_url text, completed_count bigint, active_count bigint, total_xp numeric, last_completed timestamp with time zone)
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
BEGIN
  RETURN QUERY
  SELECT 
    cp.profile_id,
    p.nickname,
    p.first_name,
    p.avatar_url,
    COUNT(*) FILTER (WHERE cp.is_completed = true) as completed_count,
    COUNT(*) FILTER (WHERE cp.is_completed = false) as active_count,
    COALESCE(SUM(CASE WHEN cp.is_completed THEN c.challenge_score ELSE 0 END), 0) as total_xp,
    MAX(cp.completed_at) as last_completed
  FROM challenge_participants cp
  JOIN profiles p ON p.id = cp.profile_id
  JOIN challenges c ON c.id = cp.challenge_id
  GROUP BY cp.profile_id, p.nickname, p.first_name, p.avatar_url
  HAVING COUNT(*) FILTER (WHERE cp.is_completed = true) > 0
  ORDER BY completed_count DESC, total_xp DESC
  LIMIT limit_count;
END;
$$;


--
-- Name: FUNCTION get_challenge_leaderboard(limit_count integer); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.get_challenge_leaderboard(limit_count integer) IS 'Returns top users by completed challenges for the leaderboard';


--
-- Name: get_challenge_leaderboard(integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_challenge_leaderboard(p_challenge_id integer, p_limit integer DEFAULT 10) RETURNS jsonb
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
BEGIN
  RETURN (
    SELECT COALESCE(jsonb_agg(
      jsonb_build_object(
        'id', ranked.user_id,
        'nickname', ranked.nickname,
        'avatar_url', ranked.avatar_url,
        'rank', ranked.rank,
        'is_completed', TRUE,
        'completed_at', ranked.created_at
      ) ORDER BY ranked.rank
    ), '[]'::jsonb)
    FROM (
      SELECT
        ca.user_completed_challenge AS user_id,
        p.nickname,
        p.avatar_url,
        ca.created_at,
        ROW_NUMBER() OVER (ORDER BY ca.created_at ASC) AS rank
      FROM challenge_activities ca
      LEFT JOIN profiles p ON p.id = ca.user_completed_challenge
      WHERE ca.challenge_id = p_challenge_id
        AND ca.user_completed_challenge IS NOT NULL
      ORDER BY ca.created_at ASC
      LIMIT p_limit
    ) ranked
  );
END;
$$;


--
-- Name: get_challenges_data(uuid, boolean, boolean, boolean, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_challenges_data(p_user_id uuid, p_include_completed boolean DEFAULT true, p_include_upcoming boolean DEFAULT true, p_include_leaderboard boolean DEFAULT true, p_leaderboard_limit integer DEFAULT 10, p_completed_limit integer DEFAULT 5) RETURNS jsonb
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
DECLARE
  v_result JSONB;
  v_active_challenges JSONB;
  v_completed_challenges JSONB;
  v_upcoming_challenges JSONB;
  v_user_stats JSONB;
  v_leaderboard JSONB;
  v_user_rank INT;
  v_total_participants INT;
BEGIN
  SET LOCAL statement_timeout = '5s';

  -- Get active challenges with user progress
  SELECT COALESCE(jsonb_agg(
    jsonb_build_object(
      'id', c.id,
      'title', c.challenge_title,
      'description', c.challenge_description,
      'type', COALESCE(c.challenge_difficulty, 'daily'),
      'icon_url', c.challenge_image,
      'start_date', c.challenge_created_at,
      'end_date', c.challenge_updated_at,
      'reward_points', c.challenge_score,
      'badge_id', NULL,
      'badge_name', NULL,
      'badge_icon_url', NULL,
      'current_value', COALESCE(
        (SELECT COUNT(*)::int 
         FROM challenge_activities ca 
         WHERE ca.challenge_id = c.id 
           AND ca.user_accepted_challenge = p_user_id),
        0
      ),
      'target_value', COALESCE(c.challenged_people, 1),
      'completed_at', (
        SELECT ca.created_at 
        FROM challenge_activities ca 
        WHERE ca.challenge_id = c.id 
          AND ca.user_completed_challenge = p_user_id 
        LIMIT 1
      ),
      'claimed_at', NULL
    )
  ), '[]'::jsonb)
  INTO v_active_challenges
  FROM challenges c
  WHERE c.challenge_published = TRUE
    AND c.challenge_created_at <= NOW()
    AND (c.challenge_updated_at IS NULL OR c.challenge_updated_at >= NOW())
    AND EXISTS (
      SELECT 1 FROM challenge_activities ca 
      WHERE ca.challenge_id = c.id 
        AND ca.user_accepted_challenge = p_user_id
        AND ca.user_completed_challenge IS NULL
    );

  -- Get completed challenges (if requested)
  IF p_include_completed THEN
    SELECT COALESCE(jsonb_agg(
      jsonb_build_object(
        'id', c.id,
        'title', c.challenge_title,
        'description', c.challenge_description,
        'type', COALESCE(c.challenge_difficulty, 'daily'),
        'icon_url', c.challenge_image,
        'reward_points', c.challenge_score,
        'badge_id', NULL,
        'badge_name', NULL,
        'completed_at', ca.created_at,
        'claimed_at', NULL
      )
    ), '[]'::jsonb)
    INTO v_completed_challenges
    FROM challenges c
    JOIN challenge_activities ca ON ca.challenge_id = c.id
    WHERE ca.user_completed_challenge = p_user_id
    ORDER BY ca.created_at DESC
    LIMIT p_completed_limit;
  ELSE
    v_completed_challenges := '[]'::jsonb;
  END IF;

  -- Get upcoming challenges (if requested)
  IF p_include_upcoming THEN
    SELECT COALESCE(jsonb_agg(
      jsonb_build_object(
        'id', c.id,
        'title', c.challenge_title,
        'description', c.challenge_description,
        'type', COALESCE(c.challenge_difficulty, 'daily'),
        'icon_url', c.challenge_image,
        'start_date', c.challenge_created_at,
        'end_date', c.challenge_updated_at,
        'reward_points', c.challenge_score,
        'badge_id', NULL
      )
    ), '[]'::jsonb)
    INTO v_upcoming_challenges
    FROM challenges c
    WHERE c.challenge_published = TRUE
      AND c.challenge_created_at > NOW()
    ORDER BY c.challenge_created_at ASC
    LIMIT 5;
  ELSE
    v_upcoming_challenges := '[]'::jsonb;
  END IF;

  -- Get user stats
  SELECT jsonb_build_object(
    'total_completed', COUNT(*) FILTER (WHERE ca.user_completed_challenge = p_user_id),
    'current_streak', 0,
    'points_earned', COALESCE(SUM(c.challenge_score) FILTER (WHERE ca.user_completed_challenge = p_user_id), 0),
    'badges_earned', 0
  )
  INTO v_user_stats
  FROM challenge_activities ca
  JOIN challenges c ON c.id = ca.challenge_id
  WHERE ca.user_accepted_challenge = p_user_id OR ca.user_completed_challenge = p_user_id;

  -- Get leaderboard (if requested)
  IF p_include_leaderboard THEN
    WITH user_points AS (
      SELECT 
        ca.user_completed_challenge AS user_id,
        COUNT(*) AS challenges_completed,
        COALESCE(SUM(c.challenge_score), 0) AS points
      FROM challenge_activities ca
      JOIN challenges c ON c.id = ca.challenge_id
      WHERE ca.user_completed_challenge IS NOT NULL
      GROUP BY ca.user_completed_challenge
    ),
    ranked_users AS (
      SELECT 
        up.user_id,
        up.points,
        up.challenges_completed,
        ROW_NUMBER() OVER (ORDER BY up.points DESC, up.challenges_completed DESC) AS rank
      FROM user_points up
    )
    SELECT 
      COALESCE(jsonb_agg(
        jsonb_build_object(
          'user_id', ru.user_id,
          'display_name', p.display_name,
          'avatar_url', p.avatar_url,
          'points', ru.points,
          'challenges_completed', ru.challenges_completed,
          'is_verified', FALSE,
          'member_since', p.created_at
        )
        ORDER BY ru.rank
      ), '[]'::jsonb),
      (SELECT rank FROM ranked_users WHERE user_id = p_user_id),
      (SELECT COUNT(*)::int FROM ranked_users)
    INTO v_leaderboard, v_user_rank, v_total_participants
    FROM ranked_users ru
    JOIN profiles p ON p.id = ru.user_id
    WHERE ru.rank <= p_leaderboard_limit;
  ELSE
    v_leaderboard := '[]'::jsonb;
    v_user_rank := NULL;
    v_total_participants := 0;
  END IF;

  -- Build final result
  v_result := jsonb_build_object(
    'active_challenges', v_active_challenges,
    'completed_challenges', v_completed_challenges,
    'upcoming_challenges', v_upcoming_challenges,
    'user_stats', v_user_stats,
    'leaderboard', v_leaderboard,
    'user_rank', v_user_rank,
    'total_participants', v_total_participants
  );

  RETURN v_result;
END;
$$;


--
-- Name: FUNCTION get_challenges_data(p_user_id uuid, p_include_completed boolean, p_include_upcoming boolean, p_include_leaderboard boolean, p_leaderboard_limit integer, p_completed_limit integer); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.get_challenges_data(p_user_id uuid, p_include_completed boolean, p_include_upcoming boolean, p_include_leaderboard boolean, p_leaderboard_limit integer, p_completed_limit integer) IS 'Returns aggregated challenges data for /api-v1-challenges endpoint';


--
-- Name: get_challenges_screen_data(uuid, text, text, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_challenges_screen_data(p_user_id uuid DEFAULT NULL::uuid, p_difficulty text DEFAULT NULL::text, p_sort_by text DEFAULT 'popular'::text, p_page_limit integer DEFAULT 20, p_page_offset integer DEFAULT 0) RETURNS jsonb
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
DECLARE
  v_result JSONB;
  v_challenges JSONB;
  v_user_challenges JSONB;
  v_leaderboard JSONB;
  v_stats JSONB;
BEGIN
  -- Get all published challenges with participation info
  WITH challenge_data AS (
    SELECT 
      c.id,
      c.challenge_title,
      c.challenge_description,
      c.challenge_image,
      c.challenge_difficulty,
      c.challenge_score,
      c.challenge_action,
      c.challenged_people,
      c.challenge_views,
      c.challenge_likes_counter,
      c.challenge_created_at,
      c.challenge_updated_at,
      -- Creator info (using correct column names)
      p.id AS creator_id,
      COALESCE(p.nickname, p.first_name, 'User') AS creator_name,
      p.avatar_url AS creator_avatar,
      -- User participation (if logged in)
      CASE WHEN p_user_id IS NOT NULL THEN
        EXISTS(SELECT 1 FROM challenge_participants cp WHERE cp.challenge_id = c.id AND cp.profile_id = p_user_id)
      ELSE FALSE END AS user_has_joined,
      CASE WHEN p_user_id IS NOT NULL THEN
        (SELECT is_completed FROM challenge_participants cp WHERE cp.challenge_id = c.id AND cp.profile_id = p_user_id)
      ELSE NULL END AS user_completed,
      -- Completion rate
      CASE WHEN c.challenged_people > 0 THEN
        ROUND((SELECT COUNT(*)::numeric FROM challenge_participants cp WHERE cp.challenge_id = c.id AND cp.is_completed = TRUE) / c.challenged_people * 100, 1)
      ELSE 0 END AS completion_rate
    FROM challenges c
    JOIN profiles p ON c.profile_id = p.id
    WHERE c.challenge_published = TRUE
      AND (p_difficulty IS NULL OR c.challenge_difficulty = p_difficulty)
    ORDER BY 
      CASE p_sort_by
        WHEN 'popular' THEN c.challenged_people
        WHEN 'recent' THEN EXTRACT(EPOCH FROM c.challenge_created_at)
        WHEN 'score' THEN c.challenge_score
        WHEN 'views' THEN c.challenge_views
      END DESC
    LIMIT p_page_limit
    OFFSET p_page_offset
  )
  SELECT COALESCE(jsonb_agg(
    jsonb_build_object(
      'id', id,
      'title', challenge_title,
      'description', challenge_description,
      'image', challenge_image,
      'difficulty', challenge_difficulty,
      'score', challenge_score,
      'action', challenge_action,
      'participantsCount', challenged_people,
      'viewsCount', challenge_views,
      'likesCount', challenge_likes_counter,
      'completionRate', completion_rate,
      'createdAt', challenge_created_at,
      'creator', jsonb_build_object(
        'id', creator_id,
        'name', creator_name,
        'avatar', creator_avatar
      ),
      'userParticipation', jsonb_build_object(
        'hasJoined', user_has_joined,
        'isCompleted', user_completed
      )
    )
  ), '[]'::jsonb) INTO v_challenges FROM challenge_data;

  -- Get user's active challenges (if logged in)
  IF p_user_id IS NOT NULL THEN
    SELECT COALESCE(jsonb_agg(
      jsonb_build_object(
        'id', c.id,
        'title', c.challenge_title,
        'image', c.challenge_image,
        'difficulty', c.challenge_difficulty,
        'score', c.challenge_score,
        'isCompleted', cp.is_completed,
        'joinedAt', cp.accepted_at,
        'completedAt', cp.completed_at
      ) ORDER BY cp.accepted_at DESC
    ), '[]'::jsonb) INTO v_user_challenges
    FROM challenge_participants cp
    JOIN challenges c ON cp.challenge_id = c.id
    WHERE cp.profile_id = p_user_id
    LIMIT 10;
  ELSE
    v_user_challenges := '[]'::jsonb;
  END IF;

  -- Get leaderboard (top participants by completed challenges)
  SELECT COALESCE(jsonb_agg(
    jsonb_build_object(
      'rank', row_number,
      'userId', profile_id,
      'name', name,
      'avatar', avatar_url,
      'completedCount', completed_count,
      'totalScore', total_score
    )
  ), '[]'::jsonb) INTO v_leaderboard
  FROM (
    SELECT 
      ROW_NUMBER() OVER (ORDER BY COUNT(*) FILTER (WHERE cp.is_completed) DESC, SUM(c.challenge_score) DESC) AS row_number,
      cp.profile_id,
      COALESCE(p.nickname, p.first_name, 'User') AS name,
      p.avatar_url,
      COUNT(*) FILTER (WHERE cp.is_completed) AS completed_count,
      COALESCE(SUM(c.challenge_score) FILTER (WHERE cp.is_completed), 0) AS total_score
    FROM challenge_participants cp
    JOIN profiles p ON cp.profile_id = p.id
    JOIN challenges c ON cp.challenge_id = c.id
    GROUP BY cp.profile_id, p.nickname, p.first_name, p.avatar_url
    HAVING COUNT(*) FILTER (WHERE cp.is_completed) > 0
    ORDER BY completed_count DESC, total_score DESC
    LIMIT 10
  ) leaderboard;

  -- Get overall stats
  SELECT jsonb_build_object(
    'totalChallenges', (SELECT COUNT(*) FROM challenges WHERE challenge_published = TRUE),
    'totalParticipants', (SELECT COUNT(DISTINCT profile_id) FROM challenge_participants),
    'totalCompletions', (SELECT COUNT(*) FROM challenge_participants WHERE is_completed = TRUE),
    'difficultyBreakdown', jsonb_build_object(
      'easy', (SELECT COUNT(*) FROM challenges WHERE challenge_published = TRUE AND challenge_difficulty = 'easy'),
      'medium', (SELECT COUNT(*) FROM challenges WHERE challenge_published = TRUE AND challenge_difficulty = 'medium'),
      'hard', (SELECT COUNT(*) FROM challenges WHERE challenge_published = TRUE AND challenge_difficulty = 'hard')
    ),
    'userStats', CASE WHEN p_user_id IS NOT NULL THEN jsonb_build_object(
      'joinedCount', (SELECT COUNT(*) FROM challenge_participants WHERE profile_id = p_user_id),
      'completedCount', (SELECT COUNT(*) FROM challenge_participants WHERE profile_id = p_user_id AND is_completed = TRUE),
      'totalScore', (SELECT COALESCE(SUM(c.challenge_score), 0) FROM challenge_participants cp JOIN challenges c ON cp.challenge_id = c.id WHERE cp.profile_id = p_user_id AND cp.is_completed = TRUE)
    ) ELSE NULL END
  ) INTO v_stats;

  -- Build final response
  v_result := jsonb_build_object(
    'success', TRUE,
    'challenges', v_challenges,
    'userChallenges', v_user_challenges,
    'leaderboard', v_leaderboard,
    'stats', v_stats,
    'pagination', jsonb_build_object(
      'limit', p_page_limit,
      'offset', p_page_offset,
      'hasMore', jsonb_array_length(v_challenges) = p_page_limit
    )
  );

  RETURN v_result;
END;
$$;


--
-- Name: get_chat_screen_data(uuid, uuid, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_chat_screen_data(p_room_id uuid, p_user_id uuid, p_messages_limit integer DEFAULT 50) RETURNS jsonb
    LANGUAGE plpgsql STABLE SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
DECLARE
  v_room JSONB;
  v_messages JSONB;
  v_participants JSONB;
  v_listing JSONB;
BEGIN
  -- Verify user is participant
  IF NOT EXISTS(SELECT 1 FROM rooms WHERE id = p_room_id AND (sharer = p_user_id OR requester = p_user_id)) THEN
    RETURN jsonb_build_object('success', FALSE, 'error', 'Access denied');
  END IF;

  -- Get room details
  SELECT jsonb_build_object(
    'id', r.id,
    'post_id', r.post_id,
    'sharer_id', r.sharer,
    'requester_id', r.requester,
    'last_message', r.last_message,
    'last_message_time', r.last_message_time
  ) INTO v_room
  FROM rooms r
  WHERE r.id = p_room_id;

  -- Get participants
  SELECT jsonb_agg(jsonb_build_object(
    'id', pr.id,
    'nickname', pr.nickname,
    'avatar_url', pr.avatar_url,
    'is_online', COALESCE(pr.last_seen_at > NOW() - INTERVAL '5 minutes', FALSE),
    'is_current_user', pr.id = p_user_id
  ))
  INTO v_participants
  FROM rooms r
  JOIN profiles pr ON pr.id IN (r.sharer, r.requester)
  WHERE r.id = p_room_id;

  -- Get messages (from room_participants which stores message history)
  SELECT COALESCE(jsonb_agg(jsonb_build_object(
    'id', rp.id,
    'text', rp.text,
    'image', rp.image,
    'sender_id', rp.profile_id,
    'timestamp', rp.timestamp,
    'is_mine', rp.profile_id = p_user_id
  ) ORDER BY rp.timestamp DESC), '[]'::jsonb)
  INTO v_messages
  FROM room_participants rp
  WHERE rp.room_id = p_room_id
  LIMIT p_messages_limit;

  -- Get associated listing if exists
  SELECT jsonb_build_object(
    'id', p.id,
    'post_name', p.post_name,
    'images', COALESCE(p.images[1:1], ARRAY[]::TEXT[]),
    'is_active', p.is_active,
    'is_arranged', p.is_arranged
  ) INTO v_listing
  FROM rooms r
  JOIN posts p ON p.id = r.post_id
  WHERE r.id = p_room_id;

  -- Mark messages as read
  UPDATE rooms 
  SET last_message_seen_by = p_user_id 
  WHERE id = p_room_id AND last_message_sent_by != p_user_id;

  RETURN jsonb_build_object(
    'success', TRUE,
    'room', v_room,
    'participants', v_participants,
    'messages', v_messages,
    'listing', v_listing,
    'meta', jsonb_build_object(
      'timestamp', NOW(),
      'messages_count', jsonb_array_length(v_messages)
    )
  );
END;
$$;


--
-- Name: FUNCTION get_chat_screen_data(p_room_id uuid, p_user_id uuid, p_messages_limit integer); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.get_chat_screen_data(p_room_id uuid, p_user_id uuid, p_messages_limit integer) IS 'Returns all data needed for chat screen';


--
-- Name: get_chat_thread(uuid, integer, uuid, boolean); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_chat_thread(p_room_id uuid, p_limit integer DEFAULT 50, p_before_id uuid DEFAULT NULL::uuid, p_mark_read boolean DEFAULT true) RETURNS jsonb
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public', 'pg_temp'
    AS $$
DECLARE
  v_user_id uuid;
  v_result jsonb;
  v_room jsonb;
  v_messages jsonb;
  v_other_user jsonb;
  v_post jsonb;
BEGIN
  v_user_id := auth.uid();
  
  IF v_user_id IS NULL THEN
    RAISE EXCEPTION 'Authentication required';
  END IF;
  
  -- Verify user is participant
  IF NOT EXISTS (
    SELECT 1 FROM rooms 
    WHERE id = p_room_id 
    AND (requester_id = v_user_id OR sharer_id = v_user_id)
  ) THEN
    RAISE EXCEPTION 'Not a participant of this room';
  END IF;
  
  -- Get room details
  SELECT jsonb_build_object(
    'id', r.id,
    'post_id', r.post_id,
    'requester_id', r.requester_id,
    'sharer_id', r.sharer_id,
    'is_arranged', r.is_arranged,
    'created_at', r.created_at
  )
  INTO v_room
  FROM rooms r
  WHERE r.id = p_room_id;
  
  -- Get other user details
  SELECT jsonb_build_object(
    'id', p.id,
    'nickname', p.nickname,
    'avatar_url', p.avatar_url,
    'is_verified', p.is_verified
  )
  INTO v_other_user
  FROM profiles p
  JOIN rooms r ON r.id = p_room_id
  WHERE p.id = CASE 
    WHEN r.requester_id = v_user_id THEN r.sharer_id 
    ELSE r.requester_id 
  END;
  
  -- Get post details
  SELECT jsonb_build_object(
    'id', po.id,
    'post_name', po.post_name,
    'images', po.images,
    'is_active', po.is_active,
    'is_arranged', po.is_arranged
  )
  INTO v_post
  FROM posts po
  JOIN rooms r ON r.post_id = po.id
  WHERE r.id = p_room_id;
  
  -- Get messages
  SELECT jsonb_agg(msg ORDER BY created_at DESC)
  INTO v_messages
  FROM (
    SELECT jsonb_build_object(
      'id', m.id,
      'content', m.content,
      'sender_id', m.sender_id,
      'is_mine', m.sender_id = v_user_id,
      'created_at', m.created_at,
      'read_at', m.read_at
    ) as msg,
    m.created_at
    FROM messages m
    WHERE m.room_id = p_room_id
    AND (p_before_id IS NULL OR m.id < p_before_id)
    ORDER BY m.created_at DESC
    LIMIT p_limit
  ) sub;
  
  -- Mark messages as read if requested
  IF p_mark_read THEN
    UPDATE messages
    SET read_at = now()
    WHERE room_id = p_room_id
    AND sender_id != v_user_id
    AND read_at IS NULL;
  END IF;
  
  -- Build result
  v_result := jsonb_build_object(
    'room', v_room,
    'other_user', v_other_user,
    'post', v_post,
    'messages', COALESCE(v_messages, '[]'::jsonb),
    'has_more', (
      SELECT COUNT(*) > p_limit
      FROM messages m
      WHERE m.room_id = p_room_id
      AND (p_before_id IS NULL OR m.id < p_before_id)
    )
  );
  
  RETURN v_result;
END;
$$;


--
-- Name: get_comment_reactions(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_comment_reactions(p_comment_id integer) RETURNS TABLE(reaction_type_id integer, reaction_name text, reaction_emoji text, count bigint, user_reacted boolean, recent_users jsonb)
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
BEGIN
  RETURN QUERY
  SELECT 
    rt.id,
    rt.name,
    rt.emoji,
    COUNT(cr.id),
    BOOL_OR(cr.profile_id = auth.uid()),
    jsonb_agg(
      jsonb_build_object(
        'id', p.id,
        'first_name', p.first_name,
        'avatar_url', p.avatar_url
      )
    ) FILTER (WHERE p.id IS NOT NULL)
  FROM reaction_types rt
  LEFT JOIN forum_comment_reactions cr ON cr.reaction_type_id = rt.id AND cr.comment_id = p_comment_id
  LEFT JOIN profiles p ON p.id = cr.profile_id
  GROUP BY rt.id, rt.name, rt.emoji
  HAVING COUNT(cr.id) > 0
  ORDER BY COUNT(cr.id) DESC;
END;
$$;


--
-- Name: get_comprehensive_quota_status(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_comprehensive_quota_status(p_organization_id uuid DEFAULT '00000000-0000-0000-0000-000000000001'::uuid) RETURNS TABLE(provider text, daily_sent integer, daily_limit integer, daily_remaining integer, daily_percent_used numeric, monthly_sent integer, monthly_limit integer, monthly_remaining integer, monthly_percent_used numeric, is_available boolean)
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO ''
    AS $$
DECLARE
  v_today date := CURRENT_DATE;
  v_year_month text := to_char(CURRENT_DATE, 'YYYY-MM');
BEGIN
  RETURN QUERY
  WITH daily AS (
    SELECT 
      q.provider,
      COALESCE(q.emails_sent, 0) as sent,
      q.daily_limit as lim
    FROM public.email_provider_quota q
    WHERE q.date = v_today AND q.organization_id = p_organization_id
  ),
  monthly AS (
    SELECT 
      m.provider,
      COALESCE(m.emails_sent, 0) as sent,
      m.monthly_limit as lim
    FROM public.email_provider_monthly_quota m
    WHERE m.year_month = v_year_month AND m.organization_id = p_organization_id
  ),
  providers AS (
    SELECT unnest(ARRAY['resend', 'brevo', 'aws_ses']) as prov
  )
  SELECT 
    p.prov as provider,
    COALESCE(d.sent, 0)::integer as daily_sent,
    COALESCE(d.lim, CASE p.prov WHEN 'resend' THEN 100 WHEN 'brevo' THEN 300 ELSE 100 END)::integer as daily_limit,
    GREATEST(0, COALESCE(d.lim, CASE p.prov WHEN 'resend' THEN 100 WHEN 'brevo' THEN 300 ELSE 100 END) - COALESCE(d.sent, 0))::integer as daily_remaining,
    CASE WHEN COALESCE(d.lim, 100) > 0 
      THEN ROUND((COALESCE(d.sent, 0)::numeric / COALESCE(d.lim, 100)::numeric) * 100, 1)
      ELSE 0 
    END as daily_percent_used,
    COALESCE(m.sent, 0)::integer as monthly_sent,
    COALESCE(m.lim, CASE p.prov WHEN 'resend' THEN 3000 WHEN 'brevo' THEN 9000 ELSE 62000 END)::integer as monthly_limit,
    GREATEST(0, COALESCE(m.lim, CASE p.prov WHEN 'resend' THEN 3000 WHEN 'brevo' THEN 9000 ELSE 62000 END) - COALESCE(m.sent, 0))::integer as monthly_remaining,
    CASE WHEN COALESCE(m.lim, 3000) > 0 
      THEN ROUND((COALESCE(m.sent, 0)::numeric / COALESCE(m.lim, 3000)::numeric) * 100, 1)
      ELSE 0 
    END as monthly_percent_used,
    (COALESCE(d.sent, 0) < COALESCE(d.lim, 100) AND COALESCE(m.sent, 0) < COALESCE(m.lim, 3000)) as is_available
  FROM providers p
  LEFT JOIN daily d ON d.provider = p.prov
  LEFT JOIN monthly m ON m.provider = p.prov;
END;
$$;


--
-- Name: get_connection_pool_stats(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_connection_pool_stats() RETURNS TABLE(total_connections integer, active_connections integer, utilization_percent numeric)
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public', 'pg_temp'
    AS $$
DECLARE
    v_max_connections INT;
    v_current_connections INT;
BEGIN
    SELECT setting::INT INTO v_max_connections
    FROM pg_settings WHERE name = 'max_connections';

    SELECT COUNT(*)::INT INTO v_current_connections
    FROM pg_stat_activity WHERE state IS NOT NULL;

    RETURN QUERY SELECT
        v_max_connections,
        v_current_connections,
        ROUND((v_current_connections::NUMERIC / v_max_connections::NUMERIC) * 100, 2);
END;
$$;


--
-- Name: FUNCTION get_connection_pool_stats(); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.get_connection_pool_stats() IS 'Returns database connection pool utilization';


--
-- Name: get_crm_customer_summary(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_crm_customer_summary(p_customer_id uuid) RETURNS TABLE(customer_id uuid, profile_id uuid, full_name text, email text, status text, lifetime_value numeric, total_transactions integer, items_shared integer, items_received integer, rating_average numeric, forum_reputation integer, trust_level integer, tags jsonb, last_interaction_at timestamp with time zone, created_at timestamp with time zone)
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO ''
    AS $$
BEGIN
  RETURN QUERY
  SELECT 
    c.id as customer_id,
    c.profile_id,
    COALESCE(p.first_name || ' ' || p.second_name, p.nickname, p.email) as full_name,
    p.email,
    c.status,
    c.lifetime_value,
    c.total_transactions,
    COALESCE(ps.items_shared, 0) as items_shared,
    COALESCE(ps.items_received, 0) as items_received,
    ps.rating_average,
    COALESCE(fus.reputation_score, 0) as forum_reputation,
    COALESCE(fus.trust_level, 0) as trust_level,
    COALESCE(
      (SELECT jsonb_agg(jsonb_build_object('id', t.id, 'name', t.name, 'color', t.color))
       FROM public.crm_customer_tag_assignments cta
       JOIN public.crm_customer_tags t ON cta.tag_id = t.id
       WHERE cta.customer_id = c.id),
      '[]'::jsonb
    ) as tags,
    c.last_interaction_at,
    c.created_at
  FROM public.crm_customers c
  JOIN public.profiles p ON c.profile_id = p.id
  LEFT JOIN public.profile_stats ps ON p.id = ps.profile_id
  LEFT JOIN public.forum_user_stats fus ON p.id = fus.profile_id
  WHERE c.id = p_customer_id;
END;
$$;


--
-- Name: get_current_aal(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_current_aal(p_profile_id uuid) RETURNS text
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO ''
    AS $$
DECLARE
  v_session RECORD;
BEGIN
  SELECT * INTO v_session
  FROM mfa_sessions
  WHERE profile_id = p_profile_id
    AND is_active = TRUE
    AND expires_at > NOW()
  ORDER BY created_at DESC
  LIMIT 1;

  IF v_session.id IS NULL THEN
    RETURN 'aal1';
  END IF;

  RETURN v_session.current_aal;
END;
$$;


--
-- Name: get_dashboard_stats(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_dashboard_stats() RETURNS jsonb
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
DECLARE
  v_today timestamptz;
  v_result jsonb;
BEGIN
  -- Calculate start of today (in UTC)
  v_today := date_trunc('day', now());
  
  SELECT jsonb_build_object(
    'total_users', (SELECT COUNT(*) FROM profiles),
    'active_users', (SELECT COUNT(*) FROM profiles WHERE is_active = true),
    'total_posts', (SELECT COUNT(*) FROM posts),
    'active_posts', (SELECT COUNT(*) FROM posts WHERE is_active = true),
    'pending_reports', (SELECT COUNT(*) FROM forum_moderation_queue WHERE status = 'pending'),
    'total_messages', (SELECT COUNT(*) FROM room_participants),
    'new_users_today', (SELECT COUNT(*) FROM profiles WHERE created_time >= v_today),
    'new_posts_today', (SELECT COUNT(*) FROM posts WHERE created_at >= v_today)
  ) INTO v_result;
  
  RETURN v_result;
END;
$$;


--
-- Name: FUNCTION get_dashboard_stats(); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.get_dashboard_stats() IS 'Returns all admin dashboard statistics in a single call. Replaces 8 separate COUNT queries.';


--
-- Name: get_delta_sync(uuid, text[]); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_delta_sync(p_user_id uuid, p_tables text[] DEFAULT ARRAY['notifications'::text, 'rooms'::text]) RETURNS jsonb
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
DECLARE
  v_result jsonb := '{}'::jsonb;
  v_table text;
  v_checkpoint bigint;
  v_current_version bigint;
  v_changes jsonb;
  v_change_count integer := 0;
BEGIN
  -- Get current max sync version
  SELECT MAX(sync_version) INTO v_current_version
  FROM (
    SELECT sync_version FROM posts WHERE sync_version IS NOT NULL
    UNION ALL
    SELECT sync_version FROM notifications WHERE sync_version IS NOT NULL
    UNION ALL
    SELECT sync_version FROM rooms WHERE sync_version IS NOT NULL
  ) all_versions;

  v_current_version := COALESCE(v_current_version, 0);

  -- Process each requested table
  FOREACH v_table IN ARRAY p_tables
  LOOP
    -- Get checkpoint for this table
    SELECT last_sync_version INTO v_checkpoint
    FROM sync_checkpoints
    WHERE user_id = p_user_id AND table_name = v_table;

    v_checkpoint := COALESCE(v_checkpoint, 0);

    -- Get changes based on table
    CASE v_table
      WHEN 'notifications' THEN
        SELECT COALESCE(jsonb_agg(
          jsonb_build_object(
            'id', n.id,
            'title', n.notification_title,
            'text', n.notification_text,
            'timestamp', n.timestamp,
            'readAt', n.read_at,
            'screen', n.initial_page_name,
            'params', n.parameter_data,
            'syncVersion', n.sync_version,
            '_operation', 'upsert'
          )
        ), '[]'::jsonb) INTO v_changes
        FROM notifications n
        WHERE n.profile_id = p_user_id
          AND n.sync_version > v_checkpoint;

      WHEN 'rooms' THEN
        SELECT COALESCE(jsonb_agg(
          jsonb_build_object(
            'id', r.id,
            'postId', r.post_id,
            'sharer', r.sharer,
            'requester', r.requester,
            'lastMessage', r.last_message,
            'lastMessageTime', r.last_message_time,
            'lastMessageSentBy', r.last_message_sent_by,
            'syncVersion', r.sync_version,
            '_operation', 'upsert'
          )
        ), '[]'::jsonb) INTO v_changes
        FROM rooms r
        WHERE (r.sharer = p_user_id OR r.requester = p_user_id)
          AND r.sync_version > v_checkpoint;

      WHEN 'posts' THEN
        SELECT COALESCE(jsonb_agg(
          jsonb_build_object(
            'id', fi.id,
            'postName', fi.post_name,
            'description', fi.description,
            'images', fi.images,
            'postType', fi.post_type,
            'isActive', fi.is_active,
            'latitude', fi.latitude,
            'longitude', fi.longitude,
            'pickupAddress', fi.pickup_address,
            'createdAt', fi.created_at,
            'updatedAt', fi.updated_at,
            'syncVersion', fi.sync_version,
            '_operation', CASE WHEN fi.deleted_at IS NOT NULL THEN 'delete' ELSE 'upsert' END
          )
        ), '[]'::jsonb) INTO v_changes
        FROM posts fi
        WHERE fi.profile_id = p_user_id
          AND fi.sync_version > v_checkpoint;

      ELSE
        v_changes := '[]'::jsonb;
    END CASE;

    v_result := v_result || jsonb_build_object(v_table, v_changes);
    v_change_count := v_change_count + jsonb_array_length(v_changes);

    -- Update checkpoint
    INSERT INTO sync_checkpoints (user_id, table_name, last_sync_version, last_sync_at)
    VALUES (p_user_id, v_table, v_current_version, NOW())
    ON CONFLICT (user_id, table_name) DO UPDATE
    SET last_sync_version = EXCLUDED.last_sync_version,
        last_sync_at = EXCLUDED.last_sync_at;
  END LOOP;

  RETURN jsonb_build_object(
    'success', true,
    'changes', v_result,
    'stats', jsonb_build_object(
      'totalChanges', v_change_count,
      'currentVersion', v_current_version
    ),
    'meta', jsonb_build_object(
      'timestamp', NOW(),
      'tables', p_tables
    )
  );
END;
$$;


--
-- Name: FUNCTION get_delta_sync(p_user_id uuid, p_tables text[]); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.get_delta_sync(p_user_id uuid, p_tables text[]) IS 'Returns changes since last sync with automatic checkpoint update';


--
-- Name: get_delta_translations(character varying, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_delta_translations(p_locale character varying, p_from_version character varying) RETURNS jsonb
    LANGUAGE plpgsql STABLE
    SET search_path TO ''
    AS $$
DECLARE
  v_changes JSONB := '{}';
  v_from_timestamp TIMESTAMPTZ;
BEGIN
  -- Get the timestamp of the from_version
  SELECT created_at INTO v_from_timestamp
  FROM translation_versions
  WHERE locale = p_locale AND version = p_from_version
  ORDER BY created_at DESC
  LIMIT 1;

  -- If version not found, return empty (client should do full fetch)
  IF v_from_timestamp IS NULL THEN
    RETURN '{}'::JSONB;
  END IF;

  -- Aggregate all changes since that version
  SELECT COALESCE(jsonb_object_agg(key, value), '{}'::JSONB)
  INTO v_changes
  FROM (
    SELECT key, value
    FROM translation_versions tv,
         jsonb_each(tv.changes) AS kv(key, value)
    WHERE tv.locale = p_locale
      AND tv.created_at > v_from_timestamp
    ORDER BY tv.created_at ASC
  ) aggregated;

  RETURN v_changes;
END;
$$;


--
-- Name: get_display_name_data(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_display_name_data(p_user_id uuid) RETURNS jsonb
    LANGUAGE plpgsql STABLE SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
DECLARE
  v_profile jsonb;
  v_override jsonb;
BEGIN
  -- Get profile data
  SELECT jsonb_build_object(
    'id', id,
    'display_name', display_name,
    'first_name', first_name,
    'second_name', second_name,
    'nickname', nickname,
    'email', email
  )
  INTO v_profile
  FROM profiles
  WHERE id = p_user_id
    AND deleted_at IS NULL;

  -- Get override if exists and not expired
  SELECT jsonb_build_object(
    'user_id', user_id,
    'display_name', display_name,
    'reason', reason,
    'overridden_by', overridden_by,
    'expires_at', expires_at,
    'created_at', created_at
  )
  INTO v_override
  FROM display_name_overrides
  WHERE user_id = p_user_id
    AND (expires_at IS NULL OR expires_at > now());

  RETURN jsonb_build_object(
    'profile', v_profile,
    'override', v_override
  );
END;
$$;


--
-- Name: FUNCTION get_display_name_data(p_user_id uuid); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.get_display_name_data(p_user_id uuid) IS 'Get profile and override data for display name extraction';


--
-- Name: get_display_name_data_batch(uuid[]); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_display_name_data_batch(p_user_ids uuid[]) RETURNS TABLE(user_id uuid, profile jsonb, override jsonb)
    LANGUAGE plpgsql STABLE SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
BEGIN
  -- Limit batch size to 100
  IF array_length(p_user_ids, 1) > 100 THEN
    RAISE EXCEPTION 'Batch size exceeds maximum of 100';
  END IF;

  RETURN QUERY
  WITH user_profiles AS (
    SELECT
      p.id,
      jsonb_build_object(
        'id', p.id,
        'display_name', p.display_name,
        'first_name', p.first_name,
        'second_name', p.second_name,
        'nickname', p.nickname,
        'email', p.email
      ) AS profile_data
    FROM profiles p
    WHERE p.id = ANY(p_user_ids)
      AND p.deleted_at IS NULL
  ),
  user_overrides AS (
    SELECT
      o.user_id AS uid,
      jsonb_build_object(
        'user_id', o.user_id,
        'display_name', o.display_name,
        'reason', o.reason,
        'overridden_by', o.overridden_by,
        'expires_at', o.expires_at,
        'created_at', o.created_at
      ) AS override_data
    FROM display_name_overrides o
    WHERE o.user_id = ANY(p_user_ids)
      AND (o.expires_at IS NULL OR o.expires_at > now())
  )
  SELECT
    uid AS user_id,
    up.profile_data AS profile,
    uo.override_data AS override
  FROM unnest(p_user_ids) AS uid
  LEFT JOIN user_profiles up ON up.id = uid
  LEFT JOIN user_overrides uo ON uo.uid = uid;
END;
$$;


--
-- Name: FUNCTION get_display_name_data_batch(p_user_ids uuid[]); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.get_display_name_data_batch(p_user_ids uuid[]) IS 'Batch lookup for display name data (max 100 users)';


--
-- Name: get_draft_count(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_draft_count() RETURNS integer
    LANGUAGE sql STABLE SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
  SELECT COUNT(*)::INT FROM public.forum_drafts WHERE profile_id = (SELECT auth.uid());
$$;


--
-- Name: get_edge_function_url(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_edge_function_url() RETURNS text
    LANGUAGE plpgsql IMMUTABLE
    AS $$
BEGIN
  RETURN 'https://***REMOVED***/functions/v1';
END;
$$;


--
-- Name: get_email_dashboard_stats_v2(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_email_dashboard_stats_v2() RETURNS jsonb
    LANGUAGE plpgsql STABLE SECURITY DEFINER
    AS $$
DECLARE
  v_result jsonb;
  v_today date := CURRENT_DATE;
  v_30_days_ago date := CURRENT_DATE - INTERVAL '30 days';
  v_7_days_ago date := CURRENT_DATE - INTERVAL '7 days';
BEGIN
  SELECT jsonb_build_object(
    -- Overall metrics (30 days)
    'totalSent', COALESCE((
      SELECT COUNT(*) FROM email_delivery_log
      WHERE queued_at >= v_30_days_ago AND status != 'queued'
    ), 0),
    'totalDelivered', COALESCE((
      SELECT COUNT(*) FROM email_delivery_log
      WHERE queued_at >= v_30_days_ago AND status IN ('delivered', 'opened', 'clicked')
    ), 0),
    'totalOpened', COALESCE((
      SELECT COUNT(*) FROM email_delivery_log
      WHERE queued_at >= v_30_days_ago AND status IN ('opened', 'clicked')
    ), 0),
    'totalClicked', COALESCE((
      SELECT COUNT(*) FROM email_delivery_log
      WHERE queued_at >= v_30_days_ago AND status = 'clicked'
    ), 0),
    'totalBounced', COALESCE((
      SELECT COUNT(*) FROM email_delivery_log
      WHERE queued_at >= v_30_days_ago AND status = 'bounced'
    ), 0),
    'totalFailed', COALESCE((
      SELECT COUNT(*) FROM email_delivery_log
      WHERE queued_at >= v_30_days_ago AND status = 'failed'
    ), 0),
    'totalComplained', COALESCE((
      SELECT COUNT(*) FROM email_delivery_log
      WHERE queued_at >= v_30_days_ago AND status = 'complained'
    ), 0),

    -- Today's metrics
    'sentToday', COALESCE((
      SELECT COUNT(*) FROM email_delivery_log
      WHERE queued_at >= v_today AND status != 'queued'
    ), 0),

    -- Queue status
    'queuePending', COALESCE((
      SELECT COUNT(*) FROM email_delivery_log WHERE status = 'queued'
    ), 0),

    -- Subscriber counts
    'totalSubscribers', COALESCE((
      SELECT COUNT(DISTINCT user_id) FROM notification_preferences
      WHERE channel = 'email' AND enabled = true
    ), 0),
    'activeSubscribers', COALESCE((
      SELECT COUNT(DISTINCT np.user_id) FROM notification_preferences np
      JOIN profiles p ON p.id = np.user_id
      WHERE np.channel = 'email' AND np.enabled = true
    ), 0),

    -- Provider stats (today)
    'providers', COALESCE((
      SELECT jsonb_agg(jsonb_build_object(
        'provider', provider,
        'requestsTotal', requests_total,
        'requestsSuccess', requests_success,
        'requestsFailed', requests_failed,
        'emailsSent', emails_sent,
        'emailsDelivered', emails_delivered,
        'emailsOpened', emails_opened,
        'emailsClicked', emails_clicked,
        'emailsBounced', emails_bounced,
        'successRate', CASE WHEN requests_total > 0
          THEN ROUND((requests_success::numeric / requests_total) * 100, 1)
          ELSE 100 END,
        'avgLatencyMs', avg_latency_ms,
        'dailyQuotaUsed', emails_sent,
        'dailyQuotaLimit', daily_quota_limit
      ))
      FROM email_provider_stats
      WHERE date = v_today
    ), '[]'::jsonb),

    -- Provider stats (30 days aggregate)
    'providers30d', COALESCE((
      SELECT jsonb_agg(jsonb_build_object(
        'provider', provider,
        'emailsSent', total_sent,
        'emailsDelivered', total_delivered,
        'emailsOpened', total_opened,
        'emailsClicked', total_clicked,
        'emailsBounced', total_bounced,
        'successRate', CASE WHEN total_requests > 0
          THEN ROUND((total_success::numeric / total_requests) * 100, 1)
          ELSE 100 END
      ))
      FROM (
        SELECT
          provider,
          SUM(requests_total) as total_requests,
          SUM(requests_success) as total_success,
          SUM(emails_sent) as total_sent,
          SUM(emails_delivered) as total_delivered,
          SUM(emails_opened) as total_opened,
          SUM(emails_clicked) as total_clicked,
          SUM(emails_bounced) as total_bounced
        FROM email_provider_stats
        WHERE date >= v_30_days_ago
        GROUP BY provider
      ) agg
    ), '[]'::jsonb),

    -- Rates (30 days)
    'openRate', COALESCE((
      SELECT ROUND(
        (COUNT(*) FILTER (WHERE status IN ('opened', 'clicked'))::numeric /
         NULLIF(COUNT(*) FILTER (WHERE status IN ('delivered', 'opened', 'clicked')), 0)) * 100, 1
      )
      FROM email_delivery_log
      WHERE queued_at >= v_30_days_ago
    ), 0),
    'clickRate', COALESCE((
      SELECT ROUND(
        (COUNT(*) FILTER (WHERE status = 'clicked')::numeric /
         NULLIF(COUNT(*) FILTER (WHERE status IN ('opened', 'clicked')), 0)) * 100, 1
      )
      FROM email_delivery_log
      WHERE queued_at >= v_30_days_ago
    ), 0),
    'bounceRate', COALESCE((
      SELECT ROUND(
        (COUNT(*) FILTER (WHERE status = 'bounced')::numeric /
         NULLIF(COUNT(*) FILTER (WHERE status != 'queued'), 0)) * 100, 1
      )
      FROM email_delivery_log
      WHERE queued_at >= v_30_days_ago
    ), 0),

    -- Daily breakdown (last 7 days for chart)
    'dailyStats', COALESCE((
      SELECT jsonb_agg(daily_data ORDER BY day)
      FROM (
        SELECT
          queued_at::date as day,
          jsonb_build_object(
            'date', queued_at::date,
            'sent', COUNT(*) FILTER (WHERE status != 'queued'),
            'delivered', COUNT(*) FILTER (WHERE status IN ('delivered', 'opened', 'clicked')),
            'opened', COUNT(*) FILTER (WHERE status IN ('opened', 'clicked')),
            'clicked', COUNT(*) FILTER (WHERE status = 'clicked'),
            'bounced', COUNT(*) FILTER (WHERE status = 'bounced')
          ) as daily_data
        FROM email_delivery_log
        WHERE queued_at >= v_7_days_ago
        GROUP BY queued_at::date
      ) daily
    ), '[]'::jsonb),

    -- Email type breakdown
    'byType', COALESCE((
      SELECT jsonb_agg(jsonb_build_object(
        'type', email_type,
        'sent', cnt,
        'percentage', ROUND((cnt::numeric / NULLIF(total, 0)) * 100, 1)
      ))
      FROM (
        SELECT
          email_type,
          COUNT(*) as cnt,
          SUM(COUNT(*)) OVER () as total
        FROM email_delivery_log
        WHERE queued_at >= v_30_days_ago AND status != 'queued'
        GROUP BY email_type
      ) type_stats
    ), '[]'::jsonb),

    -- Recent campaigns
    'recentCampaigns', COALESCE((
      SELECT jsonb_agg(jsonb_build_object(
        'id', id,
        'name', name,
        'subject', subject,
        'sentAt', sent_at,
        'totalSent', total_sent,
        'totalOpened', total_opened,
        'totalClicked', total_clicked,
        'openRate', CASE WHEN total_sent > 0
          THEN ROUND((total_opened::numeric / total_sent) * 100, 1) ELSE 0 END,
        'clickRate', CASE WHEN total_opened > 0
          THEN ROUND((total_clicked::numeric / total_opened) * 100, 1) ELSE 0 END
      ) ORDER BY sent_at DESC)
      FROM newsletter_campaigns
      WHERE status = 'sent' AND sent_at >= v_30_days_ago
      LIMIT 5
    ), '[]'::jsonb),

    -- Metadata
    'generatedAt', now(),
    'periodStart', v_30_days_ago,
    'periodEnd', v_today

  ) INTO v_result;

  RETURN v_result;
END;
$$;


--
-- Name: FUNCTION get_email_dashboard_stats_v2(); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.get_email_dashboard_stats_v2() IS 'Comprehensive email dashboard statistics from email_delivery_log';


--
-- Name: get_email_provider_health(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_email_provider_health() RETURNS jsonb
    LANGUAGE plpgsql STABLE SECURITY DEFINER
    AS $$
BEGIN
  RETURN (
    SELECT jsonb_agg(jsonb_build_object(
      'provider', s.provider,

      -- Today's stats
      'today', jsonb_build_object(
        'requests', COALESCE(t.requests_total, 0),
        'success', COALESCE(t.requests_success, 0),
        'failed', COALESCE(t.requests_failed, 0),
        'successRate', CASE WHEN COALESCE(t.requests_total, 0) > 0
          THEN ROUND((t.requests_success::numeric / t.requests_total) * 100, 1)
          ELSE 100 END,
        'avgLatencyMs', COALESCE(t.avg_latency_ms, 0),
        'sent', COALESCE(t.emails_sent, 0),
        'delivered', COALESCE(t.emails_delivered, 0),
        'opened', COALESCE(t.emails_opened, 0),
        'clicked', COALESCE(t.emails_clicked, 0),
        'bounced', COALESCE(t.emails_bounced, 0)
      ),

      -- This month's stats
      'month', jsonb_build_object(
        'requests', COALESCE(m.requests_total, 0),
        'success', COALESCE(m.requests_success, 0),
        'sent', COALESCE(m.emails_sent, 0),
        'delivered', COALESCE(m.emails_delivered, 0)
      ),

      -- Quotas
      'quota', jsonb_build_object(
        'dailyUsed', COALESCE(t.emails_sent, 0),
        'dailyLimit', COALESCE(t.daily_quota_limit, 500),
        'dailyRemaining', GREATEST(COALESCE(t.daily_quota_limit, 500) - COALESCE(t.emails_sent, 0), 0),
        'monthlyUsed', COALESCE(m.emails_sent, 0),
        'monthlyLimit', COALESCE(t.monthly_quota_limit, 15000),
        'monthlyRemaining', GREATEST(COALESCE(t.monthly_quota_limit, 15000) - COALESCE(m.emails_sent, 0), 0)
      ),

      -- Status
      'status', CASE
        WHEN COALESCE(t.requests_total, 0) = 0 THEN 'idle'
        WHEN COALESCE(t.requests_success, 0)::numeric / NULLIF(t.requests_total, 1) >= 0.95 THEN 'healthy'
        WHEN COALESCE(t.requests_success, 0)::numeric / NULLIF(t.requests_total, 1) >= 0.80 THEN 'degraded'
        ELSE 'unhealthy'
      END
    ))
    FROM (
      SELECT DISTINCT provider FROM email_provider_stats
      UNION
      SELECT unnest(ARRAY['resend', 'brevo', 'aws_ses', 'mailersend'])
    ) s
    LEFT JOIN email_provider_stats t ON t.provider = s.provider AND t.date = CURRENT_DATE
    LEFT JOIN (
      SELECT
        provider,
        SUM(requests_total) as requests_total,
        SUM(requests_success) as requests_success,
        SUM(emails_sent) as emails_sent,
        SUM(emails_delivered) as emails_delivered
      FROM email_provider_stats
      WHERE date >= DATE_TRUNC('month', CURRENT_DATE)
      GROUP BY provider
    ) m ON m.provider = s.provider
  );
END;
$$;


--
-- Name: FUNCTION get_email_provider_health(); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.get_email_provider_health() IS 'Provider health and quota status for dashboard';


--
-- Name: get_email_template(text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_email_template(p_slug text) RETURNS TABLE(id uuid, slug text, name text, category text, subject text, html_content text, text_content text, variables jsonb, metadata jsonb, version integer)
    LANGUAGE plpgsql STABLE SECURITY DEFINER
    AS $$
BEGIN
  RETURN QUERY SELECT et.id, et.slug, et.name, et.category, et.subject, et.html_content, et.text_content, et.variables, et.metadata, et.version
  FROM email_templates et WHERE et.slug = p_slug AND et.is_active = true LIMIT 1;
END;
$$;


--
-- Name: get_email_template_history(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_email_template_history(p_template_id uuid) RETURNS TABLE(id uuid, version integer, subject text, changed_by uuid, changed_at timestamp with time zone, change_reason text)
    LANGUAGE plpgsql STABLE SECURITY DEFINER
    AS $$
BEGIN
  RETURN QUERY SELECT etv.id, etv.version, etv.subject::TEXT, etv.changed_by, etv.changed_at, etv.change_reason
  FROM email_template_versions etv WHERE etv.template_id = p_template_id ORDER BY etv.version DESC;
END;
$$;


--
-- Name: get_error_rate(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_error_rate(p_minutes integer DEFAULT 5) RETURNS TABLE(total_requests bigint, error_count bigint, error_rate numeric)
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public', 'pg_temp'
    AS $$
BEGIN
    RETURN QUERY
    SELECT
        COUNT(*)::BIGINT as total_requests,
        COUNT(*) FILTER (WHERE status_code >= 400 OR status_code IS NULL)::BIGINT as error_count,
        CASE
            WHEN COUNT(*) = 0 THEN 0
            ELSE ROUND(
                (COUNT(*) FILTER (WHERE status_code >= 400 OR status_code IS NULL)::NUMERIC / COUNT(*)::NUMERIC) * 100,
                2
            )
        END as error_rate
    FROM metrics.api_requests
    WHERE created_at > now() - (p_minutes || ' minutes')::INTERVAL;
END;
$$;


--
-- Name: FUNCTION get_error_rate(p_minutes integer); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.get_error_rate(p_minutes integer) IS 'Returns error rate percentage for the last N minutes';


--
-- Name: get_experiment_variant(uuid, text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_experiment_variant(p_user_id uuid, p_experiment_key text) RETURNS jsonb
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
DECLARE
  v_experiment record;
  v_assignment record;
  v_user_hash integer;
  v_cumulative_weight integer := 0;
  v_variant jsonb;
  v_variant_id text;
BEGIN
  -- Get experiment
  SELECT * INTO v_experiment
  FROM experiments
  WHERE key = p_experiment_key;

  IF v_experiment IS NULL THEN
    RETURN jsonb_build_object(
      'success', false,
      'error', 'EXPERIMENT_NOT_FOUND'
    );
  END IF;

  -- Check if experiment is running
  IF v_experiment.status != 'running' THEN
    RETURN jsonb_build_object(
      'success', true,
      'experimentKey', p_experiment_key,
      'variant', NULL,
      'reason', 'experiment_not_running',
      'status', v_experiment.status
    );
  END IF;

  -- Check for existing assignment
  SELECT * INTO v_assignment
  FROM experiment_assignments
  WHERE user_id = p_user_id
    AND experiment_key = p_experiment_key;

  IF v_assignment IS NOT NULL THEN
    RETURN jsonb_build_object(
      'success', true,
      'experimentKey', p_experiment_key,
      'variant', v_assignment.variant_id,
      'assignedAt', v_assignment.assigned_at,
      'isNewAssignment', false
    );
  END IF;

  -- Check sampling (not all users may be in experiment)
  v_user_hash := abs(hashtext(p_user_id::text || 'sample')) % 100;
  IF v_user_hash >= v_experiment.sample_percentage THEN
    RETURN jsonb_build_object(
      'success', true,
      'experimentKey', p_experiment_key,
      'variant', NULL,
      'reason', 'not_sampled'
    );
  END IF;

  -- Assign variant based on hash
  v_user_hash := abs(hashtext(p_user_id::text || p_experiment_key)) % 100;

  FOR v_variant IN SELECT * FROM jsonb_array_elements(v_experiment.variants)
  LOOP
    v_cumulative_weight := v_cumulative_weight + (v_variant->>'weight')::integer;
    IF v_user_hash < v_cumulative_weight THEN
      v_variant_id := v_variant->>'id';
      EXIT;
    END IF;
  END LOOP;

  -- Fallback to control if no variant matched
  IF v_variant_id IS NULL THEN
    v_variant_id := 'control';
  END IF;

  -- Persist assignment
  INSERT INTO experiment_assignments (user_id, experiment_key, variant_id)
  VALUES (p_user_id, p_experiment_key, v_variant_id)
  ON CONFLICT (user_id, experiment_key) DO NOTHING;

  RETURN jsonb_build_object(
    'success', true,
    'experimentKey', p_experiment_key,
    'variant', v_variant_id,
    'assignedAt', NOW(),
    'isNewAssignment', true
  );
END;
$$;


--
-- Name: FUNCTION get_experiment_variant(p_user_id uuid, p_experiment_key text); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.get_experiment_variant(p_user_id uuid, p_experiment_key text) IS 'Gets or assigns experiment variant for a user';


--
-- Name: get_feed_cache_stats(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_feed_cache_stats() RETURNS jsonb
    LANGUAGE plpgsql STABLE SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
DECLARE
  v_stats record;
BEGIN
  SELECT
    COUNT(*) AS total_cells,
    COUNT(*) FILTER (WHERE expires_at > NOW()) AS active_cells,
    COUNT(*) FILTER (WHERE expires_at <= NOW()) AS expired_cells,
    SUM(access_count) AS total_accesses,
    AVG(access_count)::numeric(10,2) AS avg_accesses_per_cell,
    AVG(computation_time_ms)::numeric(10,2) AS avg_computation_ms,
    MAX(access_count) AS max_accesses,
    SUM(item_count) AS total_cached_items
  INTO v_stats
  FROM precomputed_feed_cells;

  RETURN jsonb_build_object(
    'totalCells', COALESCE(v_stats.total_cells, 0),
    'activeCells', COALESCE(v_stats.active_cells, 0),
    'expiredCells', COALESCE(v_stats.expired_cells, 0),
    'totalAccesses', COALESCE(v_stats.total_accesses, 0),
    'avgAccessesPerCell', COALESCE(v_stats.avg_accesses_per_cell, 0),
    'avgComputationMs', COALESCE(v_stats.avg_computation_ms, 0),
    'maxAccesses', COALESCE(v_stats.max_accesses, 0),
    'totalCachedItems', COALESCE(v_stats.total_cached_items, 0),
    'timestamp', NOW()
  );
END;
$$;


--
-- Name: FUNCTION get_feed_cache_stats(); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.get_feed_cache_stats() IS 'Returns feed cache statistics for monitoring';


--
-- Name: get_feed_initial_data(double precision, double precision, double precision, integer, integer, integer, text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_feed_initial_data(p_latitude double precision, p_longitude double precision, p_radius_km double precision DEFAULT 25, p_feed_limit integer DEFAULT 50, p_trending_limit integer DEFAULT 10, p_category_id integer DEFAULT NULL::integer, p_post_type text DEFAULT NULL::text) RETURNS jsonb
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
DECLARE
    v_search_radius_m DOUBLE PRECISION;
    v_trending_radius_m DOUBLE PRECISION;
    v_result JSONB;
BEGIN
    v_search_radius_m := p_radius_km * 1000;
    v_trending_radius_m := p_radius_km * 1000 * 2; -- Wider radius for trending
    
    WITH 
    -- Categories (static, no location filter)
    active_categories AS (
        SELECT id, name, description, icon_url, color, sort_order
        FROM categories
        WHERE is_active = TRUE
        ORDER BY sort_order ASC
    ),
    -- Feed items (location-filtered)
    feed_posts AS (
        SELECT 
            p.*,
            ROUND((extensions.ST_Distance(
                p.location,
                extensions.ST_SetSRID(extensions.ST_MakePoint(p_longitude, p_latitude), 4326)::extensions.geography
            ) / 1000)::NUMERIC, 2) AS distance_km,
            EXTRACT(EPOCH FROM (NOW() - p.created_at)) / 3600 AS age_hours
        FROM posts p
        WHERE 
            extensions.ST_DWithin(
                p.location,
                extensions.ST_SetSRID(extensions.ST_MakePoint(p_longitude, p_latitude), 4326)::extensions.geography,
                v_search_radius_m
            )
            AND p.is_arranged = FALSE
            AND p.is_active = TRUE
            AND p.location IS NOT NULL
            AND (p_category_id IS NULL OR p.category_id = p_category_id)
            AND (p_post_type IS NULL OR p.post_type = p_post_type)
        ORDER BY p.created_at DESC
        LIMIT p_feed_limit
    ),
    -- Trending items (wider radius, engagement-sorted)
    trending_posts AS (
        SELECT 
            p.*,
            COALESCE(p.post_views, 0) + COALESCE(p.post_like_counter, 0) * 2 AS engagement_score,
            ROUND((extensions.ST_Distance(
                p.location,
                extensions.ST_SetSRID(extensions.ST_MakePoint(p_longitude, p_latitude), 4326)::extensions.geography
            ) / 1000)::NUMERIC, 2) AS distance_km,
            EXTRACT(EPOCH FROM (NOW() - p.created_at)) / 3600 AS age_hours
        FROM posts p
        WHERE 
            extensions.ST_DWithin(
                p.location,
                extensions.ST_SetSRID(extensions.ST_MakePoint(p_longitude, p_latitude), 4326)::extensions.geography,
                v_trending_radius_m
            )
            AND p.is_arranged = FALSE
            AND p.is_active = TRUE
            AND p.location IS NOT NULL
        ORDER BY (COALESCE(p.post_views, 0) + COALESCE(p.post_like_counter, 0) * 2) DESC, p.created_at DESC
        LIMIT p_trending_limit
    ),
    -- Feed stats
    feed_stats AS (
        SELECT
            COUNT(*) AS total_count,
            COUNT(*) FILTER (WHERE post_type = 'food') AS food_count,
            COUNT(*) FILTER (WHERE post_type = 'fridge') AS fridge_count,
            COUNT(*) FILTER (WHERE age_hours > 48) AS urgent_count
        FROM feed_posts
    )
    SELECT jsonb_build_object(
        'success', true,
        'categories', COALESCE(
            (SELECT jsonb_agg(
                jsonb_build_object(
                    'id', c.id,
                    'name', c.name,
                    'description', c.description,
                    'iconUrl', c.icon_url,
                    'color', c.color,
                    'sortOrder', c.sort_order
                ) ORDER BY c.sort_order
            ) FROM active_categories c),
            '[]'::jsonb
        ),
        'feedItems', COALESCE(
            (SELECT jsonb_agg(
                jsonb_build_object(
                    'id', fp.id,
                    'postName', fp.post_name,
                    'postType', fp.post_type,
                    'postDescription', fp.post_description,
                    'postAddress', fp.post_address,
                    'postStrippedAddress', fp.post_stripped_address,
                    'images', fp.images,
                    'distanceKm', fp.distance_km,
                    'ageHours', ROUND(fp.age_hours::NUMERIC, 1),
                    'postViews', COALESCE(fp.post_views, 0),
                    'postLikeCounter', COALESCE(fp.post_like_counter, 0),
                    'profileId', fp.profile_id,
                    'createdAt', fp.created_at,
                    'categoryId', fp.category_id,
                    'pickupTime', fp.pickup_time,
                    'availableHours', fp.available_hours
                ) ORDER BY fp.created_at DESC
            ) FROM feed_posts fp),
            '[]'::jsonb
        ),
        'trendingItems', COALESCE(
            (SELECT jsonb_agg(
                jsonb_build_object(
                    'id', tp.id,
                    'postName', tp.post_name,
                    'postType', tp.post_type,
                    'postDescription', tp.post_description,
                    'postAddress', tp.post_address,
                    'postStrippedAddress', tp.post_stripped_address,
                    'images', tp.images,
                    'engagementScore', tp.engagement_score,
                    'distanceKm', tp.distance_km,
                    'ageHours', ROUND(tp.age_hours::NUMERIC, 1),
                    'postViews', COALESCE(tp.post_views, 0),
                    'postLikeCounter', COALESCE(tp.post_like_counter, 0),
                    'profileId', tp.profile_id,
                    'createdAt', tp.created_at,
                    'categoryId', tp.category_id,
                    'pickupTime', tp.pickup_time
                ) ORDER BY tp.engagement_score DESC
            ) FROM trending_posts tp),
            '[]'::jsonb
        ),
        'stats', (SELECT row_to_json(s)::jsonb FROM feed_stats s),
        'metadata', jsonb_build_object(
            'searchRadiusKm', p_radius_km,
            'trendingRadiusKm', p_radius_km * 2,
            'feedLimit', p_feed_limit,
            'trendingLimit', p_trending_limit,
            'calculatedAt', NOW()
        )
    ) INTO v_result;
    
    RETURN v_result;
END;
$$;


--
-- Name: get_feed_initial_data(double precision, double precision, double precision, integer, integer, text, bigint); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_feed_initial_data(p_latitude double precision, p_longitude double precision, p_radius_km double precision DEFAULT 10, p_feed_limit integer DEFAULT 20, p_trending_limit integer DEFAULT 5, p_post_type text DEFAULT NULL::text, p_category_id bigint DEFAULT NULL::bigint) RETURNS jsonb
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public', 'pg_temp'
    AS $$
DECLARE
    v_search_radius_m DOUBLE PRECISION;
    v_trending_radius_m DOUBLE PRECISION;
    v_result JSONB;
BEGIN
    v_search_radius_m := p_radius_km * 1000;
    v_trending_radius_m := p_radius_km * 1000 * 2; -- Wider radius for trending
    
    WITH 
    -- Categories (static, no location filter)
    active_categories AS (
        SELECT id, name, description, icon_url, color, sort_order
        FROM categories
        WHERE is_active = TRUE
        ORDER BY sort_order ASC
    ),
    -- Feed items (location-filtered)
    feed_posts AS (
        SELECT 
            p.*,
            ROUND((extensions.ST_Distance(
                p.location,
                extensions.ST_SetSRID(extensions.ST_MakePoint(p_longitude, p_latitude), 4326)::extensions.geography
            ) / 1000)::NUMERIC, 2) AS distance_km,
            EXTRACT(EPOCH FROM (NOW() - p.created_at)) / 3600 AS age_hours
        FROM posts p
        WHERE 
            extensions.ST_DWithin(
                p.location,
                extensions.ST_SetSRID(extensions.ST_MakePoint(p_longitude, p_latitude), 4326)::extensions.geography,
                v_search_radius_m
            )
            AND p.is_arranged = FALSE
            AND p.is_active = TRUE
            AND p.location IS NOT NULL
            AND (p_category_id IS NULL OR p.category_id = p_category_id)
            AND (p_post_type IS NULL OR p.post_type = p_post_type)
        ORDER BY p.created_at DESC
        LIMIT p_feed_limit
    ),
    -- Trending items (wider radius, engagement-sorted)
    trending_posts AS (
        SELECT 
            p.*,
            COALESCE(p.post_views, 0) + COALESCE(p.post_like_counter, 0) * 2 AS engagement_score,
            ROUND((extensions.ST_Distance(
                p.location,
                extensions.ST_SetSRID(extensions.ST_MakePoint(p_longitude, p_latitude), 4326)::extensions.geography
            ) / 1000)::NUMERIC, 2) AS distance_km,
            EXTRACT(EPOCH FROM (NOW() - p.created_at)) / 3600 AS age_hours
        FROM posts p
        WHERE 
            extensions.ST_DWithin(
                p.location,
                extensions.ST_SetSRID(extensions.ST_MakePoint(p_longitude, p_latitude), 4326)::extensions.geography,
                v_trending_radius_m
            )
            AND p.is_arranged = FALSE
            AND p.is_active = TRUE
            AND p.location IS NOT NULL
        ORDER BY (COALESCE(p.post_views, 0) + COALESCE(p.post_like_counter, 0) * 2) DESC, p.created_at DESC
        LIMIT p_trending_limit
    ),
    -- Feed stats
    feed_stats AS (
        SELECT
            COUNT(*) AS total_count,
            COUNT(*) FILTER (WHERE post_type = 'food') AS food_count,
            COUNT(*) FILTER (WHERE post_type = 'fridge') AS fridge_count,
            COUNT(*) FILTER (WHERE age_hours > 48) AS urgent_count
        FROM feed_posts
    )
    SELECT jsonb_build_object(
        'success', true,
        'categories', COALESCE(
            (SELECT jsonb_agg(
                jsonb_build_object(
                    'id', c.id,
                    'name', c.name,
                    'description', c.description,
                    'iconUrl', c.icon_url,
                    'color', c.color,
                    'sortOrder', c.sort_order
                ) ORDER BY c.sort_order
            ) FROM active_categories c),
            '[]'::jsonb
        ),
        'feedItems', COALESCE(
            (SELECT jsonb_agg(
                jsonb_build_object(
                    'id', fp.id,
                    'postName', fp.post_name,
                    'postType', fp.post_type,
                    'postDescription', fp.post_description,
                    'postAddress', fp.post_address,
                    'images', fp.images,
                    'distanceKm', fp.distance_km,
                    'ageHours', ROUND(fp.age_hours::NUMERIC, 1),
                    'postViews', COALESCE(fp.post_views, 0),
                    'postLikeCounter', COALESCE(fp.post_like_counter, 0),
                    'profileId', fp.profile_id,
                    'createdAt', fp.created_at,
                    'categoryId', fp.category_id,
                    'pickupTime', fp.pickup_time,
                    'availableHours', fp.available_hours
                ) ORDER BY fp.created_at DESC
            ) FROM feed_posts fp),
            '[]'::jsonb
        ),
        'trendingItems', COALESCE(
            (SELECT jsonb_agg(
                jsonb_build_object(
                    'id', tp.id,
                    'postName', tp.post_name,
                    'postType', tp.post_type,
                    'postDescription', tp.post_description,
                    'postAddress', tp.post_address,
                    'images', tp.images,
                    'engagementScore', tp.engagement_score,
                    'distanceKm', tp.distance_km,
                    'ageHours', ROUND(tp.age_hours::NUMERIC, 1),
                    'postViews', COALESCE(tp.post_views, 0),
                    'postLikeCounter', COALESCE(tp.post_like_counter, 0),
                    'profileId', tp.profile_id,
                    'createdAt', tp.created_at,
                    'categoryId', tp.category_id,
                    'pickupTime', tp.pickup_time
                ) ORDER BY tp.engagement_score DESC
            ) FROM trending_posts tp),
            '[]'::jsonb
        ),
        'stats', (SELECT row_to_json(s)::jsonb FROM feed_stats s),
        'metadata', jsonb_build_object(
            'searchRadiusKm', p_radius_km,
            'trendingRadiusKm', p_radius_km * 2,
            'feedLimit', p_feed_limit,
            'trendingLimit', p_trending_limit,
            'calculatedAt', NOW()
        )
    ) INTO v_result;
    
    RETURN v_result;
END;
$$;


--
-- Name: get_filtered_feed(double precision, double precision, double precision, bigint, text, text, text, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_filtered_feed(p_latitude double precision, p_longitude double precision, p_radius_km double precision DEFAULT 10, p_category_id bigint DEFAULT NULL::bigint, p_post_type text DEFAULT NULL::text, p_search_query text DEFAULT NULL::text, p_sort_by text DEFAULT 'nearest'::text, p_limit integer DEFAULT 50, p_offset integer DEFAULT 0) RETURNS jsonb
    LANGUAGE plpgsql STABLE SECURITY DEFINER
    SET search_path TO 'public', 'extensions'
    AS $$
DECLARE
  v_search_radius_m DOUBLE PRECISION;
  v_result JSONB;
BEGIN
  v_search_radius_m := p_radius_km * 1000;
  
  WITH filtered_posts AS (
    SELECT 
      p.*,
      -- Distance in km
      ROUND((extensions.ST_Distance(
        p.location,
        extensions.ST_SetSRID(extensions.ST_MakePoint(p_longitude, p_latitude), 4326)::extensions.geography
      ) / 1000)::NUMERIC, 2) AS distance_km,
      -- Age in hours
      EXTRACT(EPOCH FROM (NOW() - p.created_at)) / 3600 AS age_hours
    FROM posts p
    WHERE 
      -- Within search radius
      extensions.ST_DWithin(
        p.location,
        extensions.ST_SetSRID(extensions.ST_MakePoint(p_longitude, p_latitude), 4326)::extensions.geography,
        v_search_radius_m
      )
      -- Not arranged/claimed
      AND p.is_arranged = FALSE
      -- Active posts only
      AND p.is_active = TRUE
      -- Has location
      AND p.location IS NOT NULL
      -- Optional category filter
      AND (p_category_id IS NULL OR p.category_id = p_category_id)
      -- Optional post type filter
      AND (p_post_type IS NULL OR p.post_type = p_post_type)
      -- Optional text search (case-insensitive)
      AND (
        p_search_query IS NULL 
        OR p_search_query = ''
        OR p.post_name ILIKE '%' || p_search_query || '%'
        OR p.post_description ILIKE '%' || p_search_query || '%'
        OR p.post_address ILIKE '%' || p_search_query || '%'
      )
    ORDER BY
      CASE p_sort_by
        WHEN 'nearest' THEN extensions.ST_Distance(
          p.location,
          extensions.ST_SetSRID(extensions.ST_MakePoint(p_longitude, p_latitude), 4326)::extensions.geography
        )
        ELSE NULL
      END ASC NULLS LAST,
      CASE p_sort_by
        WHEN 'newest' THEN EXTRACT(EPOCH FROM p.created_at)
        ELSE NULL
      END DESC NULLS LAST,
      CASE p_sort_by
        WHEN 'expiringSoon' THEN EXTRACT(EPOCH FROM p.created_at)
        ELSE NULL  
      END ASC NULLS LAST,
      CASE p_sort_by
        WHEN 'mostViewed' THEN COALESCE(p.post_views, 0)
        ELSE NULL
      END DESC NULLS LAST,
      -- Default secondary sort: newest
      p.created_at DESC
    LIMIT p_limit
    OFFSET p_offset
  ),
  stats AS (
    SELECT
      COUNT(*) AS total_count,
      COUNT(*) FILTER (WHERE post_type = 'food') AS food_count,
      COUNT(*) FILTER (WHERE post_type = 'fridge') AS fridge_count,
      COUNT(*) FILTER (WHERE post_type = 'foodbank') AS foodbank_count,
      COUNT(*) FILTER (WHERE age_hours > 48) AS urgent_count,
      MIN(distance_km) AS min_distance,
      MAX(distance_km) AS max_distance
    FROM filtered_posts
  )
  SELECT jsonb_build_object(
    'success', true,
    'items', COALESCE(
      (SELECT jsonb_agg(
        jsonb_build_object(
          'id', fp.id,
          'postName', fp.post_name,
          'postType', fp.post_type,
          'postDescription', fp.post_description,
          'postAddress', fp.post_address,
          'images', fp.images,
          'distanceKm', fp.distance_km,
          'ageHours', ROUND(fp.age_hours::NUMERIC, 1),
          'postViews', COALESCE(fp.post_views, 0),
          'postLikeCounter', COALESCE(fp.post_like_counter, 0),
          'profileId', fp.profile_id,
          'createdAt', fp.created_at,
          'categoryId', fp.category_id,
          'pickupTime', fp.pickup_time,
          'availableHours', fp.available_hours
        )
      ) FROM filtered_posts fp),
      '[]'::jsonb
    ),
    'stats', (SELECT row_to_json(s)::jsonb FROM stats s),
    'pagination', jsonb_build_object(
      'limit', p_limit,
      'offset', p_offset,
      'hasMore', (SELECT COUNT(*) FROM filtered_posts) >= p_limit
    ),
    'filters', jsonb_build_object(
      'categoryId', p_category_id,
      'postType', p_post_type,
      'searchQuery', p_search_query,
      'sortBy', p_sort_by,
      'radiusKm', p_radius_km
    )
  ) INTO v_result;
  
  RETURN v_result;
END;
$$;


--
-- Name: FUNCTION get_filtered_feed(p_latitude double precision, p_longitude double precision, p_radius_km double precision, p_category_id bigint, p_post_type text, p_search_query text, p_sort_by text, p_limit integer, p_offset integer); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.get_filtered_feed(p_latitude double precision, p_longitude double precision, p_radius_km double precision, p_category_id bigint, p_post_type text, p_search_query text, p_sort_by text, p_limit integer, p_offset integer) IS 'Returns filtered and sorted food listings. Supports category, type, text search filters and multiple sort options (nearest, newest, expiringSoon, mostViewed).';


--
-- Name: get_forum_feed_data(uuid, integer, text, text, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_forum_feed_data(p_user_id uuid DEFAULT NULL::uuid, p_category_id integer DEFAULT NULL::integer, p_post_type text DEFAULT NULL::text, p_sort_by text DEFAULT 'recent'::text, p_page_limit integer DEFAULT 20, p_page_offset integer DEFAULT 0) RETURNS jsonb
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
DECLARE
  v_result JSONB;
  v_posts JSONB;
  v_categories JSONB;
  v_featured JSONB;
  v_user_stats JSONB;
BEGIN
  -- Get forum posts with author info and engagement
  WITH post_data AS (
    SELECT 
      f.id,
      f.forum_post_name,
      f.forum_post_description,
      f.forum_post_image,
      f.forum_comments_counter,
      f.forum_likes_counter,
      f.views_count,
      f.post_type,
      f.is_pinned,
      f.is_locked,
      f.is_featured,
      f.slug,
      f.category_id,
      f.reactions_count,
      f.forum_post_created_at,
      f.last_activity_at,
      p.id AS author_id,
      COALESCE(p.nickname, p.first_name, 'User') AS author_name,
      p.avatar_url AS author_avatar,
      p.is_verified AS author_verified,
      fc.name AS category_name,
      fc.color AS category_color,
      CASE WHEN p_user_id IS NOT NULL THEN
        EXISTS(SELECT 1 FROM forum_reactions fr WHERE fr.forum_id = f.id AND fr.profile_id = p_user_id)
      ELSE FALSE END AS user_has_reacted,
      CASE WHEN p_user_id IS NOT NULL THEN
        EXISTS(SELECT 1 FROM forum_bookmarks fb WHERE fb.forum_id = f.id AND fb.profile_id = p_user_id)
      ELSE FALSE END AS user_has_bookmarked
    FROM forum f
    JOIN profiles p ON f.profile_id = p.id
    LEFT JOIN forum_categories fc ON f.category_id = fc.id
    WHERE f.forum_published = TRUE
      AND (p_category_id IS NULL OR f.category_id = p_category_id)
      AND (p_post_type IS NULL OR f.post_type = p_post_type)
    ORDER BY 
      f.is_pinned DESC,
      CASE p_sort_by
        WHEN 'recent' THEN f.forum_post_created_at
        WHEN 'activity' THEN f.last_activity_at
        WHEN 'popular' THEN f.forum_post_created_at
      END DESC,
      CASE WHEN p_sort_by = 'popular' THEN COALESCE(f.hot_score, 0) ELSE 0 END DESC
    LIMIT p_page_limit
    OFFSET p_page_offset
  )
  SELECT COALESCE(jsonb_agg(
    jsonb_build_object(
      'id', id,
      'title', forum_post_name,
      'description', forum_post_description,
      'image', forum_post_image,
      'commentsCount', COALESCE(forum_comments_counter, 0),
      'likesCount', forum_likes_counter,
      'viewsCount', COALESCE(views_count, 0),
      'postType', post_type,
      'isPinned', COALESCE(is_pinned, FALSE),
      'isLocked', COALESCE(is_locked, FALSE),
      'isFeatured', COALESCE(is_featured, FALSE),
      'slug', slug,
      'categoryId', category_id,
      'categoryName', category_name,
      'categoryColor', category_color,
      'reactions', COALESCE(reactions_count, '{}'::jsonb),
      'createdAt', forum_post_created_at,
      'lastActivityAt', last_activity_at,
      'author', jsonb_build_object(
        'id', author_id,
        'name', author_name,
        'avatar', author_avatar,
        'isVerified', COALESCE(author_verified, FALSE)
      ),
      'userInteraction', jsonb_build_object(
        'hasReacted', user_has_reacted,
        'hasBookmarked', user_has_bookmarked
      )
    )
  ), '[]'::jsonb) INTO v_posts FROM post_data;

  -- Get categories with post counts (using icon_name instead of icon)
  SELECT COALESCE(jsonb_agg(
    jsonb_build_object(
      'id', fc.id,
      'name', fc.name,
      'description', fc.description,
      'color', fc.color,
      'icon', fc.icon_name,
      'slug', fc.slug,
      'postCount', COALESCE(fc.posts_count, 0)
    ) ORDER BY fc.sort_order
  ), '[]'::jsonb) INTO v_categories
  FROM forum_categories fc
  WHERE fc.is_active = TRUE;

  -- Get featured posts
  SELECT COALESCE(jsonb_agg(
    jsonb_build_object(
      'id', f.id,
      'title', f.forum_post_name,
      'image', f.forum_post_image,
      'slug', f.slug,
      'authorName', COALESCE(p.nickname, p.first_name, 'User'),
      'featuredAt', f.featured_at
    ) ORDER BY f.featured_at DESC
  ), '[]'::jsonb) INTO v_featured
  FROM forum f
  JOIN profiles p ON f.profile_id = p.id
  WHERE f.is_featured = TRUE 
    AND f.forum_published = TRUE
    AND (f.featured_until IS NULL OR f.featured_until > NOW())
  LIMIT 5;

  -- Get user stats if logged in
  IF p_user_id IS NOT NULL THEN
    SELECT jsonb_build_object(
      'postsCount', (SELECT COUNT(*) FROM forum WHERE profile_id = p_user_id),
      'commentsCount', (SELECT COUNT(*) FROM comments WHERE user_id = p_user_id),
      'bookmarksCount', (SELECT COUNT(*) FROM forum_bookmarks WHERE profile_id = p_user_id),
      'unreadNotifications', (SELECT COUNT(*) FROM user_notifications WHERE user_id = p_user_id AND is_read = FALSE AND notification_type LIKE 'forum%')
    ) INTO v_user_stats;
  ELSE
    v_user_stats := '{}'::jsonb;
  END IF;

  v_result := jsonb_build_object(
    'success', TRUE,
    'posts', v_posts,
    'categories', v_categories,
    'featured', v_featured,
    'userStats', v_user_stats,
    'pagination', jsonb_build_object(
      'limit', p_page_limit,
      'offset', p_page_offset,
      'hasMore', jsonb_array_length(v_posts) = p_page_limit
    )
  );

  RETURN v_result;
END;
$$;


--
-- Name: get_forum_post_detail(bigint, uuid, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_forum_post_detail(p_post_id bigint, p_user_id uuid DEFAULT NULL::uuid, p_comments_limit integer DEFAULT 50) RETURNS jsonb
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
DECLARE
  v_result JSONB;
  v_post JSONB;
  v_comments JSONB;
  v_related JSONB;
BEGIN
  -- Increment view count
  UPDATE forum SET views_count = COALESCE(views_count, 0) + 1 WHERE id = p_post_id;

  -- Get post with full details
  SELECT jsonb_build_object(
    'id', f.id,
    'title', f.forum_post_name,
    'description', f.forum_post_description,
    'image', f.forum_post_image,
    'richContent', f.rich_content,
    'commentsCount', COALESCE(f.forum_comments_counter, 0),
    'likesCount', f.forum_likes_counter,
    'viewsCount', COALESCE(f.views_count, 0),
    'postType', f.post_type,
    'isPinned', COALESCE(f.is_pinned, FALSE),
    'isLocked', COALESCE(f.is_locked, FALSE),
    'isFeatured', COALESCE(f.is_featured, FALSE),
    'isEdited', COALESCE(f.is_edited, FALSE),
    'slug', f.slug,
    'categoryId', f.category_id,
    'reactions', COALESCE(f.reactions_count, '{}'::jsonb),
    'createdAt', f.forum_post_created_at,
    'updatedAt', f.forum_post_updated_at,
    'lastActivityAt', f.last_activity_at,
    'bestAnswerId', f.best_answer_id,
    'author', jsonb_build_object(
      'id', p.id,
      'name', COALESCE(p.nickname, p.first_name, 'User'),
      'avatar', p.avatar_url,
      'isVerified', COALESCE(p.is_verified, FALSE),
      'bio', p.bio,
      'postsCount', (SELECT COUNT(*) FROM forum WHERE profile_id = p.id)
    ),
    'category', CASE WHEN fc.id IS NOT NULL THEN jsonb_build_object(
      'id', fc.id,
      'name', fc.name,
      'color', fc.color
    ) ELSE NULL END,
    'userInteraction', CASE WHEN p_user_id IS NOT NULL THEN jsonb_build_object(
      'hasReacted', EXISTS(SELECT 1 FROM forum_reactions fr WHERE fr.forum_id = f.id AND fr.profile_id = p_user_id),
      'hasBookmarked', EXISTS(SELECT 1 FROM forum_bookmarks fb WHERE fb.forum_id = f.id AND fb.profile_id = p_user_id),
      'hasSubscribed', EXISTS(SELECT 1 FROM forum_subscriptions fs WHERE fs.forum_id = f.id AND fs.profile_id = p_user_id),
      'userReaction', (SELECT reaction_type_id FROM forum_reactions WHERE forum_id = f.id AND profile_id = p_user_id LIMIT 1),
      'isAuthor', f.profile_id = p_user_id
    ) ELSE NULL END
  ) INTO v_post
  FROM forum f
  JOIN profiles p ON f.profile_id = p.id
  LEFT JOIN forum_categories fc ON f.category_id = fc.id
  WHERE f.id = p_post_id AND f.forum_published = TRUE;

  IF v_post IS NULL THEN
    RETURN jsonb_build_object('success', FALSE, 'error', 'Post not found');
  END IF;

  -- Get comments with threading
  WITH RECURSIVE comment_tree AS (
    SELECT 
      c.id, c.comment, c.user_id, c.parent_id, c.depth,
      c.likes_count, c.replies_count, c.is_best_answer, c.is_pinned,
      c.reactions_count, c.comment_created_at, c.is_edited,
      COALESCE(p.nickname, p.first_name, 'User') AS author_name, 
      p.avatar_url AS author_avatar, 
      p.is_verified AS author_verified,
      0 AS tree_depth,
      ARRAY[c.id] AS path
    FROM comments c
    JOIN profiles p ON c.user_id = p.id
    WHERE c.forum_id = p_post_id AND c.parent_id IS NULL
    
    UNION ALL
    
    SELECT 
      c.id, c.comment, c.user_id, c.parent_id, c.depth,
      c.likes_count, c.replies_count, c.is_best_answer, c.is_pinned,
      c.reactions_count, c.comment_created_at, c.is_edited,
      COALESCE(p.nickname, p.first_name, 'User'), 
      p.avatar_url, 
      p.is_verified,
      ct.tree_depth + 1,
      ct.path || c.id
    FROM comments c
    JOIN profiles p ON c.user_id = p.id
    JOIN comment_tree ct ON c.parent_id = ct.id
    WHERE ct.tree_depth < 3
  )
  SELECT COALESCE(jsonb_agg(
    jsonb_build_object(
      'id', id,
      'content', comment,
      'authorId', user_id,
      'authorName', author_name,
      'authorAvatar', author_avatar,
      'authorVerified', COALESCE(author_verified, FALSE),
      'parentId', parent_id,
      'depth', COALESCE(depth, tree_depth),
      'likesCount', COALESCE(likes_count, 0),
      'repliesCount', COALESCE(replies_count, 0),
      'isBestAnswer', COALESCE(is_best_answer, FALSE),
      'isPinned', COALESCE(is_pinned, FALSE),
      'reactions', COALESCE(reactions_count, '{}'::jsonb),
      'createdAt', comment_created_at,
      'isEdited', COALESCE(is_edited, FALSE)
    ) ORDER BY is_pinned DESC, is_best_answer DESC, path
  ), '[]'::jsonb) INTO v_comments
  FROM comment_tree
  LIMIT p_comments_limit;

  -- Get related posts
  SELECT COALESCE(jsonb_agg(
    jsonb_build_object(
      'id', f.id,
      'title', f.forum_post_name,
      'image', f.forum_post_image,
      'commentsCount', COALESCE(f.forum_comments_counter, 0),
      'slug', f.slug
    )
  ), '[]'::jsonb) INTO v_related
  FROM forum f
  WHERE f.id != p_post_id
    AND f.forum_published = TRUE
    AND f.category_id = (SELECT category_id FROM forum WHERE id = p_post_id)
  ORDER BY f.hot_score DESC NULLS LAST
  LIMIT 5;

  v_result := jsonb_build_object(
    'success', TRUE,
    'post', v_post,
    'comments', v_comments,
    'relatedPosts', v_related
  );

  RETURN v_result;
END;
$$;


--
-- Name: get_forum_rate_limits_status(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_forum_rate_limits_status() RETURNS TABLE(action_type text, max_allowed integer, current_count integer, remaining integer, resets_in_seconds integer, description text)
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
DECLARE
  v_user_trust_level INTEGER;
BEGIN
  SELECT COALESCE(trust_level, 0) INTO v_user_trust_level
  FROM forum_user_stats
  WHERE profile_id = auth.uid();
  
  v_user_trust_level := COALESCE(v_user_trust_level, 0);
  
  RETURN QUERY
  SELECT 
    c.action_type,
    CEIL(c.max_actions * COALESCE((c.trust_level_multipliers->>v_user_trust_level::TEXT)::DECIMAL, 1))::INTEGER,
    COALESCE(
      (SELECT SUM(rl.action_count)::INTEGER
       FROM forum_rate_limits rl
       WHERE rl.profile_id = auth.uid()
         AND rl.action_type = c.action_type
         AND rl.created_at > now() - (c.window_seconds || ' seconds')::INTERVAL),
      0
    ),
    CEIL(c.max_actions * COALESCE((c.trust_level_multipliers->>v_user_trust_level::TEXT)::DECIMAL, 1))::INTEGER -
    COALESCE(
      (SELECT SUM(rl.action_count)::INTEGER
       FROM forum_rate_limits rl
       WHERE rl.profile_id = auth.uid()
         AND rl.action_type = c.action_type
         AND rl.created_at > now() - (c.window_seconds || ' seconds')::INTERVAL),
      0
    ),
    c.window_seconds,
    c.description
  FROM forum_rate_limit_config c
  WHERE c.is_active = TRUE
  ORDER BY c.action_type;
END;
$$;


--
-- Name: get_global_quota_status(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_global_quota_status() RETURNS TABLE(provider text, daily_sent integer, daily_limit integer, daily_remaining integer, daily_percent_used numeric, monthly_sent integer, monthly_limit integer, monthly_remaining integer, monthly_percent_used numeric)
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO ''
    AS $$
DECLARE
  v_today date := CURRENT_DATE;
  v_year_month text := to_char(CURRENT_DATE, 'YYYY-MM');
BEGIN
  RETURN QUERY
  WITH daily AS (
    SELECT 
      q.provider,
      COALESCE(SUM(q.emails_sent), 0)::integer as sent
    FROM public.email_provider_quota q
    WHERE q.date = v_today
    GROUP BY q.provider
  ),
  monthly AS (
    SELECT 
      m.provider,
      COALESCE(SUM(m.emails_sent), 0)::integer as sent
    FROM public.email_provider_monthly_quota m
    WHERE m.year_month = v_year_month
    GROUP BY m.provider
  ),
  providers AS (
    SELECT unnest(ARRAY['resend', 'brevo', 'aws_ses']) as prov
  ),
  limits AS (
    -- Updated limits: Resend 100/day, Brevo 300/day, AWS SES 200/day (sandbox)
    SELECT 'resend' as prov, 100 as daily_lim, 3000 as monthly_lim
    UNION ALL
    SELECT 'brevo', 300, 9000
    UNION ALL
    SELECT 'aws_ses', 200, 62000  -- AWS SES sandbox: 200/day
  )
  SELECT 
    p.prov as provider,
    COALESCE(d.sent, 0)::integer as daily_sent,
    l.daily_lim::integer as daily_limit,
    GREATEST(0, l.daily_lim - COALESCE(d.sent, 0))::integer as daily_remaining,
    CASE WHEN l.daily_lim > 0 
      THEN ROUND((COALESCE(d.sent, 0)::numeric / l.daily_lim::numeric) * 100, 1)
      ELSE 0 
    END as daily_percent_used,
    COALESCE(m.sent, 0)::integer as monthly_sent,
    l.monthly_lim::integer as monthly_limit,
    GREATEST(0, l.monthly_lim - COALESCE(m.sent, 0))::integer as monthly_remaining,
    CASE WHEN l.monthly_lim > 0 
      THEN ROUND((COALESCE(m.sent, 0)::numeric / l.monthly_lim::numeric) * 100, 1)
      ELSE 0 
    END as monthly_percent_used
  FROM providers p
  JOIN limits l ON l.prov = p.prov
  LEFT JOIN daily d ON d.provider = p.prov
  LEFT JOIN monthly m ON m.provider = p.prov;
END;
$$;


--
-- Name: get_healthiest_provider(text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_healthiest_provider(p_email_type text DEFAULT 'chat'::text) RETURNS TABLE(provider text, health_score integer, quota_remaining integer, recommendation_reason text)
    LANGUAGE plpgsql
    SET search_path TO ''
    AS $$
DECLARE
  v_today DATE := CURRENT_DATE;
BEGIN
  RETURN QUERY
  SELECT
    m.provider,
    m.health_score,
    COALESCE(q.daily_limit - q.emails_sent, 0) as quota_remaining,
    CASE
      WHEN m.health_score >= 90 THEN 'Excellent health and performance'
      WHEN m.health_score >= 70 THEN 'Good health with minor issues'
      WHEN m.health_score >= 50 THEN 'Degraded performance, use with caution'
      ELSE 'Poor health, avoid if possible'
    END as recommendation_reason
  FROM email_provider_health_metrics m
  LEFT JOIN email_provider_quota q ON q.provider = m.provider AND q.date = v_today
  WHERE 
    -- Has quota available
    COALESCE(q.daily_limit - q.emails_sent, 0) > 0
    -- Health score above minimum threshold
    AND m.health_score >= 30
  ORDER BY
    -- Primary: Health score
    m.health_score DESC,
    -- Secondary: Available quota
    (COALESCE(q.daily_limit - q.emails_sent, 0)) DESC,
    -- Tertiary: Lower latency
    m.average_latency_ms ASC
  LIMIT 1;
END;
$$;


--
-- Name: FUNCTION get_healthiest_provider(p_email_type text); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.get_healthiest_provider(p_email_type text) IS 'Returns the healthiest available provider for email routing';


--
-- Name: get_home_screen_data(uuid, double precision, double precision, double precision, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_home_screen_data(p_user_id uuid, p_lat double precision, p_lng double precision, p_radius_km double precision DEFAULT 10, p_feed_limit integer DEFAULT 20, p_trending_limit integer DEFAULT 5) RETURNS jsonb
    LANGUAGE plpgsql STABLE SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
DECLARE
  v_search_radius_m DOUBLE PRECISION;
  v_user_prefs JSONB;
  v_feed_items JSONB;
  v_trending_items JSONB;
  v_categories JSONB;
  v_counts JSONB;
  v_nearby_fridges JSONB;
BEGIN
  v_search_radius_m := p_radius_km * 1000;

  -- Get user preferences
  SELECT jsonb_build_object(
    'dietary_preferences', COALESCE(p.dietary_preferences, '[]'::jsonb),
    'notification_preferences', COALESCE(p.notification_preferences, '{}'::jsonb),
    'search_radius_km', COALESCE(p.search_radius_km, 10),
    'language', COALESCE(p.language, 'en')
  ) INTO v_user_prefs
  FROM profiles p
  WHERE p.id = p_user_id;

  -- Get unread counts
  SELECT jsonb_build_object(
    'notifications', (SELECT COUNT(*) FROM user_notifications WHERE recipient_id = p_user_id AND is_read = FALSE),
    'messages', (SELECT COUNT(*) FROM rooms r WHERE (r.sharer = p_user_id OR r.requester = p_user_id) 
                 AND r.last_message_sent_by IS NOT NULL AND r.last_message_sent_by != p_user_id
                 AND (r.last_message_seen_by IS NULL OR r.last_message_seen_by != p_user_id)),
    'pending_requests', (SELECT COUNT(*) FROM rooms r JOIN posts p ON p.id = r.post_id 
                         WHERE p.profile_id = p_user_id AND p.is_active = TRUE AND p.is_arranged = FALSE)
  ) INTO v_counts;

  -- Get active categories
  SELECT COALESCE(jsonb_agg(jsonb_build_object(
    'id', c.id,
    'name', c.name,
    'icon_url', c.icon_url,
    'color', c.color,
    'sort_order', c.sort_order
  ) ORDER BY c.sort_order), '[]'::jsonb)
  INTO v_categories
  FROM categories c
  WHERE c.is_active = TRUE;

  -- Get feed items with distance
  SELECT COALESCE(jsonb_agg(item ORDER BY item->>'distance_km' ASC NULLS LAST, item->>'created_at' DESC), '[]'::jsonb)
  INTO v_feed_items
  FROM (
    SELECT jsonb_build_object(
      'id', p.id,
      'post_name', p.post_name,
      'post_type', p.post_type,
      'post_description', LEFT(p.post_description, 200),
      'images', COALESCE(p.images[1:3], ARRAY[]::TEXT[]),
      'distance_km', ROUND((extensions.ST_Distance(
        p.location,
        extensions.ST_SetSRID(extensions.ST_MakePoint(p_lng, p_lat), 4326)::extensions.geography
      ) / 1000)::NUMERIC, 2),
      'pickup_address', p.post_address,
      'category_id', p.category_id,
      'profile_id', p.profile_id,
      'owner_name', pr.nickname,
      'owner_avatar', pr.avatar_url,
      'created_at', p.created_at,
      'post_views', COALESCE(p.post_views, 0),
      'post_likes', COALESCE(p.post_like_counter, 0)
    ) AS item
    FROM posts p
    LEFT JOIN profiles pr ON pr.id = p.profile_id
    WHERE p.is_active = TRUE
      AND p.is_arranged = FALSE
      AND p.location IS NOT NULL
      AND extensions.ST_DWithin(
        p.location,
        extensions.ST_SetSRID(extensions.ST_MakePoint(p_lng, p_lat), 4326)::extensions.geography,
        v_search_radius_m
      )
    ORDER BY extensions.ST_Distance(
      p.location,
      extensions.ST_SetSRID(extensions.ST_MakePoint(p_lng, p_lat), 4326)::extensions.geography
    )
    LIMIT p_feed_limit
  ) sub;

  -- Get trending items (by engagement)
  SELECT COALESCE(jsonb_agg(item ORDER BY item->>'engagement_score' DESC), '[]'::jsonb)
  INTO v_trending_items
  FROM (
    SELECT jsonb_build_object(
      'id', p.id,
      'post_name', p.post_name,
      'post_type', p.post_type,
      'images', COALESCE(p.images[1:1], ARRAY[]::TEXT[]),
      'engagement_score', COALESCE(p.post_views, 0) + COALESCE(p.post_like_counter, 0) * 3,
      'profile_id', p.profile_id,
      'owner_name', pr.nickname
    ) AS item
    FROM posts p
    LEFT JOIN profiles pr ON pr.id = p.profile_id
    WHERE p.is_active = TRUE
      AND p.is_arranged = FALSE
      AND p.created_at > NOW() - INTERVAL '7 days'
    ORDER BY (COALESCE(p.post_views, 0) + COALESCE(p.post_like_counter, 0) * 3) DESC
    LIMIT p_trending_limit
  ) sub;

  -- Get nearby community fridges
  SELECT COALESCE(jsonb_agg(jsonb_build_object(
    'id', p.id,
    'name', p.post_name,
    'address', p.post_address,
    'distance_km', ROUND((extensions.ST_Distance(
      p.location,
      extensions.ST_SetSRID(extensions.ST_MakePoint(p_lng, p_lat), 4326)::extensions.geography
    ) / 1000)::NUMERIC, 2)
  ) ORDER BY extensions.ST_Distance(
    p.location,
    extensions.ST_SetSRID(extensions.ST_MakePoint(p_lng, p_lat), 4326)::extensions.geography
  )), '[]'::jsonb)
  INTO v_nearby_fridges
  FROM posts p
  WHERE p.post_type = 'fridge'
    AND p.is_active = TRUE
    AND p.location IS NOT NULL
    AND extensions.ST_DWithin(
      p.location,
      extensions.ST_SetSRID(extensions.ST_MakePoint(p_lng, p_lat), 4326)::extensions.geography,
      v_search_radius_m * 2
    )
  LIMIT 5;

  RETURN jsonb_build_object(
    'success', TRUE,
    'user_preferences', COALESCE(v_user_prefs, '{}'::jsonb),
    'counts', v_counts,
    'categories', v_categories,
    'feed_items', v_feed_items,
    'trending_items', v_trending_items,
    'nearby_fridges', v_nearby_fridges,
    'meta', jsonb_build_object(
      'location', jsonb_build_object('lat', p_lat, 'lng', p_lng),
      'radius_km', p_radius_km,
      'timestamp', NOW(),
      'cache_ttl', 60
    )
  );
END;
$$;


--
-- Name: FUNCTION get_home_screen_data(p_user_id uuid, p_lat double precision, p_lng double precision, p_radius_km double precision, p_feed_limit integer, p_trending_limit integer); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.get_home_screen_data(p_user_id uuid, p_lat double precision, p_lng double precision, p_radius_km double precision, p_feed_limit integer, p_trending_limit integer) IS 'Returns all data needed for home screen in a single call';


--
-- Name: get_large_uncompressed_images(text, bigint, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_large_uncompressed_images(target_bucket text DEFAULT 'posts'::text, size_threshold_bytes bigint DEFAULT 100000, max_results integer DEFAULT 10) RETURNS TABLE(bucket text, path text, size bigint)
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO ''
    AS $$
BEGIN
  RETURN QUERY
  SELECT 
    o.bucket_id::TEXT as bucket,
    o.name::TEXT as path,
    (o.metadata->>'size')::BIGINT as size
  FROM storage.objects o
  WHERE o.bucket_id = target_bucket
    AND (o.metadata->>'size')::BIGINT > size_threshold_bytes
    AND (
      o.metadata->>'mimetype' LIKE 'image/%'
      OR o.name LIKE '%.jpg'
      OR o.name LIKE '%.jpeg'
      OR o.name LIKE '%.png'
      OR o.name LIKE '%.webp'
      OR o.name LIKE '%.gif'
    )
    AND NOT EXISTS (
      SELECT 1 FROM public.image_compressions ic 
      WHERE ic.bucket = o.bucket_id 
        AND ic.original_path = o.name
        AND ic.status = 'completed'
    )
  ORDER BY (o.metadata->>'size')::BIGINT DESC
  LIMIT max_results;
END;
$$;


--
-- Name: get_large_uncompressed_images_all_buckets(bigint, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_large_uncompressed_images_all_buckets(size_threshold_bytes bigint DEFAULT 100000, max_results integer DEFAULT 10) RETURNS TABLE(bucket text, path text, size bigint)
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO ''
    AS $$
BEGIN
  RETURN QUERY
  SELECT 
    o.bucket_id::TEXT as bucket,
    o.name::TEXT as path,
    (o.metadata->>'size')::BIGINT as size
  FROM storage.objects o
  WHERE o.bucket_id IN ('posts', 'profiles', 'flags', 'forum', 'challenges', 'rooms', 'assets')
    AND (o.metadata->>'size')::BIGINT > size_threshold_bytes
    AND (
      o.metadata->>'mimetype' LIKE 'image/%'
      OR o.name LIKE '%.jpg'
      OR o.name LIKE '%.jpeg'
      OR o.name LIKE '%.png'
      OR o.name LIKE '%.webp'
      OR o.name LIKE '%.gif'
    )
    AND NOT EXISTS (
      SELECT 1 FROM public.image_compressions ic 
      WHERE ic.bucket = o.bucket_id 
        AND ic.original_path = o.name
        AND ic.status = 'completed'
    )
  ORDER BY (o.metadata->>'size')::BIGINT DESC
  LIMIT max_results;
END;
$$;


--
-- Name: get_large_uncompressed_images_multi(text[], bigint, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_large_uncompressed_images_multi(p_buckets text[] DEFAULT ARRAY['posts'::text, 'profiles'::text, 'forum'::text], p_min_size bigint DEFAULT 100000, p_limit integer DEFAULT 3) RETURNS TABLE(name text, bucket_id text, size bigint)
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO ''
    AS $$
BEGIN
  RETURN QUERY
  SELECT 
    so.name::text,
    so.bucket_id::text,
    (so.metadata->>'size')::bigint as size
  FROM storage.objects so
  WHERE so.bucket_id = ANY(p_buckets)
    AND (so.metadata->>'size')::BIGINT > p_min_size
    AND so.metadata->>'mimetype' LIKE 'image/%'
    AND NOT EXISTS (
      SELECT 1 FROM public.image_compressions ic 
      WHERE ic.bucket = so.bucket_id 
        AND ic.original_path = so.name
        AND ic.status IN ('completed', 'processing', 'failed', 'skipped')
    )
  ORDER BY (so.metadata->>'size')::bigint DESC
  LIMIT p_limit;
END;
$$;


--
-- Name: get_latitude(extensions.geography); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_latitude(loc extensions.geography) RETURNS double precision
    LANGUAGE sql IMMUTABLE
    SET search_path TO ''
    AS $$
  SELECT ST_Y(loc::geometry);
$$;


--
-- Name: get_latitude(text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_latitude(address text) RETURNS numeric
    LANGUAGE plpgsql STABLE
    SET search_path TO ''
    AS $$
DECLARE
  lat numeric;
BEGIN
  SELECT latitude INTO lat FROM public.geocode_address(address);
  RETURN lat;
END;
$$;


--
-- Name: get_leaderboard_user_profile(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_leaderboard_user_profile(user_id uuid) RETURNS TABLE(profile_id uuid, nickname text, first_name text, avatar_url text, joined_at timestamp with time zone, completed_count bigint, active_count bigint, total_xp numeric, completion_rate integer, user_rank integer, recent_challenges jsonb)
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
DECLARE
  v_completed_count BIGINT;
  v_active_count BIGINT;
  v_total_xp NUMERIC;
  v_user_rank INTEGER;
  v_recent JSONB;
BEGIN
  -- Get user stats
  SELECT 
    COUNT(*) FILTER (WHERE cp.is_completed = true),
    COUNT(*) FILTER (WHERE cp.is_completed = false),
    COALESCE(SUM(CASE WHEN cp.is_completed THEN c.challenge_score ELSE 0 END), 0)
  INTO v_completed_count, v_active_count, v_total_xp
  FROM challenge_participants cp
  JOIN challenges c ON c.id = cp.challenge_id
  WHERE cp.profile_id = user_id;
  
  -- Calculate rank
  WITH ranked AS (
    SELECT 
      cp.profile_id,
      ROW_NUMBER() OVER (
        ORDER BY 
          COUNT(*) FILTER (WHERE cp.is_completed = true) DESC,
          COALESCE(SUM(CASE WHEN cp.is_completed THEN c.challenge_score ELSE 0 END), 0) DESC
      ) as rank
    FROM challenge_participants cp
    JOIN challenges c ON c.id = cp.challenge_id
    GROUP BY cp.profile_id
    HAVING COUNT(*) FILTER (WHERE cp.is_completed = true) > 0
  )
  SELECT rank INTO v_user_rank FROM ranked WHERE ranked.profile_id = user_id;
  
  -- Get recent completed challenges (limit 5)
  SELECT COALESCE(jsonb_agg(row_to_json(sub)), '[]'::jsonb)
  INTO v_recent
  FROM (
    SELECT 
      c.id,
      c.challenge_title as title,
      c.challenge_difficulty as difficulty,
      c.challenge_score as xp,
      cp.completed_at as "completedAt"
    FROM challenge_participants cp
    JOIN challenges c ON c.id = cp.challenge_id
    WHERE cp.profile_id = user_id AND cp.is_completed = true
    ORDER BY cp.completed_at DESC
    LIMIT 5
  ) sub;
  
  -- Return the profile with stats
  RETURN QUERY
  SELECT 
    p.id as profile_id,
    p.nickname,
    p.first_name,
    p.avatar_url,
    p.created_time as joined_at,
    COALESCE(v_completed_count, 0),
    COALESCE(v_active_count, 0),
    COALESCE(v_total_xp, 0),
    CASE 
      WHEN COALESCE(v_completed_count, 0) + COALESCE(v_active_count, 0) > 0 
      THEN ROUND((COALESCE(v_completed_count, 0)::NUMERIC / (COALESCE(v_completed_count, 0) + COALESCE(v_active_count, 0))) * 100)::INTEGER
      ELSE 0 
    END as completion_rate,
    COALESCE(v_user_rank, 0),
    COALESCE(v_recent, '[]'::jsonb)
  FROM profiles p
  WHERE p.id = user_id;
END;
$$;


--
-- Name: FUNCTION get_leaderboard_user_profile(user_id uuid); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.get_leaderboard_user_profile(user_id uuid) IS 'Returns detailed profile stats for leaderboard user modal';


--
-- Name: get_listing_detail_data(integer, uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_listing_detail_data(p_listing_id integer, p_viewer_id uuid DEFAULT NULL::uuid) RETURNS jsonb
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
DECLARE
  v_listing JSONB;
  v_owner JSONB;
  v_owner_stats JSONB;
  v_similar_items JSONB;
  v_viewer_interaction JSONB;
BEGIN
  -- Get listing details
  SELECT jsonb_build_object(
    'id', p.id,
    'post_name', p.post_name,
    'post_description', p.post_description,
    'post_type', p.post_type,
    'post_address', p.post_address,
    'post_stripped_address', p.post_stripped_address,
    'pickup_time', p.pickup_time,
    'available_hours', p.available_hours,
    'images', COALESCE(p.images, ARRAY[]::TEXT[]),
    'category_id', p.category_id,
    'category_name', c.name,
    'condition', p.condition,
    'quantity', p.quantity,
    'is_active', p.is_active,
    'is_arranged', p.is_arranged,
    'post_views', COALESCE(p.post_views, 0),
    'post_likes', COALESCE(p.post_like_counter, 0),
    'created_at', p.created_at,
    'latitude', extensions.ST_Y(p.location::extensions.geometry),
    'longitude', extensions.ST_X(p.location::extensions.geometry)
  ) INTO v_listing
  FROM posts p
  LEFT JOIN categories c ON c.id = p.category_id
  WHERE p.id = p_listing_id;

  IF v_listing IS NULL THEN
    RETURN jsonb_build_object('success', FALSE, 'error', 'Listing not found');
  END IF;

  -- Get owner profile
  SELECT jsonb_build_object(
    'id', pr.id,
    'nickname', pr.nickname,
    'avatar_url', pr.avatar_url,
    'bio', pr.about_me,
    'is_verified', COALESCE(pr.is_verified, FALSE),
    'member_since', pr.created_time
  ) INTO v_owner
  FROM posts p
  JOIN profiles pr ON pr.id = p.profile_id
  WHERE p.id = p_listing_id;

  -- Get owner stats
  SELECT jsonb_build_object(
    'items_shared', COALESCE(ps.items_shared, 0),
    'rating_average', ps.rating_average,
    'rating_count', COALESCE(ps.rating_count, 0),
    'response_rate', NULL::NUMERIC
  ) INTO v_owner_stats
  FROM posts p
  LEFT JOIN profile_stats ps ON ps.profile_id = p.profile_id
  WHERE p.id = p_listing_id;

  -- Get similar items (same category, nearby)
  SELECT COALESCE(jsonb_agg(jsonb_build_object(
    'id', p2.id,
    'post_name', p2.post_name,
    'images', COALESCE(p2.images[1:1], ARRAY[]::TEXT[]),
    'post_type', p2.post_type
  )), '[]'::jsonb)
  INTO v_similar_items
  FROM posts p
  JOIN posts p2 ON p2.category_id = p.category_id AND p2.id != p.id
  WHERE p.id = p_listing_id
    AND p2.is_active = TRUE
    AND p2.is_arranged = FALSE
  LIMIT 6;

  -- Get viewer's interaction with this listing (if logged in)
  IF p_viewer_id IS NOT NULL THEN
    SELECT jsonb_build_object(
      'has_liked', EXISTS(SELECT 1 FROM post_likes WHERE post_id = p_listing_id AND profile_id = p_viewer_id),
      'has_bookmarked', EXISTS(SELECT 1 FROM post_bookmarks WHERE post_id = p_listing_id AND profile_id = p_viewer_id),
      'has_room', EXISTS(SELECT 1 FROM rooms WHERE post_id = p_listing_id AND requester = p_viewer_id),
      'is_owner', EXISTS(SELECT 1 FROM posts WHERE id = p_listing_id AND profile_id = p_viewer_id)
    ) INTO v_viewer_interaction;
  ELSE
    v_viewer_interaction := jsonb_build_object(
      'has_liked', FALSE,
      'has_bookmarked', FALSE,
      'has_room', FALSE,
      'is_owner', FALSE
    );
  END IF;

  -- Increment view count (fire and forget)
  UPDATE posts SET post_views = COALESCE(post_views, 0) + 1 WHERE id = p_listing_id;

  RETURN jsonb_build_object(
    'success', TRUE,
    'listing', v_listing,
    'owner', v_owner,
    'owner_stats', COALESCE(v_owner_stats, '{}'::jsonb),
    'similar_items', v_similar_items,
    'viewer_interaction', v_viewer_interaction,
    'meta', jsonb_build_object(
      'timestamp', NOW(),
      'cache_ttl', 300
    )
  );
END;
$$;


--
-- Name: get_listing_detail_data(bigint, uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_listing_detail_data(p_listing_id bigint, p_viewer_id uuid DEFAULT NULL::uuid) RETURNS jsonb
    LANGUAGE plpgsql STABLE SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
DECLARE
  v_listing JSONB;
  v_owner JSONB;
  v_owner_stats JSONB;
  v_similar_items JSONB;
  v_viewer_interaction JSONB;
BEGIN
  -- Get listing details
  SELECT jsonb_build_object(
    'id', p.id,
    'post_name', p.post_name,
    'post_description', p.post_description,
    'post_type', p.post_type,
    'post_address', p.post_address,
    'pickup_time', p.pickup_time,
    'available_hours', p.available_hours,
    'images', COALESCE(p.images, ARRAY[]::TEXT[]),
    'category_id', p.category_id,
    'category_name', c.name,
    'condition', p.condition,
    'quantity', p.quantity,
    'is_active', p.is_active,
    'is_arranged', p.is_arranged,
    'post_views', COALESCE(p.post_views, 0),
    'post_likes', COALESCE(p.post_like_counter, 0),
    'created_at', p.created_at,
    'latitude', extensions.ST_Y(p.location::extensions.geometry),
    'longitude', extensions.ST_X(p.location::extensions.geometry)
  ) INTO v_listing
  FROM posts p
  LEFT JOIN categories c ON c.id = p.category_id
  WHERE p.id = p_listing_id;

  IF v_listing IS NULL THEN
    RETURN jsonb_build_object('success', FALSE, 'error', 'Listing not found');
  END IF;

  -- Get owner profile
  SELECT jsonb_build_object(
    'id', pr.id,
    'nickname', pr.nickname,
    'avatar_url', pr.avatar_url,
    'bio', pr.about_me,
    'is_verified', COALESCE(pr.is_verified, FALSE),
    'member_since', pr.created_time
  ) INTO v_owner
  FROM posts p
  JOIN profiles pr ON pr.id = p.profile_id
  WHERE p.id = p_listing_id;

  -- Get owner stats
  SELECT jsonb_build_object(
    'items_shared', COALESCE(ps.items_shared, 0),
    'rating_average', ps.rating_average,
    'rating_count', COALESCE(ps.rating_count, 0),
    'response_rate', NULL::NUMERIC
  ) INTO v_owner_stats
  FROM posts p
  LEFT JOIN profile_stats ps ON ps.profile_id = p.profile_id
  WHERE p.id = p_listing_id;

  -- Get similar items (same category, nearby)
  SELECT COALESCE(jsonb_agg(jsonb_build_object(
    'id', p2.id,
    'post_name', p2.post_name,
    'images', COALESCE(p2.images[1:1], ARRAY[]::TEXT[]),
    'post_type', p2.post_type
  )), '[]'::jsonb)
  INTO v_similar_items
  FROM posts p
  JOIN posts p2 ON p2.category_id = p.category_id AND p2.id != p.id
  WHERE p.id = p_listing_id
    AND p2.is_active = TRUE
    AND p2.is_arranged = FALSE
  LIMIT 6;

  -- Get viewer's interaction with this listing (if logged in)
  IF p_viewer_id IS NOT NULL THEN
    SELECT jsonb_build_object(
      'has_liked', EXISTS(SELECT 1 FROM post_likes WHERE post_id = p_listing_id AND profile_id = p_viewer_id),
      'has_bookmarked', EXISTS(SELECT 1 FROM post_bookmarks WHERE post_id = p_listing_id AND profile_id = p_viewer_id),
      'has_room', EXISTS(SELECT 1 FROM rooms WHERE post_id = p_listing_id AND requester = p_viewer_id),
      'is_owner', EXISTS(SELECT 1 FROM posts WHERE id = p_listing_id AND profile_id = p_viewer_id)
    ) INTO v_viewer_interaction;
  ELSE
    v_viewer_interaction := jsonb_build_object(
      'has_liked', FALSE,
      'has_bookmarked', FALSE,
      'has_room', FALSE,
      'is_owner', FALSE
    );
  END IF;

  -- Increment view count (fire and forget)
  UPDATE posts SET post_views = COALESCE(post_views, 0) + 1 WHERE id = p_listing_id;

  RETURN jsonb_build_object(
    'success', TRUE,
    'listing', v_listing,
    'owner', v_owner,
    'owner_stats', COALESCE(v_owner_stats, '{}'::jsonb),
    'similar_items', v_similar_items,
    'viewer_interaction', v_viewer_interaction,
    'meta', jsonb_build_object(
      'timestamp', NOW(),
      'cache_ttl', 300
    )
  );
END;
$$;


--
-- Name: FUNCTION get_listing_detail_data(p_listing_id bigint, p_viewer_id uuid); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.get_listing_detail_data(p_listing_id bigint, p_viewer_id uuid) IS 'Returns all data needed for listing detail screen';


--
-- Name: get_locations_in_viewport(double precision, double precision, double precision, double precision, text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_locations_in_viewport(p_north double precision, p_south double precision, p_east double precision, p_west double precision, p_post_type text DEFAULT NULL::text) RETURNS TABLE(id bigint, post_name text, post_type text, images text[], location_json jsonb)
    LANGUAGE plpgsql STABLE SECURITY DEFINER
    SET search_path TO 'public', 'extensions'
    AS $$
BEGIN
  RETURN QUERY
  SELECT
    p.id,
    p.post_name,
    p.post_type,
    p.images,
    p.location_json
  FROM posts p
  WHERE p.location IS NOT NULL
    AND p.is_active = true
    AND ST_Intersects(
      p.location::geometry,
      ST_MakeEnvelope(p_west, p_south, p_east, p_north, 4326)
    )
    AND (p_post_type IS NULL OR p.post_type = p_post_type);
END;
$$;


--
-- Name: FUNCTION get_locations_in_viewport(p_north double precision, p_south double precision, p_east double precision, p_west double precision, p_post_type text); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.get_locations_in_viewport(p_north double precision, p_south double precision, p_east double precision, p_west double precision, p_post_type text) IS 'Fetches map locations within a viewport bounding box. 
Uses PostGIS ST_Intersects for efficient spatial queries.
Returns only id, post_name, post_type, images, and location_json for map markers.
Pass NULL for p_post_type to fetch all types.';


--
-- Name: get_login_spike_stats(integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_login_spike_stats(p_current_window_minutes integer DEFAULT 30, p_baseline_window_hours integer DEFAULT 24) RETURNS TABLE(current_failures bigint, baseline_failures bigint, spike_multiplier numeric)
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public', 'pg_temp'
    AS $$
DECLARE
    v_current BIGINT;
    v_baseline BIGINT;
    v_baseline_per_window NUMERIC;
BEGIN
    SELECT COUNT(*) INTO v_current
    FROM security.login_attempts
    WHERE success = false
      AND created_at > now() - (p_current_window_minutes || ' minutes')::INTERVAL;

    SELECT COUNT(*) INTO v_baseline
    FROM security.login_attempts
    WHERE success = false
      AND created_at > now() - (p_baseline_window_hours || ' hours')::INTERVAL
      AND created_at <= now() - (p_current_window_minutes || ' minutes')::INTERVAL;

    v_baseline_per_window := (v_baseline::NUMERIC / (p_baseline_window_hours * 60.0)) * p_current_window_minutes;

    RETURN QUERY SELECT
        v_current,
        v_baseline,
        CASE
            WHEN v_baseline_per_window = 0 THEN 0
            ELSE ROUND(v_current::NUMERIC / GREATEST(v_baseline_per_window, 1), 2)
        END;
END;
$$;


--
-- Name: FUNCTION get_login_spike_stats(p_current_window_minutes integer, p_baseline_window_hours integer); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.get_login_spike_stats(p_current_window_minutes integer, p_baseline_window_hours integer) IS 'Compares current failed logins to baseline for spike detection';


--
-- Name: get_longitude(extensions.geography); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_longitude(loc extensions.geography) RETURNS double precision
    LANGUAGE sql IMMUTABLE
    SET search_path TO ''
    AS $$
  SELECT ST_X(loc::geometry);
$$;


--
-- Name: get_longitude(text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_longitude(address text) RETURNS numeric
    LANGUAGE plpgsql STABLE
    SET search_path TO ''
    AS $$
DECLARE
  lng numeric;
BEGIN
  SELECT longitude INTO lng FROM public.geocode_address(address);
  RETURN lng;
END;
$$;


--
-- Name: get_mixed_activity_feed(integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_mixed_activity_feed(p_limit integer DEFAULT 20, p_offset integer DEFAULT 0) RETURNS jsonb
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
DECLARE
  v_result jsonb;
BEGIN
  WITH posts_activity AS (
    SELECT jsonb_build_object(
      'activity_type', CASE WHEN p.is_arranged THEN 'listingArranged' ELSE 'newListing' END,
      'title', p.post_name,
      'subtitle', COALESCE(p.post_description, ''),
      'image_url', CASE WHEN p.images IS NOT NULL AND array_length(p.images, 1) > 0 THEN p.images[1] ELSE NULL END,
      'timestamp', p.created_at,
      'actor_name', pr.nickname,
      'actor_avatar_url', pr.avatar_url,
      'linked_post_id', p.id,
      'linked_forum_id', NULL::int,
      'linked_profile_id', pr.id
    ) as activity,
    p.created_at as sort_time
    FROM posts p
    LEFT JOIN profiles pr ON p.profile_id = pr.id
    WHERE p.is_active = true
    ORDER BY p.created_at DESC
    LIMIT p_limit
    OFFSET p_offset
  ),
  forum_activity AS (
    SELECT jsonb_build_object(
      'activity_type', 'forumPost',
      'title', f.forum_post_name,
      'subtitle', COALESCE(f.forum_post_description, ''),
      'image_url', NULL::text,
      'timestamp', f.forum_post_created_at,
      'actor_name', pr.nickname,
      'actor_avatar_url', pr.avatar_url,
      'linked_post_id', NULL::int,
      'linked_forum_id', f.id,
      'linked_profile_id', pr.id
    ) as activity,
    f.forum_post_created_at as sort_time
    FROM forum f
    LEFT JOIN profiles pr ON f.profile_id = pr.id
    WHERE f.forum_published = true
    ORDER BY f.forum_post_created_at DESC
    LIMIT LEAST(p_limit / 4, 5)
    OFFSET p_offset
  ),
  combined AS (
    SELECT activity, sort_time FROM posts_activity
    UNION ALL
    SELECT activity, sort_time FROM forum_activity
  )
  SELECT COALESCE(jsonb_agg(activity ORDER BY sort_time DESC), '[]'::jsonb)
  INTO v_result
  FROM combined;
  
  RETURN v_result;
END;
$$;


--
-- Name: FUNCTION get_mixed_activity_feed(p_limit integer, p_offset integer); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.get_mixed_activity_feed(p_limit integer, p_offset integer) IS 'Returns combined and sorted activity feed from posts and forum. Replaces 2 queries + client-side sort.';


--
-- Name: get_mobile_home_data(double precision, double precision, double precision, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_mobile_home_data(p_latitude double precision DEFAULT NULL::double precision, p_longitude double precision DEFAULT NULL::double precision, p_radius_km double precision DEFAULT 25, p_feed_limit integer DEFAULT 20, p_challenges_limit integer DEFAULT 5) RETURNS jsonb
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
DECLARE
  v_user_id uuid;
  v_result jsonb;
  v_feed jsonb;
  v_challenges jsonb;
  v_notifications jsonb;
  v_user_stats jsonb;
  v_unread_messages integer;
  v_unread_notifications integer;
BEGIN
  -- Get current user
  v_user_id := auth.uid();
  
  -- Get nearby posts for feed
  SELECT jsonb_agg(post_data)
  INTO v_feed
  FROM (
    SELECT jsonb_build_object(
      'id', p.id,
      'post_name', p.post_name,
      'post_description', p.post_description,
      'post_type', p.post_type,
      'post_address', p.post_address,
      'post_stripped_address', p.post_stripped_address,
      'images', p.images,
      'created_at', p.created_at,
      'profile', jsonb_build_object(
        'id', pr.id,
        'nickname', pr.nickname,
        'avatar_url', pr.avatar_url
      ),
      'distance_km', CASE 
        WHEN p_latitude IS NOT NULL AND p_longitude IS NOT NULL AND p.location IS NOT NULL
        THEN ST_Distance(
          p.location::geography,
          ST_SetSRID(ST_MakePoint(p_longitude, p_latitude), 4326)::geography
        ) / 1000
        ELSE NULL
      END
    ) as post_data
    FROM posts p
    LEFT JOIN profiles pr ON p.profile_id = pr.id
    WHERE p.is_active = true
    AND (
      p_latitude IS NULL 
      OR p_longitude IS NULL 
      OR p.location IS NULL
      OR ST_DWithin(
        p.location::geography,
        ST_SetSRID(ST_MakePoint(p_longitude, p_latitude), 4326)::geography,
        p_radius_km * 1000
      )
    )
    ORDER BY p.created_at DESC
    LIMIT p_feed_limit
  ) sub;
  
  -- Get active challenges
  SELECT jsonb_agg(challenge_data)
  INTO v_challenges
  FROM (
    SELECT jsonb_build_object(
      'id', c.id,
      'title', c.title,
      'description', c.description,
      'challenge_type', c.challenge_type,
      'target_value', c.target_value,
      'start_date', c.start_date,
      'end_date', c.end_date,
      'reward_points', c.reward_points,
      'image_url', c.image_url,
      'participant_count', (
        SELECT COUNT(*) FROM challenge_participants cp WHERE cp.challenge_id = c.id
      ),
      'user_progress', CASE 
        WHEN v_user_id IS NOT NULL THEN (
          SELECT jsonb_build_object(
            'current_progress', cp.current_progress,
            'completed', cp.completed_at IS NOT NULL
          )
          FROM challenge_participants cp
          WHERE cp.challenge_id = c.id AND cp.profile_id = v_user_id
        )
        ELSE NULL
      END
    ) as challenge_data
    FROM challenges c
    WHERE c.status = 'active'
    AND c.start_date <= now()
    AND c.end_date >= now()
    ORDER BY c.end_date ASC
    LIMIT p_challenges_limit
  ) sub;
  
  -- Get user stats if authenticated
  IF v_user_id IS NOT NULL THEN
    SELECT jsonb_build_object(
      'active_listings', COALESCE(active_listings_count, 0),
      'total_shares', COALESCE(total_shares_count, 0),
      'total_receives', COALESCE(total_receives_count, 0),
      'unread_notifications', COALESCE(unread_notifications_count, 0),
      'unread_messages', COALESCE(unread_messages_count, 0)
    )
    INTO v_user_stats
    FROM mv_user_stats
    WHERE profile_id = v_user_id;
    
    -- Get unread counts
    SELECT COUNT(*)::integer INTO v_unread_notifications
    FROM notifications
    WHERE profile_id = v_user_id AND read_at IS NULL;
    
    SELECT COUNT(*)::integer INTO v_unread_messages
    FROM messages m
    JOIN rooms r ON m.room_id = r.id
    WHERE (r.requester_id = v_user_id OR r.sharer_id = v_user_id)
    AND m.sender_id != v_user_id
    AND m.read_at IS NULL;
  END IF;
  
  -- Build result
  v_result := jsonb_build_object(
    'feed', COALESCE(v_feed, '[]'::jsonb),
    'challenges', COALESCE(v_challenges, '[]'::jsonb),
    'user_stats', COALESCE(v_user_stats, '{}'::jsonb),
    'unread_notifications', COALESCE(v_unread_notifications, 0),
    'unread_messages', COALESCE(v_unread_messages, 0),
    'server_time', now()
  );
  
  RETURN v_result;
END;
$$;


--
-- Name: get_moderation_queue(text, text, boolean, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_moderation_queue(p_status text DEFAULT 'pending'::text, p_queue_type text DEFAULT NULL::text, p_assigned_to_me boolean DEFAULT false, p_limit integer DEFAULT 20, p_offset integer DEFAULT 0) RETURNS TABLE(id uuid, queue_type text, content_type text, forum_id integer, comment_id integer, message_id uuid, target_profile_id uuid, priority integer, status text, flag_reason text, flag_score numeric, content_snapshot jsonb, reporter_username text, assigned_to_username text, created_at timestamp with time zone, report_count bigint)
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
BEGIN
  -- Check moderator status
  IF NOT EXISTS (SELECT 1 FROM forum_trust_progress WHERE profile_id = auth.uid() AND current_level >= 4) THEN
    RAISE EXCEPTION 'Access denied: moderator privileges required';
  END IF;
  
  RETURN QUERY
  SELECT 
    mq.id,
    mq.queue_type,
    mq.content_type,
    mq.forum_id,
    mq.comment_id,
    mq.message_id,
    mq.profile_id AS target_profile_id,
    mq.priority,
    mq.status,
    mq.flag_reason,
    mq.flag_score,
    mq.content_snapshot,
    rp.nickname AS reporter_username,
    ap.nickname AS assigned_to_username,
    mq.created_at,
    (SELECT COUNT(*) FROM forum_reports r WHERE 
      (r.forum_id = mq.forum_id AND mq.forum_id IS NOT NULL) OR 
      (r.comment_id = mq.comment_id AND mq.comment_id IS NOT NULL)
    ) AS report_count
  FROM forum_moderation_queue mq
  LEFT JOIN profiles rp ON rp.id = mq.reporter_id
  LEFT JOIN profiles ap ON ap.id = mq.assigned_to
  WHERE mq.status = p_status
    AND (p_queue_type IS NULL OR mq.queue_type = p_queue_type)
    AND (NOT p_assigned_to_me OR mq.assigned_to = auth.uid())
  ORDER BY mq.priority DESC, mq.created_at ASC
  LIMIT p_limit
  OFFSET p_offset;
END;
$$;


--
-- Name: get_moderation_stats(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_moderation_stats() RETURNS jsonb
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
DECLARE
  v_pending_count INTEGER;
  v_high_priority_count INTEGER;
  v_resolved_today INTEGER;
  v_total_reports INTEGER;
BEGIN
  -- Count pending items
  SELECT COUNT(*)
  INTO v_pending_count
  FROM moderation_queue
  WHERE status = 'pending';

  -- Count high priority pending items
  SELECT COUNT(*)
  INTO v_high_priority_count
  FROM moderation_queue
  WHERE status = 'pending'
    AND priority = 'high';

  -- Count items resolved today
  SELECT COUNT(*)
  INTO v_resolved_today
  FROM moderation_queue
  WHERE status IN ('approved', 'rejected')
    AND resolved_at >= CURRENT_DATE;

  -- Total reports
  SELECT COUNT(*)
  INTO v_total_reports
  FROM moderation_queue;

  RETURN jsonb_build_object(
    'pending_count', v_pending_count,
    'high_priority_count', v_high_priority_count,
    'resolved_today', v_resolved_today,
    'total_reports', v_total_reports
  );
END;
$$;


--
-- Name: get_my_profile(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_my_profile(p_user_id uuid) RETURNS jsonb
    LANGUAGE plpgsql STABLE SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
DECLARE
  v_profile record;
  v_listing_stats record;
  v_recent_activity jsonb;
  v_unread_count integer;
BEGIN
  -- Get profile data
  SELECT
    p.id,
    p.username,
    p.email,
    p.avatar_url,
    p.bio,
    p.is_active,
    p.items_shared,
    p.rating_average,
    p.rating_count,
    p.dietary_preferences,
    p.notification_preferences,
    p.created_at,
    p.updated_at
  INTO v_profile
  FROM profiles p
  WHERE p.id = p_user_id
    AND p.deleted_at IS NULL;

  IF v_profile IS NULL THEN
    RETURN jsonb_build_object(
      'success', false,
      'error', jsonb_build_object('code', 'NOT_FOUND', 'message', 'Profile not found')
    );
  END IF;

  -- Get listing stats
  SELECT
    COUNT(*) FILTER (WHERE is_active = true AND deleted_at IS NULL AND post_type = 'food') AS active_food,
    COUNT(*) FILTER (WHERE is_active = true AND deleted_at IS NULL AND post_type = 'request') AS active_requests,
    COUNT(*) FILTER (WHERE is_active = false AND deleted_at IS NULL) AS completed,
    COUNT(*) FILTER (WHERE deleted_at IS NULL) AS total
  INTO v_listing_stats
  FROM posts
  WHERE profile_id = p_user_id;

  -- Get unread counts
  SELECT COUNT(*) INTO v_unread_count
  FROM notifications
  WHERE profile_id = p_user_id AND read_at IS NULL;

  -- Get recent activity summary
  SELECT COALESCE(jsonb_agg(
    jsonb_build_object(
      'type', 'notification',
      'title', n.notification_title,
      'timestamp', n.timestamp,
      'isRead', n.read_at IS NOT NULL
    ) ORDER BY n.timestamp DESC
  ), '[]'::jsonb) INTO v_recent_activity
  FROM (
    SELECT * FROM notifications
    WHERE profile_id = p_user_id
    ORDER BY timestamp DESC
    LIMIT 3
  ) n;

  -- Return profile with editable fields
  RETURN jsonb_build_object(
    'success', true,
    'profile', jsonb_build_object(
      'id', v_profile.id,
      'username', v_profile.username,
      'email', v_profile.email,
      'avatarUrl', v_profile.avatar_url,
      'bio', v_profile.bio,
      'isActive', v_profile.is_active,
      'dietaryPreferences', COALESCE(v_profile.dietary_preferences, '[]'::jsonb),
      'notificationPreferences', COALESCE(v_profile.notification_preferences, '{}'::jsonb),
      'createdAt', v_profile.created_at,
      'updatedAt', v_profile.updated_at
    ),
    'editableFields', jsonb_build_array(
      jsonb_build_object('field', 'username', 'type', 'text', 'label', 'Username', 'maxLength', 30),
      jsonb_build_object('field', 'bio', 'type', 'textarea', 'label', 'Bio', 'maxLength', 500),
      jsonb_build_object('field', 'avatarUrl', 'type', 'image', 'label', 'Profile Photo'),
      jsonb_build_object('field', 'dietaryPreferences', 'type', 'multiselect', 'label', 'Dietary Preferences',
        'options', jsonb_build_array('vegetarian', 'vegan', 'gluten-free', 'dairy-free', 'nut-free', 'halal', 'kosher'))
    ),
    'stats', jsonb_build_object(
      'itemsShared', COALESCE(v_profile.items_shared, 0),
      'rating', COALESCE(v_profile.rating_average, 0),
      'ratingCount', COALESCE(v_profile.rating_count, 0),
      'ratingDisplay', CASE
        WHEN v_profile.rating_count > 0 THEN
          ROUND(v_profile.rating_average::numeric, 1)::text || ' '
        ELSE 'No ratings'
      END,
      'memberSince', to_char(v_profile.created_at, 'Mon YYYY'),
      'memberDays', EXTRACT(DAY FROM NOW() - v_profile.created_at)::integer
    ),
    'listingStats', jsonb_build_object(
      'activeFood', v_listing_stats.active_food,
      'activeRequests', v_listing_stats.active_requests,
      'completed', v_listing_stats.completed,
      'total', v_listing_stats.total
    ),
    'badges', CASE
      WHEN v_unread_count > 0 THEN
        jsonb_build_array(
          jsonb_build_object('text', v_unread_count::text, 'color', 'red', 'screen', 'Notifications')
        )
      ELSE '[]'::jsonb
    END,
    'recentActivity', v_recent_activity,
    'quickLinks', jsonb_build_array(
      jsonb_build_object('label', 'My Listings', 'screen', 'MyListings', 'icon', 'list', 'badge', v_listing_stats.active_food + v_listing_stats.active_requests),
      jsonb_build_object('label', 'Notifications', 'screen', 'Notifications', 'icon', 'bell', 'badge', v_unread_count),
      jsonb_build_object('label', 'Settings', 'screen', 'Settings', 'icon', 'settings'),
      jsonb_build_object('label', 'Help', 'screen', 'Help', 'icon', 'help-circle')
    ),
    'meta', jsonb_build_object(
      'timestamp', NOW(),
      'cacheTTL', 60,
      'refreshAfter', 300
    )
  );
END;
$$;


--
-- Name: FUNCTION get_my_profile(p_user_id uuid); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.get_my_profile(p_user_id uuid) IS 'BFF endpoint: Returns own profile with editable field definitions';


--
-- Name: get_my_scheduled_posts(text, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_my_scheduled_posts(p_status text DEFAULT NULL::text, p_limit integer DEFAULT 20, p_offset integer DEFAULT 0) RETURNS TABLE(id uuid, title text, description text, category_id integer, category_name text, post_type text, scheduled_for timestamp with time zone, status text, created_at timestamp with time zone)
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
BEGIN
  RETURN QUERY
  SELECT 
    sp.id,
    sp.title,
    sp.description,
    sp.category_id,
    fc.name AS category_name,
    sp.post_type,
    sp.scheduled_for,
    sp.status,
    sp.created_at
  FROM forum_scheduled_posts sp
  LEFT JOIN forum_categories fc ON fc.id = sp.category_id
  WHERE sp.profile_id = auth.uid()
    AND (p_status IS NULL OR sp.status = p_status)
  ORDER BY sp.scheduled_for ASC
  LIMIT p_limit
  OFFSET p_offset;
END;
$$;


--
-- Name: get_my_user_stats(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_my_user_stats() RETURNS TABLE(user_id uuid, active_listings_count bigint, completed_arrangements_count bigint, unread_messages_count bigint, unread_notifications_count bigint, total_views_count bigint, avg_rating numeric, review_count bigint, last_refreshed timestamp with time zone)
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
BEGIN
    -- Only return stats for the authenticated user
    RETURN QUERY
    SELECT 
        mv.user_id,
        mv.active_listings_count,
        mv.completed_arrangements_count,
        mv.unread_messages_count,
        mv.unread_notifications_count,
        mv.total_views_count,
        mv.avg_rating,
        mv.review_count,
        mv.last_refreshed
    FROM public.mv_user_stats mv
    WHERE mv.user_id = auth.uid();
END;
$$;


--
-- Name: FUNCTION get_my_user_stats(); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.get_my_user_stats() IS 'Securely retrieves user statistics from mv_user_stats materialized view. 
Users can only access their own stats. This function replaces direct table access 
which was flagged as a security concern.';


--
-- Name: get_nearby_posts(double precision, double precision, double precision, text, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_nearby_posts(user_lat double precision, user_lng double precision, radius_meters double precision DEFAULT 5000, post_type_filter text DEFAULT NULL::text, page_limit integer DEFAULT 50, page_cursor integer DEFAULT 0) RETURNS TABLE(id bigint, profile_id uuid, post_name text, post_description text, post_type text, pickup_time text, available_hours text, post_address text, post_stripped_address text, latitude double precision, longitude double precision, images text[], is_active boolean, is_arranged boolean, post_arranged_to uuid, post_arranged_at timestamp with time zone, post_views integer, post_like_counter integer, has_pantry boolean, condition character varying, network text, website text, donation text, donation_rules text, category_id bigint, created_at timestamp with time zone, updated_at timestamp with time zone, distance_meters double precision)
    LANGUAGE plpgsql STABLE
    SET search_path TO 'public', 'extensions'
    AS $$
BEGIN
    RETURN QUERY
    SELECT
        p.id,
        p.profile_id,
        p.post_name,
        p.post_description,
        p.post_type,
        p.pickup_time,
        p.available_hours,
        p.post_address,
        p.post_stripped_address,
        extensions.ST_Y(p.location::extensions.geometry),
        extensions.ST_X(p.location::extensions.geometry),
        p.images,
        p.is_active,
        p.is_arranged,
        p.post_arranged_to,
        p.post_arranged_at,
        p.post_views,
        p.post_like_counter,
        p.has_pantry,
        p.condition,
        p.network,
        p.website,
        p.donation,
        p.donation_rules,
        p.category_id,
        p.created_at,
        p.updated_at,
        extensions.ST_Distance(
            p.location,
            extensions.ST_SetSRID(extensions.ST_MakePoint(user_lng, user_lat), 4326)::extensions.geography
        )
    FROM public.posts p
    WHERE p.is_active = true
      AND p.is_arranged = false
      AND p.location IS NOT NULL
      AND extensions.ST_DWithin(
          p.location,
          extensions.ST_SetSRID(extensions.ST_MakePoint(user_lng, user_lat), 4326)::extensions.geography,
          radius_meters
      )
      AND (post_type_filter IS NULL OR p.post_type = post_type_filter)
    ORDER BY extensions.ST_Distance(p.location, extensions.ST_SetSRID(extensions.ST_MakePoint(user_lng, user_lat), 4326)::extensions.geography) ASC
    LIMIT page_limit
    OFFSET page_cursor;
END;
$$;


--
-- Name: get_nearby_posts(double precision, double precision, integer, uuid, text, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_nearby_posts(p_latitude double precision, p_longitude double precision, p_radius_meters integer, p_user_id uuid DEFAULT NULL::uuid, p_post_type text DEFAULT NULL::text, p_limit integer DEFAULT 50, p_offset integer DEFAULT 0) RETURNS TABLE(id bigint, profile_id uuid, post_name text, post_description text, post_type text, pickup_time text, post_address text, post_stripped_address text, latitude double precision, longitude double precision, images text[], is_active boolean, is_arranged boolean, post_views integer, category_id bigint, tags text[], quantity text, created_at timestamp with time zone, updated_at timestamp with time zone, distance_meters double precision)
    LANGUAGE plpgsql STABLE SECURITY DEFINER
    AS $$
BEGIN
    RETURN QUERY
    SELECT
        p.id,
        p.profile_id,
        p.post_name,
        p.post_description,
        p.post_type,
        p.pickup_time,
        p.post_address,
        p.post_stripped_address,
        p.latitude,
        p.longitude,
        p.images,
        p.is_active,
        p.is_arranged,
        p.post_views,
        p.category_id,
        p.tags,
        p.quantity,
        p.created_at,
        p.updated_at,
        ST_Distance(
            p.location::geography,
            ST_SetSRID(ST_MakePoint(p_longitude, p_latitude), 4326)::geography
        ) AS distance_meters
    FROM posts_with_location p
    WHERE
        ST_DWithin(
            p.location::geography,
            ST_SetSRID(ST_MakePoint(p_longitude, p_latitude), 4326)::geography,
            p_radius_meters
        )
        AND p.is_active = true
        AND p.is_arranged = false
        AND (p_post_type IS NULL OR p.post_type = p_post_type)
        AND (
            p_user_id IS NULL
            OR NOT EXISTS (
                SELECT 1
                FROM blocked_users bu
                WHERE bu.user_id = p_user_id
                AND bu.blocked_user_id = p.profile_id
            )
        )
    ORDER BY distance_meters ASC
    LIMIT p_limit
    OFFSET p_offset;
END;
$$;


--
-- Name: FUNCTION get_nearby_posts(p_latitude double precision, p_longitude double precision, p_radius_meters integer, p_user_id uuid, p_post_type text, p_limit integer, p_offset integer); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.get_nearby_posts(p_latitude double precision, p_longitude double precision, p_radius_meters integer, p_user_id uuid, p_post_type text, p_limit integer, p_offset integer) IS 'Fetch posts near a location with optional user blocking filter.
When p_user_id is NULL (anonymous), returns all nearby posts.
When p_user_id is provided (authenticated), excludes blocked users.';


--
-- Name: get_nearby_posts_count(double precision, double precision, double precision); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_nearby_posts_count(user_lat double precision, user_lng double precision, radius_meters double precision DEFAULT 50000) RETURNS TABLE(post_type text, count bigint)
    LANGUAGE sql STABLE SECURITY DEFINER
    SET search_path TO 'public', 'extensions'
    AS $$
  SELECT 
    p.post_type,
    COUNT(*) as count
  FROM posts p
  WHERE 
    p.is_active = true
    AND p.location IS NOT NULL
    AND ST_DWithin(
      p.location,
      ST_SetSRID(ST_MakePoint(user_lng, user_lat), 4326)::geography,
      radius_meters
    )
  GROUP BY p.post_type
  ORDER BY count DESC;
$$;


--
-- Name: FUNCTION get_nearby_posts_count(user_lat double precision, user_lng double precision, radius_meters double precision); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.get_nearby_posts_count(user_lat double precision, user_lng double precision, radius_meters double precision) IS 'Returns count of nearby posts grouped by type for UI statistics/badges.';


--
-- Name: get_notification_preferences(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_notification_preferences(p_user_id uuid) RETURNS jsonb
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
DECLARE
  v_settings jsonb;
  v_preferences jsonb;
BEGIN
  -- Initialize if needed
  PERFORM init_notification_preferences(p_user_id);

  -- Get global settings
  SELECT jsonb_build_object(
    'push_enabled', push_enabled,
    'email_enabled', email_enabled,
    'sms_enabled', sms_enabled,
    'phone_number', phone_number,
    'phone_verified', phone_verified,
    'quiet_hours', jsonb_build_object(
      'enabled', quiet_hours_enabled,
      'start', quiet_hours_start,
      'end', quiet_hours_end,
      'timezone', timezone
    ),
    'digest', jsonb_build_object(
      'daily_enabled', daily_digest_enabled,
      'daily_time', daily_digest_time,
      'weekly_enabled', weekly_digest_enabled,
      'weekly_day', weekly_digest_day
    ),
    'dnd', jsonb_build_object(
      'enabled', dnd_enabled,
      'until', dnd_until
    )
  ) INTO v_settings
  FROM notification_settings
  WHERE user_id = p_user_id;

  -- Get category preferences grouped by category
  SELECT jsonb_object_agg(
    category::text,
    channels
  ) INTO v_preferences
  FROM (
    SELECT
      category,
      jsonb_object_agg(
        channel::text,
        jsonb_build_object(
          'enabled', enabled,
          'frequency', frequency
        )
      ) as channels
    FROM notification_preferences
    WHERE user_id = p_user_id
    GROUP BY category
  ) grouped;

  RETURN jsonb_build_object(
    'settings', v_settings,
    'preferences', COALESCE(v_preferences, '{}'::jsonb)
  );
END;
$$;


--
-- Name: get_notification_summary(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_notification_summary(p_user_id uuid) RETURNS jsonb
    LANGUAGE plpgsql STABLE SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
DECLARE
  v_unread_notifications integer;
  v_unread_messages integer;
BEGIN
  -- Get unread notification count
  SELECT COUNT(*) INTO v_unread_notifications
  FROM user_notifications
  WHERE recipient_id = p_user_id
    AND is_read = false;

  -- Get unread message count (from rooms)
  SELECT COUNT(*) INTO v_unread_messages
  FROM rooms
  WHERE (sharer = p_user_id OR requester = p_user_id)
    AND last_message_sent_by IS DISTINCT FROM p_user_id
    AND (last_message_seen_by IS NULL OR last_message_seen_by IS DISTINCT FROM p_user_id)
    AND last_message IS NOT NULL
    AND last_message != '';

  RETURN jsonb_build_object(
    'success', true,
    'notifications', v_unread_notifications,
    'messages', v_unread_messages,
    'total', v_unread_notifications + v_unread_messages,
    'badge', CASE
      WHEN (v_unread_notifications + v_unread_messages) > 99 THEN '99+'
      WHEN (v_unread_notifications + v_unread_messages) > 0 THEN (v_unread_notifications + v_unread_messages)::text
      ELSE NULL
    END,
    'meta', jsonb_build_object('timestamp', NOW(), 'cacheTTL', 30)
  );
END;
$$;


--
-- Name: FUNCTION get_notification_summary(p_user_id uuid); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.get_notification_summary(p_user_id uuid) IS 'Lightweight notification counts for header badges';


--
-- Name: get_notifications_screen(uuid, integer, integer, text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_notifications_screen(p_user_id uuid, p_offset integer DEFAULT 0, p_limit integer DEFAULT 50, p_filter text DEFAULT 'all'::text) RETURNS jsonb
    LANGUAGE plpgsql STABLE SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
DECLARE
  v_notifications jsonb;
  v_unread_count integer;
  v_total_count integer;
  v_filter_counts jsonb;
BEGIN
  -- Validate filter
  IF p_filter NOT IN ('all', 'unread', 'messages', 'listings', 'system') THEN
    p_filter := 'all';
  END IF;

  -- Get counts for filter tabs (using user_notifications table)
  SELECT jsonb_build_object(
    'all', COUNT(*),
    'unread', COUNT(*) FILTER (WHERE is_read = false),
    'messages', COUNT(*) FILTER (WHERE type = 'new_message'),
    'listings', COUNT(*) FILTER (WHERE type IN ('post_claimed', 'post_arranged', 'post_expiring', 'nearby_post'))
  ) INTO v_filter_counts
  FROM user_notifications
  WHERE recipient_id = p_user_id;

  v_unread_count := (v_filter_counts->>'unread')::integer;

  -- Get total count for current filter
  SELECT COUNT(*) INTO v_total_count
  FROM user_notifications n
  WHERE n.recipient_id = p_user_id
    AND (
      p_filter = 'all'
      OR (p_filter = 'unread' AND n.is_read = false)
      OR (p_filter = 'messages' AND n.type = 'new_message')
      OR (p_filter = 'listings' AND n.type IN ('post_claimed', 'post_arranged', 'post_expiring', 'nearby_post'))
      OR (p_filter = 'system' AND n.type IN ('welcome', 'system'))
    );

  -- Get filtered notifications with display formatting
  SELECT COALESCE(jsonb_agg(
    jsonb_build_object(
      'id', n.id,
      'title', n.title,
      'body', n.body,
      'timestamp', n.created_at,
      'timeDisplay', CASE
        WHEN n.created_at > NOW() - INTERVAL '1 minute' THEN 'Just now'
        WHEN n.created_at > NOW() - INTERVAL '1 hour' THEN
          EXTRACT(MINUTE FROM NOW() - n.created_at)::integer || 'm ago'
        WHEN n.created_at > NOW() - INTERVAL '24 hours' THEN
          EXTRACT(HOUR FROM NOW() - n.created_at)::integer || 'h ago'
        WHEN n.created_at > NOW() - INTERVAL '48 hours' THEN 'Yesterday'
        WHEN n.created_at > NOW() - INTERVAL '7 days' THEN
          EXTRACT(DAY FROM NOW() - n.created_at)::integer || 'd ago'
        ELSE to_char(n.created_at, 'Mon DD')
      END,
      'isRead', n.is_read,
      'readAt', n.read_at,
      'type', n.type,
      'icon', CASE n.type
        WHEN 'new_message' THEN 'message-circle'
        WHEN 'post_claimed' THEN 'check-circle'
        WHEN 'post_arranged' THEN 'handshake'
        WHEN 'review_received' THEN 'star'
        WHEN 'review_reminder' THEN 'star'
        WHEN 'post_expiring' THEN 'clock'
        WHEN 'nearby_post' THEN 'map-pin'
        WHEN 'welcome' THEN 'heart'
        ELSE 'bell'
      END,
      'action', jsonb_build_object(
        'screen', CASE n.type
          WHEN 'new_message' THEN 'Chat'
          WHEN 'post_claimed' THEN 'FoodItemDetail'
          WHEN 'post_arranged' THEN 'FoodItemDetail'
          WHEN 'review_received' THEN 'Reviews'
          WHEN 'review_reminder' THEN 'Reviews'
          WHEN 'post_expiring' THEN 'FoodItemDetail'
          WHEN 'nearby_post' THEN 'FoodItemDetail'
          ELSE 'Notifications'
        END,
        'params', COALESCE(n.data, '{}'::jsonb),
        'postId', n.post_id,
        'roomId', n.room_id
      ),
      'actor', CASE WHEN n.actor_id IS NOT NULL THEN (
        SELECT jsonb_build_object(
          'id', p.id,
          'nickname', p.nickname,
          'avatarUrl', p.avatar_url
        )
        FROM profiles p
        WHERE p.id = n.actor_id
      ) ELSE NULL END,
      'swipeActions', jsonb_build_array(
        jsonb_build_object(
          'label', CASE WHEN n.is_read = false THEN 'Mark Read' ELSE 'Mark Unread' END,
          'action', CASE WHEN n.is_read = false THEN 'mark_read' ELSE 'mark_unread' END,
          'color', 'blue'
        ),
        jsonb_build_object('label', 'Delete', 'action', 'delete', 'color', 'red')
      )
    ) ORDER BY n.created_at DESC
  ), '[]'::jsonb) INTO v_notifications
  FROM (
    SELECT *
    FROM user_notifications
    WHERE recipient_id = p_user_id
      AND (
        p_filter = 'all'
        OR (p_filter = 'unread' AND is_read = false)
        OR (p_filter = 'messages' AND type = 'new_message')
        OR (p_filter = 'listings' AND type IN ('post_claimed', 'post_arranged', 'post_expiring', 'nearby_post'))
        OR (p_filter = 'system' AND type IN ('welcome', 'system'))
      )
    ORDER BY created_at DESC
    OFFSET p_offset
    LIMIT p_limit
  ) n;

  -- Return complete screen data
  RETURN jsonb_build_object(
    'success', true,
    'notifications', v_notifications,
    'counts', jsonb_build_object(
      'unread', v_unread_count,
      'total', v_total_count,
      'filtered', jsonb_array_length(v_notifications)
    ),
    'filterCounts', v_filter_counts,
    'filters', jsonb_build_array(
      jsonb_build_object('id', 'all', 'label', 'All', 'count', (v_filter_counts->>'all')::integer, 'isActive', p_filter = 'all'),
      jsonb_build_object('id', 'unread', 'label', 'Unread', 'count', (v_filter_counts->>'unread')::integer, 'isActive', p_filter = 'unread'),
      jsonb_build_object('id', 'messages', 'label', 'Messages', 'count', (v_filter_counts->>'messages')::integer, 'isActive', p_filter = 'messages'),
      jsonb_build_object('id', 'listings', 'label', 'Listings', 'count', (v_filter_counts->>'listings')::integer, 'isActive', p_filter = 'listings')
    ),
    'pagination', jsonb_build_object(
      'offset', p_offset,
      'limit', p_limit,
      'total', v_total_count,
      'hasMore', (p_offset + p_limit) < v_total_count,
      'nextOffset', CASE WHEN (p_offset + p_limit) < v_total_count THEN p_offset + p_limit ELSE NULL END
    ),
    'actions', jsonb_build_array(
      jsonb_build_object(
        'label', 'Mark All Read',
        'action', 'mark_all_read',
        'enabled', v_unread_count > 0,
        'icon', 'check-all'
      )
    ),
    'emptyState', CASE
      WHEN v_total_count = 0 THEN jsonb_build_object(
        'title', CASE p_filter
          WHEN 'unread' THEN 'All caught up!'
          WHEN 'messages' THEN 'No message notifications'
          WHEN 'listings' THEN 'No listing notifications'
          ELSE 'No notifications yet'
        END,
        'message', CASE p_filter
          WHEN 'unread' THEN 'You have no unread notifications'
          WHEN 'messages' THEN 'Message notifications will appear here'
          WHEN 'listings' THEN 'Listing notifications will appear here'
          ELSE 'When you get notifications, they will appear here'
        END,
        'icon', 'bell-off'
      )
      ELSE NULL
    END,
    'meta', jsonb_build_object(
      'timestamp', NOW(),
      'cacheTTL', 30,
      'refreshAfter', 60
    )
  );
END;
$$;


--
-- Name: FUNCTION get_notifications_screen(p_user_id uuid, p_offset integer, p_limit integer, p_filter text); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.get_notifications_screen(p_user_id uuid, p_offset integer, p_limit integer, p_filter text) IS 'BFF endpoint: Returns complete notifications screen data';


--
-- Name: get_openai_api_key(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_openai_api_key() RETURNS text
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
BEGIN
  RETURN vault.read_secret('OPENAI_API_KEY');
END;
$$;


--
-- Name: get_or_compute_feed_cell(double precision, double precision, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_or_compute_feed_cell(p_lat double precision, p_lng double precision, p_radius_km integer DEFAULT 10, p_limit integer DEFAULT 50) RETURNS jsonb
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
DECLARE
  v_cell_id text;
  v_cached record;
  v_items jsonb;
  v_from_cache boolean := false;
BEGIN
  -- Compute cell ID based on location
  v_cell_id := lat_lng_to_geohash(p_lat, p_lng, 5) || '_' || p_radius_km::text;

  -- Check for cached data
  SELECT * INTO v_cached
  FROM precomputed_feed_cells
  WHERE cell_id = v_cell_id
    AND expires_at > NOW();

  IF v_cached IS NOT NULL THEN
    -- Update access stats
    UPDATE precomputed_feed_cells
    SET access_count = access_count + 1,
        last_accessed_at = NOW()
    WHERE cell_id = v_cell_id;

    v_items := v_cached.feed_data;
    v_from_cache := true;
  ELSE
    -- Compute fresh feed
    v_items := compute_feed_for_cell(v_cell_id, p_lat, p_lng, p_radius_km, p_limit);
    v_from_cache := false;

    -- Get updated cached record for metadata
    SELECT * INTO v_cached
    FROM precomputed_feed_cells
    WHERE cell_id = v_cell_id;
  END IF;

  RETURN jsonb_build_object(
    'success', true,
    'items', v_items,
    'itemCount', jsonb_array_length(v_items),
    'cache', jsonb_build_object(
      'cellId', v_cell_id,
      'fromCache', v_from_cache,
      'computedAt', v_cached.computed_at,
      'expiresAt', v_cached.expires_at,
      'accessCount', v_cached.access_count,
      'computationTimeMs', v_cached.computation_time_ms
    ),
    'meta', jsonb_build_object(
      'timestamp', NOW(),
      'centerLat', p_lat,
      'centerLng', p_lng,
      'radiusKm', p_radius_km
    )
  );
END;
$$;


--
-- Name: FUNCTION get_or_compute_feed_cell(p_lat double precision, p_lng double precision, p_radius_km integer, p_limit integer); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.get_or_compute_feed_cell(p_lat double precision, p_lng double precision, p_radius_km integer, p_limit integer) IS 'Cache-first feed retrieval with automatic recomputation';


--
-- Name: get_or_create_room(integer, uuid, uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_or_create_room(p_post_id integer, p_sharer_id uuid, p_requester_id uuid) RETURNS jsonb
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public', 'pg_temp'
    AS $$
DECLARE
  v_room_id uuid;
  v_room jsonb;
  v_created boolean := false;
BEGIN
  -- Prevent owner from creating room with themselves
  IF p_sharer_id = p_requester_id THEN
    RAISE EXCEPTION 'Cannot create a chat room with yourself' USING ERRCODE = '23514';
  END IF;

  -- Try to find existing room
  SELECT id INTO v_room_id
  FROM rooms
  WHERE post_id = p_post_id
    AND sharer = p_sharer_id
    AND requester = p_requester_id
  LIMIT 1;
  
  -- If not found, create new room
  IF v_room_id IS NULL THEN
    INSERT INTO rooms (post_id, sharer, requester)
    VALUES (p_post_id, p_sharer_id, p_requester_id)
    RETURNING id INTO v_room_id;
    v_created := true;
  END IF;
  
  -- Fetch full room data
  SELECT jsonb_build_object(
    'id', r.id,
    'post_id', r.post_id,
    'sharer', r.sharer,
    'requester', r.requester,
    'last_message', r.last_message,
    'last_message_time', r.last_message_time,
    'sharer_last_seen', r.sharer_last_seen,
    'requester_last_seen', r.requester_last_seen,
    'is_archived', r.is_archived,
    'created_at', r.created_at,
    'updated_at', r.updated_at,
    'created', v_created
  )
  INTO v_room
  FROM rooms r
  WHERE r.id = v_room_id;
  
  RETURN v_room;
END;
$$;


--
-- Name: FUNCTION get_or_create_room(p_post_id integer, p_sharer_id uuid, p_requester_id uuid); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.get_or_create_room(p_post_id integer, p_sharer_id uuid, p_requester_id uuid) IS 'Atomically finds existing room or creates new one. Replaces find-then-create pattern.';


--
-- Name: get_or_create_room(bigint, uuid, uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_or_create_room(p_post_id bigint, p_sharer_id uuid, p_requester_id uuid) RETURNS TABLE(id uuid, post_id bigint, sharer uuid, requester uuid, last_message text, last_message_time timestamp with time zone, last_message_sent_by uuid, last_message_seen_by uuid, post_arranged_to uuid, email_to text)
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
    v_room_id uuid;
BEGIN
    -- Prevent owner from creating room with themselves
    IF p_sharer_id = p_requester_id THEN
        RAISE EXCEPTION 'Cannot create a chat room with yourself' USING ERRCODE = '23514';
    END IF;

    -- Try to find existing room
    SELECT r.id INTO v_room_id
    FROM rooms r
    WHERE r.post_id = p_post_id
      AND r.sharer = p_sharer_id
      AND r.requester = p_requester_id
    LIMIT 1;

    -- If no existing room, create one
    IF v_room_id IS NULL THEN
        INSERT INTO rooms (post_id, sharer, requester)
        VALUES (p_post_id, p_sharer_id, p_requester_id)
        RETURNING rooms.id INTO v_room_id;
    END IF;

    -- Return the room data
    RETURN QUERY
    SELECT r.id, r.post_id, r.sharer, r.requester,
           r.last_message, r.last_message_time,
           r.last_message_sent_by, r.last_message_seen_by,
           r.post_arranged_to, r.email_to
    FROM rooms r
    WHERE r.id = v_room_id;
END;
$$;


--
-- Name: get_or_translate(text, text, text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_or_translate(p_source_text text, p_target_locale text, p_content_type text DEFAULT 'general'::text) RETURNS TABLE(translated_text text, cache_hit boolean, quality_score numeric, translation_id uuid)
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
    v_hash TEXT;
    v_result RECORD;
BEGIN
    v_hash := encode(sha256(p_source_text::bytea), 'hex');

    SELECT
        dct.id,
        dct.translated_text,
        dct.quality_score
    INTO v_result
    FROM dynamic_content_translations dct
    WHERE dct.content_hash = v_hash
      AND dct.target_locale = p_target_locale
      AND dct.expires_at > NOW();

    IF FOUND THEN
        UPDATE dynamic_content_translations
        SET hit_count = hit_count + 1, last_hit_at = NOW()
        WHERE id = v_result.id;

        RETURN QUERY SELECT v_result.translated_text, TRUE, v_result.quality_score, v_result.id;
    ELSE
        RETURN QUERY SELECT NULL::TEXT, FALSE, NULL::DECIMAL, NULL::UUID;
    END IF;
END;
$$;


--
-- Name: get_or_translate(text, text, text, text, text, text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_or_translate(p_content_type text, p_content_id text, p_field_name text, p_source_locale text, p_target_locale text, p_source_text text) RETURNS TABLE(translated_text text, cached boolean, quality_score double precision)
    LANGUAGE plpgsql
    AS $$
DECLARE
  v_translation RECORD;
BEGIN
  -- Try to find existing translation
  SELECT * INTO v_translation
  FROM content_translations
  WHERE content_type = p_content_type
    AND content_id = p_content_id
    AND field_name = p_field_name
    AND source_locale = p_source_locale
    AND target_locale = p_target_locale
    AND source_text = p_source_text
    AND expires_at > NOW();
  
  IF FOUND THEN
    -- Update hit count and last hit time
    UPDATE content_translations
    SET hit_count = hit_count + 1,
        last_hit_at = NOW()
    WHERE id = v_translation.id;
    
    RETURN QUERY SELECT 
      v_translation.translated_text,
      TRUE as cached,
      v_translation.quality_score;
  ELSE
    -- Return null to indicate cache miss
    RETURN QUERY SELECT 
      NULL::TEXT as translated_text,
      FALSE as cached,
      NULL::FLOAT as quality_score;
  END IF;
END;
$$;


--
-- Name: get_p95_latency(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_p95_latency(p_minutes integer DEFAULT 5) RETURNS integer
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public', 'pg_temp'
    AS $$
DECLARE
    v_p95 INT;
BEGIN
    SELECT PERCENTILE_CONT(0.95) WITHIN GROUP (ORDER BY response_time_ms)::INT
    INTO v_p95
    FROM metrics.api_requests
    WHERE created_at > now() - (p_minutes || ' minutes')::INTERVAL;

    RETURN COALESCE(v_p95, 0);
END;
$$;


--
-- Name: FUNCTION get_p95_latency(p_minutes integer); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.get_p95_latency(p_minutes integer) IS 'Returns P95 latency in milliseconds for the last N minutes';


--
-- Name: get_paginated_notifications(uuid, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_paginated_notifications(p_user_id uuid, p_limit integer DEFAULT 20, p_offset integer DEFAULT 0) RETURNS jsonb
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
DECLARE
  v_notifications JSONB;
  v_unread_count INTEGER;
  v_total_count INTEGER;
  v_has_more BOOLEAN;
BEGIN
  -- Get unread count (single query for all unread)
  SELECT COUNT(*)
  INTO v_unread_count
  FROM user_notifications
  WHERE recipient_id = p_user_id
    AND is_read = FALSE;

  -- Get total count for this user
  SELECT COUNT(*)
  INTO v_total_count
  FROM user_notifications
  WHERE recipient_id = p_user_id;

  -- Get paginated notifications with actor profile
  SELECT COALESCE(jsonb_agg(
    jsonb_build_object(
      'id', n.id,
      'recipient_id', n.recipient_id,
      'actor_id', n.actor_id,
      'type', n.type,
      'title', n.title,
      'body', n.body,
      'post_id', n.post_id,
      'room_id', n.room_id,
      'review_id', n.review_id,
      'data', n.data,
      'is_read', n.is_read,
      'read_at', n.read_at,
      'created_at', n.created_at,
      'updated_at', n.updated_at,
      -- Include actor profile
      'actor_profile', CASE 
        WHEN n.actor_id IS NOT NULL THEN (
          SELECT jsonb_build_object(
            'id', p.id,
            'nickname', p.nickname,
            'avatar_url', p.avatar_url
          )
          FROM profiles p
          WHERE p.id = n.actor_id
        )
        ELSE NULL
      END
    ) ORDER BY n.created_at DESC
  ), '[]'::jsonb)
  INTO v_notifications
  FROM user_notifications n
  WHERE n.recipient_id = p_user_id
  ORDER BY n.created_at DESC
  LIMIT p_limit
  OFFSET p_offset;

  -- Calculate if there are more pages
  v_has_more := (p_offset + p_limit) < v_total_count;

  RETURN jsonb_build_object(
    'notifications', v_notifications,
    'unread_count', v_unread_count,
    'total_count', v_total_count,
    'has_more', v_has_more
  );
END;
$$;


--
-- Name: get_pending_digest_notifications(text, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_pending_digest_notifications(p_frequency text, p_limit integer DEFAULT 100) RETURNS TABLE(user_id uuid, items jsonb, item_count integer)
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
BEGIN
    RETURN QUERY
    SELECT
        ndq.user_id,
        jsonb_agg(
            jsonb_build_object(
                'id', ndq.id,
                'type', ndq.notification_type,
                'category', ndq.category,
                'title', ndq.title,
                'body', ndq.body,
                'data', ndq.data,
                'created_at', ndq.created_at
            ) ORDER BY ndq.created_at DESC
        ) AS items,
        COUNT(*)::INTEGER AS item_count
    FROM notification_digest_queue ndq
    WHERE ndq.frequency = p_frequency
        AND ndq.status = 'pending'
        AND ndq.scheduled_for <= NOW()
    GROUP BY ndq.user_id
    LIMIT p_limit;
END;
$$;


--
-- Name: FUNCTION get_pending_digest_notifications(p_frequency text, p_limit integer); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.get_pending_digest_notifications(p_frequency text, p_limit integer) IS 'Get pending digest notifications grouped by user';


--
-- Name: get_pending_emails_for_processing(integer, text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_pending_emails_for_processing(p_batch_size integer DEFAULT 100, p_provider text DEFAULT NULL::text) RETURNS TABLE(id uuid, user_id uuid, campaign_id uuid, email_type text, template_slug text, user_email text, user_first_name text, retry_count integer, metadata jsonb)
    LANGUAGE sql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
  SELECT
    edl.id,
    edl.user_id,
    edl.campaign_id,
    edl.email_type,
    edl.template_slug,
    p.email AS user_email,
    p.first_name AS user_first_name,
    edl.retry_count,
    edl.metadata
  FROM email_delivery_log edl
  JOIN profiles p ON p.id = edl.user_id
  WHERE edl.status = 'queued'
    AND edl.retry_count < 3
    AND p.email IS NOT NULL
  ORDER BY edl.queued_at ASC
  LIMIT p_batch_size
  FOR UPDATE OF edl SKIP LOCKED;
$$;


--
-- Name: FUNCTION get_pending_emails_for_processing(p_batch_size integer, p_provider text); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.get_pending_emails_for_processing(p_batch_size integer, p_provider text) IS 'Gets batch of queued emails for processing';


--
-- Name: get_pending_geocode_queue(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_pending_geocode_queue(batch_size integer DEFAULT 10) RETURNS TABLE(id integer, post_id bigint, post_address text, retry_count integer)
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO ''
    AS $$
BEGIN
  RETURN QUERY
  SELECT
    q.id,
    q.post_id,
    q.post_address,
    q.retry_count
  FROM public.location_update_queue q
  WHERE q.status = 'pending'
    OR (q.status = 'failed' AND q.retry_count < q.max_retries)
  ORDER BY
    CASE WHEN q.status = 'pending' THEN 0 ELSE 1 END,
    q.retry_count ASC,
    q.created_at ASC
  LIMIT batch_size
  FOR UPDATE SKIP LOCKED;
END;
$$;


--
-- Name: get_personalized_feed(uuid, double precision, double precision, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_personalized_feed(p_user_id uuid, p_latitude double precision, p_longitude double precision, p_offset integer DEFAULT 0, p_limit integer DEFAULT 20) RETURNS jsonb
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
DECLARE
  v_category_weights jsonb;
  v_items jsonb;
  v_total_count integer;
  v_radius_km integer := 25;
BEGIN
  -- Get user's category preferences
  SELECT COALESCE(categories_viewed, '{}'::jsonb)
  INTO v_category_weights
  FROM user_activity_summary
  WHERE user_id = p_user_id;

  v_category_weights := COALESCE(v_category_weights, '{}'::jsonb);

  -- Count total items
  SELECT COUNT(*) INTO v_total_count
  FROM posts fi
  WHERE fi.is_active = true
    AND fi.deleted_at IS NULL
    AND fi.profile_id != p_user_id
    AND fi.post_type = 'food'
    AND fi.latitude IS NOT NULL
    AND fi.longitude IS NOT NULL
    -- Bounding box filter
    AND fi.latitude BETWEEN (p_latitude - (v_radius_km / 111.0)) AND (p_latitude + (v_radius_km / 111.0))
    AND fi.longitude BETWEEN (p_longitude - (v_radius_km / (111.0 * cos(radians(p_latitude)))))
                         AND (p_longitude + (v_radius_km / (111.0 * cos(radians(p_latitude)))));

  -- Get scored items
  SELECT COALESCE(jsonb_agg(item ORDER BY (item->>'totalScore')::integer DESC), '[]'::jsonb)
  INTO v_items
  FROM (
    SELECT jsonb_build_object(
      'id', fi.id,
      'postName', fi.post_name,
      'description', CASE
        WHEN length(fi.description) > 100
        THEN substring(fi.description, 1, 100) || '...'
        ELSE fi.description
      END,
      'thumbnail', fi.images[1],
      'images', fi.images,
      'postType', fi.post_type,
      'categoryId', fi.category_id,
      'location', jsonb_build_object(
        'lat', fi.latitude,
        'lng', fi.longitude,
        'address', fi.pickup_address
      ),
      'distance', jsonb_build_object(
        'km', ROUND((
          6371 * acos(
            LEAST(1.0, GREATEST(-1.0,
              cos(radians(p_latitude)) * cos(radians(fi.latitude)) *
              cos(radians(fi.longitude) - radians(p_longitude)) +
              sin(radians(p_latitude)) * sin(radians(fi.latitude))
            ))
          )
        )::numeric, 1),
        'display', ROUND((
          6371 * acos(
            LEAST(1.0, GREATEST(-1.0,
              cos(radians(p_latitude)) * cos(radians(fi.latitude)) *
              cos(radians(fi.longitude) - radians(p_longitude)) +
              sin(radians(p_latitude)) * sin(radians(fi.latitude))
            ))
          )
        )::numeric, 1)::text || ' km'
      ),
      'profile', jsonb_build_object(
        'id', p.id,
        'username', p.username,
        'avatar', p.avatar_url,
        'rating', ROUND(COALESCE(p.rating_average, 0)::numeric, 1)
      ),
      'createdAt', fi.created_at,
      'badges', CASE
        WHEN fi.created_at > NOW() - INTERVAL '6 hours' THEN
          jsonb_build_array(jsonb_build_object('text', 'New', 'color', 'green'))
        WHEN (
          6371 * acos(
            LEAST(1.0, GREATEST(-1.0,
              cos(radians(p_latitude)) * cos(radians(fi.latitude)) *
              cos(radians(fi.longitude) - radians(p_longitude)) +
              sin(radians(p_latitude)) * sin(radians(fi.latitude))
            ))
          )
        ) < 1 THEN
          jsonb_build_array(jsonb_build_object('text', 'Nearby', 'color', 'blue'))
        ELSE '[]'::jsonb
      END,
      -- Score breakdown for transparency
      'scoreBreakdown', jsonb_build_object(
        'distance', GREATEST(0, 30 - (
          (6371 * acos(
            LEAST(1.0, GREATEST(-1.0,
              cos(radians(p_latitude)) * cos(radians(fi.latitude)) *
              cos(radians(fi.longitude) - radians(p_longitude)) +
              sin(radians(p_latitude)) * sin(radians(fi.latitude))
            ))
          )) / v_radius_km * 30
        ))::integer,
        'freshness', GREATEST(0, 25 - (EXTRACT(DAY FROM NOW() - fi.created_at) * 2))::integer,
        'category', LEAST(25, COALESCE((v_category_weights->>fi.category_id::text)::integer, 0) * 5),
        'engagement', LEAST(20, (COALESCE(fi.post_views, 0) + COALESCE(fi.post_like_counter, 0) * 3) / 10)::integer
      ),
      'totalScore', (
        GREATEST(0, 30 - ((6371 * acos(LEAST(1.0, GREATEST(-1.0,
          cos(radians(p_latitude)) * cos(radians(fi.latitude)) *
          cos(radians(fi.longitude) - radians(p_longitude)) +
          sin(radians(p_latitude)) * sin(radians(fi.latitude))
        )))) / v_radius_km * 30))
        + GREATEST(0, 25 - (EXTRACT(DAY FROM NOW() - fi.created_at) * 2))
        + LEAST(25, COALESCE((v_category_weights->>fi.category_id::text)::integer, 0) * 5)
        + LEAST(20, (COALESCE(fi.post_views, 0) + COALESCE(fi.post_like_counter, 0) * 3) / 10)
      )::integer
    ) AS item
    FROM posts fi
    JOIN profiles p ON p.id = fi.profile_id
    WHERE fi.is_active = true
      AND fi.deleted_at IS NULL
      AND fi.profile_id != p_user_id
      AND fi.post_type = 'food'
      AND fi.latitude IS NOT NULL
      AND fi.longitude IS NOT NULL
      -- Bounding box filter
      AND fi.latitude BETWEEN (p_latitude - (v_radius_km / 111.0)) AND (p_latitude + (v_radius_km / 111.0))
      AND fi.longitude BETWEEN (p_longitude - (v_radius_km / (111.0 * cos(radians(p_latitude)))))
                           AND (p_longitude + (v_radius_km / (111.0 * cos(radians(p_latitude)))))
    ORDER BY (
      GREATEST(0, 30 - ((6371 * acos(LEAST(1.0, GREATEST(-1.0,
        cos(radians(p_latitude)) * cos(radians(fi.latitude)) *
        cos(radians(fi.longitude) - radians(p_longitude)) +
        sin(radians(p_latitude)) * sin(radians(fi.latitude))
      )))) / v_radius_km * 30))
      + GREATEST(0, 25 - (EXTRACT(DAY FROM NOW() - fi.created_at) * 2))
      + LEAST(25, COALESCE((v_category_weights->>fi.category_id::text)::integer, 0) * 5)
      + LEAST(20, (COALESCE(fi.post_views, 0) + COALESCE(fi.post_like_counter, 0) * 3) / 10)
    ) DESC
    OFFSET p_offset
    LIMIT p_limit
  ) sub;

  -- Track feed view event
  PERFORM track_user_event(p_user_id, 'feed_view', jsonb_build_object(
    'itemCount', jsonb_array_length(v_items),
    'lat', p_latitude,
    'lng', p_longitude
  ));

  RETURN jsonb_build_object(
    'success', true,
    'items', v_items,
    'pagination', jsonb_build_object(
      'offset', p_offset,
      'limit', p_limit,
      'total', v_total_count,
      'hasMore', (p_offset + p_limit) < v_total_count
    ),
    'meta', jsonb_build_object(
      'algorithm', 'personalized_v1',
      'timestamp', NOW(),
      'cacheTTL', 60,
      'hasPreferences', jsonb_typeof(v_category_weights) = 'object' AND v_category_weights != '{}'::jsonb
    )
  );
END;
$$;


--
-- Name: FUNCTION get_personalized_feed(p_user_id uuid, p_latitude double precision, p_longitude double precision, p_offset integer, p_limit integer); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.get_personalized_feed(p_user_id uuid, p_latitude double precision, p_longitude double precision, p_offset integer, p_limit integer) IS 'Returns personalized feed with ML-ready scoring';


--
-- Name: get_platform_stats(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_platform_stats(p_days integer DEFAULT 30) RETURNS jsonb
    LANGUAGE plpgsql STABLE SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
DECLARE
  v_daily_stats jsonb;
  v_totals record;
BEGIN
  -- Get daily stats
  SELECT COALESCE(jsonb_agg(
    jsonb_build_object(
      'date', date,
      'newUsers', new_users,
      'activeUsers', active_users,
      'newListings', new_listings,
      'completedShares', completed_shares,
      'notificationsSent', notifications_sent
    ) ORDER BY date DESC
  ), '[]'::jsonb) INTO v_daily_stats
  FROM daily_stats
  WHERE date >= CURRENT_DATE - p_days;

  -- Get totals
  SELECT
    COALESCE(SUM(new_users), 0) AS total_new_users,
    COALESCE(AVG(active_users), 0)::integer AS avg_active_users,
    COALESCE(SUM(new_listings), 0) AS total_new_listings,
    COALESCE(SUM(completed_shares), 0) AS total_completed_shares
  INTO v_totals
  FROM daily_stats
  WHERE date >= CURRENT_DATE - p_days;

  -- Get current platform totals
  RETURN jsonb_build_object(
    'success', true,
    'period', jsonb_build_object(
      'days', p_days,
      'from', CURRENT_DATE - p_days,
      'to', CURRENT_DATE
    ),
    'totals', jsonb_build_object(
      'newUsers', v_totals.total_new_users,
      'avgActiveUsers', v_totals.avg_active_users,
      'newListings', v_totals.total_new_listings,
      'completedShares', v_totals.total_completed_shares
    ),
    'dailyStats', v_daily_stats,
    'currentTotals', (
      SELECT jsonb_build_object(
        'totalUsers', COUNT(*) FILTER (WHERE is_active = true),
        'totalListings', (SELECT COUNT(*) FROM posts),
        'activeListings', (SELECT COUNT(*) FROM posts WHERE is_active = true)
      )
      FROM profiles
    ),
    'meta', jsonb_build_object('timestamp', NOW())
  );
END;
$$;


--
-- Name: FUNCTION get_platform_stats(p_days integer); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.get_platform_stats(p_days integer) IS 'Returns platform statistics for admin dashboards';


--
-- Name: get_poll_results(uuid, uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_poll_results(p_poll_id uuid, p_profile_id uuid) RETURNS jsonb
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
DECLARE
  v_poll jsonb;
  v_options jsonb;
  v_user_voted_option_ids jsonb;
  v_voter_count int;
BEGIN
  -- Fetch poll
  SELECT jsonb_build_object(
    'id', fp.id,
    'forum_id', fp.forum_id,
    'question', fp.question,
    'poll_type', fp.poll_type,
    'ends_at', fp.ends_at,
    'total_votes', fp.total_votes,
    'created_at', fp.created_at
  )
  INTO v_poll
  FROM forum_polls fp
  WHERE fp.id = p_poll_id;
  
  IF v_poll IS NULL THEN
    RETURN jsonb_build_object('error', 'Poll not found');
  END IF;
  
  -- Fetch options sorted by sort_order
  SELECT COALESCE(jsonb_agg(
    jsonb_build_object(
      'id', fpo.id,
      'poll_id', fpo.poll_id,
      'option_text', fpo.option_text,
      'votes_count', fpo.votes_count,
      'sort_order', fpo.sort_order,
      'created_at', fpo.created_at
    ) ORDER BY fpo.sort_order
  ), '[]'::jsonb)
  INTO v_options
  FROM forum_poll_options fpo
  WHERE fpo.poll_id = p_poll_id;
  
  -- Fetch user's voted option IDs
  SELECT COALESCE(jsonb_agg(fpv.option_id), '[]'::jsonb)
  INTO v_user_voted_option_ids
  FROM forum_poll_votes fpv
  WHERE fpv.poll_id = p_poll_id
    AND fpv.profile_id = p_profile_id;
  
  -- Count unique voters
  SELECT COUNT(DISTINCT profile_id)
  INTO v_voter_count
  FROM forum_poll_votes
  WHERE poll_id = p_poll_id;
  
  RETURN jsonb_build_object(
    'poll', v_poll,
    'options', v_options,
    'total_votes', (v_poll->>'total_votes')::int,
    'voter_count', v_voter_count,
    'user_voted_option_ids', v_user_voted_option_ids
  );
END;
$$;


--
-- Name: FUNCTION get_poll_results(p_poll_id uuid, p_profile_id uuid); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.get_poll_results(p_poll_id uuid, p_profile_id uuid) IS 'Returns poll results with options, votes, and user votes in a single call. Replaces 3 queries.';


--
-- Name: get_post(integer); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.get_post(IN p_id integer)
    LANGUAGE plpgsql
    SET search_path TO ''
    AS $$
BEGIN
  SELECT * FROM posts WHERE id = p_id;
  
  CALL increment_post_views(p_id);
END;
$$;


--
-- Name: get_post_activity_timeline(bigint, integer, integer, public.post_activity_type[]); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_post_activity_timeline(p_post_id bigint, p_limit integer DEFAULT 50, p_offset integer DEFAULT 0, p_activity_types public.post_activity_type[] DEFAULT NULL::public.post_activity_type[]) RETURNS TABLE(id uuid, activity_type public.post_activity_type, actor_id uuid, actor_nickname text, actor_avatar text, changes jsonb, metadata jsonb, reason text, notes text, created_at timestamp with time zone)
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO ''
    AS $$
BEGIN
  RETURN QUERY
  SELECT 
    pal.id,
    pal.activity_type,
    pal.actor_id,
    p.nickname AS actor_nickname,
    p.avatar_url AS actor_avatar,
    pal.changes,
    pal.metadata,
    pal.reason,
    pal.notes,
    pal.created_at
  FROM post_activity_logs pal
  LEFT JOIN profiles p ON pal.actor_id = p.id
  WHERE pal.post_id = p_post_id
    AND (p_activity_types IS NULL OR pal.activity_type = ANY(p_activity_types))
  ORDER BY pal.created_at DESC
  LIMIT p_limit
  OFFSET p_offset;
END;
$$;


--
-- Name: get_post_analytics(integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_post_analytics(p_post_id integer, p_days integer DEFAULT 7) RETURNS jsonb
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
DECLARE v_user_id UUID; v_post_owner UUID; v_result JSONB;
BEGIN v_user_id := auth.uid();
SELECT profile_id INTO v_post_owner FROM posts WHERE id = p_post_id;
IF v_post_owner IS NULL THEN RETURN jsonb_build_object('success', false, 'error', jsonb_build_object('code', 'POST_NOT_FOUND', 'message', 'Post not found')); END IF;
IF v_post_owner != v_user_id THEN RETURN jsonb_build_object('success', false, 'error', jsonb_build_object('code', 'AUTH_FORBIDDEN', 'message', 'Not authorized')); END IF;
SELECT jsonb_build_object('total_views', COALESCE(p.post_views, 0), 'total_likes', COALESCE(p.post_like_counter, 0), 'views_by_day', (SELECT COALESCE(jsonb_agg(jsonb_build_object('date', day, 'count', cnt) ORDER BY day), '[]'::JSONB) FROM (SELECT DATE(created_at) as day, COUNT(*) as cnt FROM post_views WHERE post_id = p_post_id AND created_at > NOW() - (p_days || ' days')::INTERVAL GROUP BY DATE(created_at)) daily), 'unique_viewers', (SELECT COUNT(DISTINCT COALESCE(viewer_id::TEXT, session_id)) FROM post_views WHERE post_id = p_post_id), 'engagement_rate', CASE WHEN COALESCE(p.post_views, 0) > 0 THEN ROUND((COALESCE(p.post_like_counter, 0)::NUMERIC / p.post_views) * 100, 2) ELSE 0 END) INTO v_result FROM posts p WHERE p.id = p_post_id;
RETURN jsonb_build_object('success', true, 'analytics', v_result, 'period_days', p_days);
EXCEPTION WHEN OTHERS THEN RETURN jsonb_build_object('success', false, 'error', jsonb_build_object('code', 'SERVER_ERROR', 'message', SQLERRM));
END;
$$;


--
-- Name: get_post_reactions(integer, uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_post_reactions(p_forum_id integer, p_profile_id uuid) RETURNS jsonb
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
DECLARE
  v_reactions_count jsonb;
  v_user_reaction_ids int[];
BEGIN
  -- Get reactions_count JSONB from forum post
  SELECT COALESCE(reactions_count, '{}'::jsonb)
  INTO v_reactions_count
  FROM forum
  WHERE id = p_forum_id;
  
  -- Get user's reaction type IDs
  SELECT COALESCE(array_agg(reaction_type_id), ARRAY[]::int[])
  INTO v_user_reaction_ids
  FROM forum_reactions
  WHERE forum_id = p_forum_id
    AND profile_id = p_profile_id;
  
  RETURN jsonb_build_object(
    'reactions_count', v_reactions_count,
    'user_reaction_type_ids', to_jsonb(v_user_reaction_ids)
  );
END;
$$;


--
-- Name: FUNCTION get_post_reactions(p_forum_id integer, p_profile_id uuid); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.get_post_reactions(p_forum_id integer, p_profile_id uuid) IS 'Returns forum post reactions count and user reactions in a single call. Replaces 2 queries.';


--
-- Name: get_posts_in_bounds(double precision, double precision, double precision, double precision, text, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_posts_in_bounds(min_lat double precision, min_lng double precision, max_lat double precision, max_lng double precision, post_type_filter text DEFAULT NULL::text, page_limit integer DEFAULT 100) RETURNS TABLE(id bigint, post_name text, post_type text, location_json json, images text[], is_arranged boolean)
    LANGUAGE sql STABLE SECURITY DEFINER
    SET search_path TO 'public', 'extensions'
    AS $$
  SELECT 
    p.id,
    p.post_name,
    p.post_type,
    ST_AsGeoJSON(p.location)::json AS location_json,
    p.images,
    p.is_arranged
  FROM posts p
  WHERE 
    p.is_active = true
    AND p.location IS NOT NULL
    -- Bounding box filter using && operator (uses spatial index)
    AND p.location::geometry && ST_MakeEnvelope(min_lng, min_lat, max_lng, max_lat, 4326)
    AND (post_type_filter IS NULL OR p.post_type = post_type_filter)
  LIMIT page_limit;
$$;


--
-- Name: FUNCTION get_posts_in_bounds(min_lat double precision, min_lng double precision, max_lat double precision, max_lng double precision, post_type_filter text, page_limit integer); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.get_posts_in_bounds(min_lat double precision, min_lng double precision, max_lat double precision, max_lng double precision, post_type_filter text, page_limit integer) IS 'Returns posts within a map bounding box for viewport-based loading.
Optimized for map pan/zoom interactions.';


--
-- Name: get_profile_analytics(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_profile_analytics(p_user_id uuid DEFAULT NULL::uuid) RETURNS jsonb
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
DECLARE
  v_user_id UUID;
  v_profile RECORD;
  v_stats RECORD;
  v_completion JSONB;
  v_impact JSONB;
  v_rank JSONB;
  v_completed_count INT := 0;
  v_missing_fields TEXT[] := ARRAY[]::TEXT[];
  v_total_exchanges INT;
  v_rank_tier TEXT;
  v_next_tier TEXT;
  v_progress_to_next INT;
  
  -- Impact calculation constants (server-side source of truth)
  c_co2_kg_per_item CONSTANT NUMERIC := 2.5;
  c_water_liters_per_item CONSTANT NUMERIC := 100;
  c_food_kg_per_item CONSTANT NUMERIC := 0.5;
  c_money_usd_per_item CONSTANT NUMERIC := 5.0;
BEGIN
  -- Use provided user_id or authenticated user
  v_user_id := COALESCE(p_user_id, auth.uid());
  
  IF v_user_id IS NULL THEN
    RAISE EXCEPTION 'User not authenticated and no user_id provided';
  END IF;
  
  -- Fetch profile
  SELECT * INTO v_profile FROM profiles WHERE id = v_user_id;
  
  IF v_profile IS NULL THEN
    RETURN jsonb_build_object('success', false, 'error', 'Profile not found');
  END IF;
  
  -- Fetch stats (may not exist for new users)
  SELECT * INTO v_stats FROM profile_stats WHERE profile_id = v_user_id;
  
  -- Calculate profile completion
  -- Field 1: Display name (nickname)
  IF v_profile.nickname IS NOT NULL AND v_profile.nickname != '' THEN
    v_completed_count := v_completed_count + 1;
  ELSE
    v_missing_fields := array_append(v_missing_fields, 'Display name');
  END IF;
  
  -- Field 2: Profile photo (avatar_url)
  IF v_profile.avatar_url IS NOT NULL AND v_profile.avatar_url != '' THEN
    v_completed_count := v_completed_count + 1;
  ELSE
    v_missing_fields := array_append(v_missing_fields, 'Profile photo');
  END IF;
  
  -- Field 3: Bio
  IF v_profile.bio IS NOT NULL AND v_profile.bio != '' THEN
    v_completed_count := v_completed_count + 1;
  ELSE
    v_missing_fields := array_append(v_missing_fields, 'Bio');
  END IF;
  
  -- Field 4: Location
  IF v_profile.location IS NOT NULL THEN
    v_completed_count := v_completed_count + 1;
  ELSE
    v_missing_fields := array_append(v_missing_fields, 'Location');
  END IF;
  
  -- Field 5: First food share
  IF COALESCE(v_stats.items_shared, 0) > 0 OR COALESCE(v_stats.items_received, 0) > 0 THEN
    v_completed_count := v_completed_count + 1;
  ELSE
    v_missing_fields := array_append(v_missing_fields, 'First food share');
  END IF;
  
  v_completion := jsonb_build_object(
    'percentage', ROUND((v_completed_count::NUMERIC / 5) * 100, 1),
    'completedCount', v_completed_count,
    'totalFields', 5,
    'completedFields', ARRAY(
      SELECT f FROM (VALUES 
        ('Display name'), ('Profile photo'), ('Bio'), ('Location'), ('First food share')
      ) AS fields(f)
      WHERE f != ALL(v_missing_fields)
    ),
    'missingFields', v_missing_fields,
    'isComplete', v_completed_count >= 5,
    'nextStep', CASE WHEN array_length(v_missing_fields, 1) > 0 
                     THEN v_missing_fields[1] 
                     ELSE NULL END
  );
  
  -- Calculate community rank
  v_total_exchanges := COALESCE(v_stats.items_shared, 0) + COALESCE(v_stats.items_received, 0);
  
  SELECT tier, next_tier, progress INTO v_rank_tier, v_next_tier, v_progress_to_next
  FROM (
    SELECT 
      CASE
        WHEN v_total_exchanges = 0 THEN 'Newcomer'
        WHEN v_total_exchanges BETWEEN 1 AND 5 THEN 'Food Saver'
        WHEN v_total_exchanges BETWEEN 6 AND 15 THEN 'Community Helper'
        WHEN v_total_exchanges BETWEEN 16 AND 30 THEN 'Sharing Champion'
        WHEN v_total_exchanges BETWEEN 31 AND 50 THEN 'Food Hero'
        WHEN v_total_exchanges BETWEEN 51 AND 100 THEN 'Sustainability Star'
        ELSE 'Legend'
      END AS tier,
      CASE
        WHEN v_total_exchanges = 0 THEN 'Food Saver'
        WHEN v_total_exchanges BETWEEN 1 AND 5 THEN 'Community Helper'
        WHEN v_total_exchanges BETWEEN 6 AND 15 THEN 'Sharing Champion'
        WHEN v_total_exchanges BETWEEN 16 AND 30 THEN 'Food Hero'
        WHEN v_total_exchanges BETWEEN 31 AND 50 THEN 'Sustainability Star'
        WHEN v_total_exchanges BETWEEN 51 AND 100 THEN 'Legend'
        ELSE NULL
      END AS next_tier,
      CASE
        WHEN v_total_exchanges = 0 THEN 0
        WHEN v_total_exchanges BETWEEN 1 AND 5 THEN ROUND(((v_total_exchanges - 1)::NUMERIC / 5) * 100)
        WHEN v_total_exchanges BETWEEN 6 AND 15 THEN ROUND(((v_total_exchanges - 6)::NUMERIC / 10) * 100)
        WHEN v_total_exchanges BETWEEN 16 AND 30 THEN ROUND(((v_total_exchanges - 16)::NUMERIC / 15) * 100)
        WHEN v_total_exchanges BETWEEN 31 AND 50 THEN ROUND(((v_total_exchanges - 31)::NUMERIC / 20) * 100)
        WHEN v_total_exchanges BETWEEN 51 AND 100 THEN ROUND(((v_total_exchanges - 51)::NUMERIC / 50) * 100)
        ELSE 100
      END AS progress
  ) ranks;
  
  v_rank := jsonb_build_object(
    'tier', v_rank_tier,
    'nextTier', v_next_tier,
    'progressToNextTier', v_progress_to_next,
    'totalExchanges', v_total_exchanges
  );
  
  -- Calculate impact metrics (server-side calculations)
  v_impact := jsonb_build_object(
    'mealsShared', COALESCE(v_stats.items_shared, 0),
    'mealsReceived', COALESCE(v_stats.items_received, 0),
    'foodSavedKg', ROUND(COALESCE(v_stats.items_shared, 0) * c_food_kg_per_item, 2),
    'co2SavedKg', ROUND(COALESCE(v_stats.items_shared, 0) * c_co2_kg_per_item, 2),
    'waterSavedLiters', ROUND(COALESCE(v_stats.items_shared, 0) * c_water_liters_per_item, 2),
    'moneySavedUsd', ROUND(COALESCE(v_stats.items_shared, 0) * c_money_usd_per_item, 2),
    -- Gamification equivalents
    'equivalentTrees', ROUND(COALESCE(v_stats.items_shared, 0) * c_co2_kg_per_item / 21, 2), -- 21kg CO2 per tree/year
    'equivalentCarMiles', ROUND(COALESCE(v_stats.items_shared, 0) * c_co2_kg_per_item / 0.404, 2) -- 0.404kg CO2 per mile
  );
  
  RETURN jsonb_build_object(
    'success', true,
    'userId', v_user_id,
    'completion', v_completion,
    'rank', v_rank,
    'impact', v_impact,
    'ratingAverage', COALESCE(v_stats.rating_average, 0),
    'ratingCount', COALESCE(v_stats.rating_count, 0),
    'calculatedAt', NOW()
  );
END;
$$;


--
-- Name: FUNCTION get_profile_analytics(p_user_id uuid); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.get_profile_analytics(p_user_id uuid) IS 'Returns consolidated profile analytics including completion percentage, community rank, and environmental impact metrics. Single source of truth for all platforms.';


--
-- Name: get_profile_view(uuid, uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_profile_view(p_profile_id uuid, p_viewer_id uuid DEFAULT NULL::uuid) RETURNS jsonb
    LANGUAGE plpgsql STABLE SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
DECLARE
  v_profile record;
  v_listings jsonb;
  v_is_own_profile boolean;
  v_listing_stats record;
  v_shared_rooms integer;
BEGIN
  v_is_own_profile := p_viewer_id IS NOT NULL AND p_profile_id = p_viewer_id;

  -- Get profile data
  SELECT
    p.id,
    p.username,
    p.email,
    p.avatar_url,
    p.bio,
    p.is_active,
    p.items_shared,
    p.rating_average,
    p.rating_count,
    p.dietary_preferences,
    p.created_at,
    p.updated_at
  INTO v_profile
  FROM profiles p
  WHERE p.id = p_profile_id
    AND p.deleted_at IS NULL;

  IF v_profile IS NULL THEN
    RETURN jsonb_build_object(
      'success', false,
      'error', jsonb_build_object('code', 'NOT_FOUND', 'message', 'Profile not found')
    );
  END IF;

  -- Get listing stats
  SELECT
    COUNT(*) FILTER (WHERE is_active = true AND deleted_at IS NULL) AS active_count,
    COUNT(*) FILTER (WHERE is_active = false AND deleted_at IS NULL) AS completed_count,
    COUNT(*) FILTER (WHERE post_type = 'food' AND deleted_at IS NULL) AS food_count,
    COUNT(*) FILTER (WHERE post_type = 'request' AND deleted_at IS NULL) AS request_count
  INTO v_listing_stats
  FROM posts
  WHERE profile_id = p_profile_id;

  -- Get recent listings
  SELECT COALESCE(jsonb_agg(
    jsonb_build_object(
      'id', fi.id,
      'postName', fi.post_name,
      'thumbnail', CASE
        WHEN fi.images IS NOT NULL AND array_length(fi.images, 1) > 0
        THEN fi.images[1]
        ELSE NULL
      END,
      'postType', fi.post_type,
      'isActive', fi.is_active,
      'createdAt', fi.created_at,
      'freshness', CASE
        WHEN fi.created_at > NOW() - INTERVAL '24 hours' THEN 'Today'
        WHEN fi.created_at > NOW() - INTERVAL '7 days' THEN
          EXTRACT(DAY FROM NOW() - fi.created_at)::integer || 'd ago'
        ELSE to_char(fi.created_at, 'Mon DD')
      END
    ) ORDER BY fi.created_at DESC
  ), '[]'::jsonb) INTO v_listings
  FROM (
    SELECT * FROM posts
    WHERE profile_id = p_profile_id
      AND deleted_at IS NULL
      AND (v_is_own_profile OR is_active = true)  -- Show inactive only for own profile
    ORDER BY created_at DESC
    LIMIT 10
  ) fi;

  -- Count shared rooms (conversations) if viewer provided
  IF p_viewer_id IS NOT NULL AND NOT v_is_own_profile THEN
    SELECT COUNT(*) INTO v_shared_rooms
    FROM rooms
    WHERE (sharer = p_profile_id AND requester = p_viewer_id)
       OR (requester = p_profile_id AND sharer = p_viewer_id);
  END IF;

  -- Return complete profile view
  RETURN jsonb_build_object(
    'success', true,
    'profile', jsonb_build_object(
      'id', v_profile.id,
      'username', v_profile.username,
      'avatarUrl', v_profile.avatar_url,
      'bio', v_profile.bio,
      'isActive', v_profile.is_active,
      'memberSince', to_char(v_profile.created_at, 'Mon YYYY'),
      'memberDays', EXTRACT(DAY FROM NOW() - v_profile.created_at)::integer,
      'dietaryPreferences', COALESCE(v_profile.dietary_preferences, '[]'::jsonb)
    ),
    'stats', jsonb_build_object(
      'itemsShared', COALESCE(v_profile.items_shared, 0),
      'itemsSharedDisplay', COALESCE(v_profile.items_shared, 0) || ' items shared',
      'rating', COALESCE(v_profile.rating_average, 0),
      'ratingCount', COALESCE(v_profile.rating_count, 0),
      'ratingDisplay', CASE
        WHEN v_profile.rating_count > 0 THEN
          ROUND(v_profile.rating_average::numeric, 1)::text || '  (' || v_profile.rating_count || ' reviews)'
        ELSE 'New member'
      END,
      'ratingStars', CASE
        WHEN v_profile.rating_count > 0 THEN
          jsonb_build_object(
            'full', FLOOR(v_profile.rating_average)::integer,
            'half', CASE WHEN (v_profile.rating_average - FLOOR(v_profile.rating_average)) >= 0.5 THEN 1 ELSE 0 END,
            'empty', 5 - CEIL(v_profile.rating_average)::integer
          )
        ELSE NULL
      END
    ),
    'listingStats', jsonb_build_object(
      'active', v_listing_stats.active_count,
      'completed', v_listing_stats.completed_count,
      'food', v_listing_stats.food_count,
      'requests', v_listing_stats.request_count
    ),
    'listings', v_listings,
    'listingsHasMore', jsonb_array_length(v_listings) = 10,
    'isOwnProfile', v_is_own_profile,
    'relationship', CASE
      WHEN v_is_own_profile THEN NULL
      WHEN v_shared_rooms > 0 THEN jsonb_build_object(
        'hasConversation', true,
        'conversationCount', v_shared_rooms
      )
      ELSE jsonb_build_object('hasConversation', false)
    END,
    'actions', CASE
      WHEN v_is_own_profile THEN jsonb_build_array(
        jsonb_build_object('label', 'Edit Profile', 'action', 'edit_profile', 'icon', 'edit', 'style', 'primary'),
        jsonb_build_object('label', 'Settings', 'action', 'settings', 'icon', 'settings', 'style', 'secondary'),
        jsonb_build_object('label', 'Share Profile', 'action', 'share', 'icon', 'share', 'style', 'text')
      )
      ELSE jsonb_build_array(
        jsonb_build_object('label', 'Message', 'action', 'message', 'icon', 'message-circle', 'style', 'primary'),
        jsonb_build_object('label', 'View Listings', 'action', 'view_listings', 'icon', 'list', 'style', 'secondary'),
        jsonb_build_object('label', 'Report', 'action', 'report', 'icon', 'flag', 'style', 'danger')
      )
    END,
    'tabs', jsonb_build_array(
      jsonb_build_object('id', 'listings', 'label', 'Listings', 'count', v_listing_stats.active_count),
      jsonb_build_object('id', 'completed', 'label', 'Completed', 'count', v_listing_stats.completed_count)
    ),
    'meta', jsonb_build_object(
      'timestamp', NOW(),
      'cacheTTL', 60,
      'refreshAfter', 300
    )
  );
END;
$$;


--
-- Name: FUNCTION get_profile_view(p_profile_id uuid, p_viewer_id uuid); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.get_profile_view(p_profile_id uuid, p_viewer_id uuid) IS 'BFF endpoint: Returns complete profile view with context-aware actions';


--
-- Name: get_provider_health_summary(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_provider_health_summary() RETURNS TABLE(provider text, circuit_state text, recent_failures integer, is_healthy boolean, today_success_rate numeric, today_avg_latency_ms numeric, quota_used integer, quota_limit integer, quota_remaining integer)
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO ''
    AS $$
BEGIN
  RETURN QUERY
  SELECT
    cb.provider,
    cb.state AS circuit_state,
    cb.failures AS recent_failures,
    (cb.state = 'closed') AS is_healthy,
    COALESCE(pm.success_rate, 0) AS today_success_rate,
    COALESCE(pm.average_latency_ms, 0) AS today_avg_latency_ms,
    COALESCE(q.emails_sent, 0) AS quota_used,
    q.daily_limit AS quota_limit,
    GREATEST(0, q.daily_limit - COALESCE(q.emails_sent, 0)) AS quota_remaining
  FROM email_circuit_breaker_state cb
  LEFT JOIN email_provider_metrics pm
    ON cb.provider = pm.provider AND pm.date = CURRENT_DATE
  LEFT JOIN email_provider_quota q
    ON cb.provider = q.provider AND q.date = CURRENT_DATE
  ORDER BY cb.provider;
END;
$$;


--
-- Name: get_quiet_hours_end(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_quiet_hours_end(p_user_id uuid) RETURNS timestamp with time zone
    LANGUAGE plpgsql STABLE SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
DECLARE
  v_prefs jsonb;
  v_end time;
  v_end_timestamp timestamptz;
BEGIN
  SELECT notification_preferences INTO v_prefs
  FROM profiles
  WHERE id = p_user_id;

  v_end := COALESCE(v_prefs->>'quiet_hours_end', '08:00')::time;

  -- Calculate next occurrence of end time
  v_end_timestamp := CURRENT_DATE + v_end;

  -- If end time has passed today, it's tomorrow
  IF v_end_timestamp <= NOW() THEN
    v_end_timestamp := v_end_timestamp + INTERVAL '1 day';
  END IF;

  RETURN v_end_timestamp;
END;
$$;


SET default_tablespace = '';

SET default_table_access_method = heap;

--
-- Name: email_queue; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.email_queue (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    recipient_id uuid,
    recipient_email text NOT NULL,
    email_type text NOT NULL,
    template_name text NOT NULL,
    template_data jsonb DEFAULT '{}'::jsonb NOT NULL,
    attempts integer DEFAULT 0,
    max_attempts integer DEFAULT 3,
    status text DEFAULT 'queued'::text,
    last_error text,
    next_retry_at timestamp with time zone,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    CONSTRAINT email_queue_attempts_check CHECK ((attempts >= 0)),
    CONSTRAINT email_queue_email_type_check CHECK ((email_type = ANY (ARRAY['auth'::text, 'chat'::text, 'food_listing'::text, 'feedback'::text, 'review_reminder'::text]))),
    CONSTRAINT email_queue_max_attempts_check CHECK ((max_attempts > 0)),
    CONSTRAINT email_queue_status_check CHECK ((status = ANY (ARRAY['queued'::text, 'processing'::text, 'failed'::text, 'completed'::text])))
);


--
-- Name: TABLE email_queue; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE public.email_queue IS 'Queue for failed emails with retry logic and exponential backoff';


--
-- Name: get_ready_emails(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_ready_emails(p_limit integer DEFAULT 50) RETURNS SETOF public.email_queue
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO ''
    AS $$
BEGIN
  RETURN QUERY
  SELECT *
  FROM public.email_queue
  WHERE status IN ('pending', 'queued')
    AND (next_retry_at IS NULL OR next_retry_at <= NOW())
    AND attempts < max_attempts
  ORDER BY
    CASE email_type
      WHEN 'auth' THEN 0
      WHEN 'chat' THEN 1
      ELSE 2
    END,
    created_at ASC
  LIMIT p_limit
  FOR UPDATE SKIP LOCKED;
END;
$$;


--
-- Name: get_recent_critical_audit_events(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_recent_critical_audit_events(hours integer DEFAULT 24) RETURNS TABLE(event_type text, user_id uuid, target_email text, action text, details jsonb, created_at timestamp with time zone)
    LANGUAGE sql STABLE SECURITY DEFINER
    AS $$
  SELECT event_type, user_id, target_email, action, details, created_at
  FROM email_audit_log
  WHERE severity = 'critical'
  AND created_at > NOW() - (hours || ' hours')::INTERVAL
  ORDER BY created_at DESC;
$$;


--
-- Name: FUNCTION get_recent_critical_audit_events(hours integer); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.get_recent_critical_audit_events(hours integer) IS 'Get critical audit events from the last N hours';


--
-- Name: get_reputation_leaderboard(text, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_reputation_leaderboard(p_period text DEFAULT 'all_time'::text, p_limit integer DEFAULT 20) RETURNS TABLE(rank bigint, profile_id uuid, username text, avatar_url text, total_points integer, period_points integer, level_title text, level_color text)
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
BEGIN
  RETURN QUERY
  SELECT ROW_NUMBER() OVER (ORDER BY CASE p_period WHEN 'weekly' THEN ur.points_this_week WHEN 'monthly' THEN ur.points_this_month ELSE ur.total_points END DESC) AS rank,
    ur.profile_id, p.nickname AS username, p.avatar_url, ur.total_points,
    CASE p_period WHEN 'weekly' THEN ur.points_this_week WHEN 'monthly' THEN ur.points_this_month ELSE ur.total_points END AS period_points,
    ur.level_title, rl.color AS level_color
  FROM forum_user_reputation ur
  JOIN profiles p ON p.id = ur.profile_id
  LEFT JOIN forum_reputation_levels rl ON rl.level = ur.reputation_level
  WHERE ur.total_points > 0
  ORDER BY period_points DESC LIMIT p_limit;
END;
$$;


--
-- Name: get_resend_api_key(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_resend_api_key() RETURNS text
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
BEGIN
  RETURN vault.read_secret('RESEND_API_KEY');
END;
$$;


--
-- Name: get_reviews_with_average(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_reviews_with_average(p_post_id integer) RETURNS jsonb
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
DECLARE
  v_reviews JSONB;
  v_average_rating NUMERIC;
  v_total_count INTEGER;
BEGIN
  -- Get average rating
  SELECT 
    COALESCE(AVG(reviewed_rating)::NUMERIC(3,2), 0),
    COUNT(*)
  INTO v_average_rating, v_total_count
  FROM reviews
  WHERE post_id = p_post_id;

  -- Get reviews with reviewer profile
  SELECT COALESCE(jsonb_agg(
    jsonb_build_object(
      'id', r.id,
      'post_id', r.post_id,
      'reviewed_user_id', r.reviewed_user_id,
      'reviewer_user_id', r.reviewer_user_id,
      'reviewed_rating', r.reviewed_rating,
      'reviewed_comment', r.reviewed_comment,
      'created_at', r.created_at,
      'updated_at', r.updated_at,
      'reviewer_profile', CASE 
        WHEN r.reviewer_user_id IS NOT NULL THEN (
          SELECT jsonb_build_object(
            'id', p.id,
            'nickname', p.nickname,
            'avatar_url', p.avatar_url
          )
          FROM profiles p
          WHERE p.id = r.reviewer_user_id
        )
        ELSE NULL
      END
    ) ORDER BY r.created_at DESC
  ), '[]'::jsonb)
  INTO v_reviews
  FROM reviews r
  WHERE r.post_id = p_post_id;

  RETURN jsonb_build_object(
    'reviews', v_reviews,
    'average_rating', v_average_rating,
    'total_count', v_total_count
  );
END;
$$;


--
-- Name: get_search_screen_data(uuid, text, text, double precision, double precision, double precision, bigint, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_search_screen_data(p_user_id uuid DEFAULT NULL::uuid, p_query text DEFAULT NULL::text, p_search_type text DEFAULT 'all'::text, p_latitude double precision DEFAULT NULL::double precision, p_longitude double precision DEFAULT NULL::double precision, p_radius_km double precision DEFAULT 50, p_category_id bigint DEFAULT NULL::bigint, p_limit integer DEFAULT 20, p_offset integer DEFAULT 0) RETURNS jsonb
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public', 'extensions'
    AS $$
DECLARE
  v_result jsonb;
  v_listings jsonb := '[]'::jsonb;
  v_users jsonb := '[]'::jsonb;
  v_forum_posts jsonb := '[]'::jsonb;
  v_suggestions jsonb := '[]'::jsonb;
  v_trending jsonb := '[]'::jsonb;
  v_recent_searches jsonb := '[]'::jsonb;
  v_has_query boolean;
  v_total_count integer := 0;
BEGIN
  v_has_query := p_query IS NOT NULL AND length(trim(p_query)) > 0;

  -- If no query, return suggestions and trending
  IF NOT v_has_query THEN
    -- Get trending searches (from search_history if exists, otherwise empty)
    BEGIN
      SELECT COALESCE(jsonb_agg(
        jsonb_build_object(
          'query', query,
          'count', search_count
        )
        ORDER BY search_count DESC
      ), '[]'::jsonb)
      INTO v_trending
      FROM (
        SELECT query, COUNT(*) as search_count
        FROM search_history
        WHERE searched_at > NOW() - INTERVAL '7 days'
        GROUP BY query
        ORDER BY search_count DESC
        LIMIT 10
      ) t;
    EXCEPTION WHEN undefined_table THEN
      v_trending := '[]'::jsonb;
    END;

    -- Get recent searches for user
    IF p_user_id IS NOT NULL THEN
      BEGIN
        SELECT COALESCE(jsonb_agg(
          jsonb_build_object(
            'query', query,
            'searchedAt', searched_at
          )
          ORDER BY searched_at DESC
        ), '[]'::jsonb)
        INTO v_recent_searches
        FROM (
          SELECT DISTINCT ON (query) query, searched_at
          FROM search_history
          WHERE user_id = p_user_id
          ORDER BY query, searched_at DESC
          LIMIT 10
        ) t;
      EXCEPTION WHEN undefined_table THEN
        v_recent_searches := '[]'::jsonb;
      END;
    END IF;

    RETURN jsonb_build_object(
      'success', true,
      'hasQuery', false,
      'suggestions', v_suggestions,
      'trending', v_trending,
      'recentSearches', v_recent_searches
    );
  END IF;

  -- Search listings
  IF p_search_type IN ('all', 'listings') THEN
    WITH listing_results AS (
      SELECT 
        p.id,
        p.post_name as title,
        p.post_description as description,
        p.images[1] as image,
        p.post_type,
        p.quantity,
        NULL::text as unit,
        NULL::timestamptz as expires_at,
        COALESCE(p.post_views, 0) as views_count,
        p.created_at,
        pr.id as author_id,
        COALESCE(pr.nickname, pr.first_name, 'User') as author_name,
        pr.avatar_url as author_avatar,
        CASE 
          WHEN p_latitude IS NOT NULL AND p_longitude IS NOT NULL AND p.location IS NOT NULL THEN
            extensions.ST_Distance(
              p.location::extensions.geography,
              extensions.ST_SetSRID(extensions.ST_MakePoint(p_longitude, p_latitude), 4326)::extensions.geography
            ) / 1000
          ELSE NULL
        END as distance_km
      FROM posts p
      JOIN profiles pr ON p.profile_id = pr.id
      WHERE p.is_active = true
        AND (
          p.post_name ILIKE '%' || p_query || '%'
          OR p.post_description ILIKE '%' || p_query || '%'
          OR p.post_address ILIKE '%' || p_query || '%'
        )
        AND (p_category_id IS NULL OR p.category_id = p_category_id)
        AND (
          p_latitude IS NULL OR p_longitude IS NULL OR p.location IS NULL
          OR extensions.ST_DWithin(
            p.location::extensions.geography,
            extensions.ST_SetSRID(extensions.ST_MakePoint(p_longitude, p_latitude), 4326)::extensions.geography,
            p_radius_km * 1000
          )
        )
      ORDER BY p.created_at DESC
      LIMIT p_limit OFFSET p_offset
    )
    SELECT COALESCE(jsonb_agg(
      jsonb_build_object(
        'id', id,
        'title', title,
        'description', description,
        'image', image,
        'postType', post_type,
        'quantity', quantity,
        'unit', unit,
        'expiresAt', expires_at,
        'viewsCount', views_count,
        'distance', distance_km,
        'createdAt', created_at,
        'author', jsonb_build_object(
          'id', author_id,
          'name', author_name,
          'avatar', author_avatar
        )
      )
    ), '[]'::jsonb)
    INTO v_listings
    FROM listing_results;
  END IF;

  -- Search users
  IF p_search_type IN ('all', 'users') THEN
    WITH user_results AS (
      SELECT 
        pr.id,
        COALESCE(pr.nickname, pr.first_name, 'User') as name,
        pr.avatar_url as avatar,
        pr.bio,
        COALESCE(pr.is_verified, false) as is_verified,
        (SELECT COUNT(*) FROM posts WHERE profile_id = pr.id AND is_active = true) as listings_count,
        NULL::double precision as rating
      FROM profiles pr
      WHERE (
        pr.nickname ILIKE '%' || p_query || '%'
        OR pr.first_name ILIKE '%' || p_query || '%'
        OR pr.second_name ILIKE '%' || p_query || '%'
        OR pr.bio ILIKE '%' || p_query || '%'
      )
      ORDER BY listings_count DESC
      LIMIT p_limit OFFSET p_offset
    )
    SELECT COALESCE(jsonb_agg(
      jsonb_build_object(
        'id', id,
        'name', name,
        'avatar', avatar,
        'bio', bio,
        'isVerified', is_verified,
        'listingsCount', listings_count,
        'rating', rating
      )
    ), '[]'::jsonb)
    INTO v_users
    FROM user_results;
  END IF;

  -- Search forum posts
  IF p_search_type IN ('all', 'forum') THEN
    BEGIN
      WITH forum_results AS (
        SELECT 
          fp.id,
          fp.title,
          fp.description,
          fp.image,
          COALESCE(fp.comments_count, 0) as comments_count,
          fp.likes_count,
          fp.slug,
          fc.name as category_name,
          fp.created_at,
          pr.id as author_id,
          COALESCE(pr.nickname, pr.first_name, 'User') as author_name,
          pr.avatar_url as author_avatar
        FROM forum_posts fp
        LEFT JOIN forum_categories fc ON fp.category_id = fc.id
        LEFT JOIN profiles pr ON fp.profile_id = pr.id
        WHERE fp.is_published = true
          AND (
            fp.title ILIKE '%' || p_query || '%'
            OR fp.description ILIKE '%' || p_query || '%'
            OR fp.content ILIKE '%' || p_query || '%'
          )
        ORDER BY fp.created_at DESC
        LIMIT p_limit OFFSET p_offset
      )
      SELECT COALESCE(jsonb_agg(
        jsonb_build_object(
          'id', id,
          'title', title,
          'description', description,
          'image', image,
          'commentsCount', comments_count,
          'likesCount', likes_count,
          'slug', slug,
          'categoryName', category_name,
          'createdAt', created_at,
          'author', jsonb_build_object(
            'id', author_id,
            'name', author_name,
            'avatar', author_avatar
          )
        )
      ), '[]'::jsonb)
      INTO v_forum_posts
      FROM forum_results;
    EXCEPTION WHEN undefined_table THEN
      v_forum_posts := '[]'::jsonb;
    END;
  END IF;

  -- Record search if user is logged in
  IF p_user_id IS NOT NULL THEN
    BEGIN
      INSERT INTO search_history (user_id, query, searched_at)
      VALUES (p_user_id, p_query, NOW())
      ON CONFLICT DO NOTHING;
    EXCEPTION WHEN undefined_table THEN
      NULL; -- Ignore if table doesn't exist
    END;
  END IF;

  -- Build result
  RETURN jsonb_build_object(
    'success', true,
    'hasQuery', true,
    'query', p_query,
    'listings', v_listings,
    'users', v_users,
    'forumPosts', v_forum_posts,
    'pagination', jsonb_build_object(
      'limit', p_limit,
      'offset', p_offset,
      'hasMore', (
        jsonb_array_length(v_listings) = p_limit 
        OR jsonb_array_length(v_users) = p_limit 
        OR jsonb_array_length(v_forum_posts) = p_limit
      )
    )
  );
END;
$$;


--
-- Name: FUNCTION get_search_screen_data(p_user_id uuid, p_query text, p_search_type text, p_latitude double precision, p_longitude double precision, p_radius_km double precision, p_category_id bigint, p_limit integer, p_offset integer); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.get_search_screen_data(p_user_id uuid, p_query text, p_search_type text, p_latitude double precision, p_longitude double precision, p_radius_km double precision, p_category_id bigint, p_limit integer, p_offset integer) IS 'BFF function for search screen - returns listings, users, forum posts, and suggestions in one call';


--
-- Name: get_search_suggestions(text, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_search_suggestions(p_partial_query text, p_limit integer DEFAULT 5) RETURNS TABLE(query text, search_count integer)
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
BEGIN
  RETURN QUERY
  SELECT ps.query, ps.search_count
  FROM forum_popular_searches ps
  WHERE ps.query LIKE lower(trim(p_partial_query)) || '%'
  ORDER BY ps.search_count DESC
  LIMIT p_limit;
END;
$$;


--
-- Name: get_secret_audited(text, uuid, jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_secret_audited(secret_name text, requesting_user_id uuid DEFAULT auth.uid(), request_metadata jsonb DEFAULT '{}'::jsonb) RETURNS text
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO ''
    AS $$
DECLARE
  secret_value text;
  user_role text;
  allowed_secrets text[];
  access_granted boolean := false;
BEGIN
  -- Get user role from user_roles table (joined with roles)
  SELECT r.name INTO user_role
  FROM public.user_roles ur
  JOIN public.roles r ON ur.role_id = r.id
  WHERE ur.profile_id = requesting_user_id
  LIMIT 1;

  allowed_secrets := ARRAY[
    'UPSTASH_REDIS_URL', 'UPSTASH_REDIS_TOKEN', 'RESEND_API_KEY',
    'OPENAI_API_KEY', 'REVENUECAT_IOS_PUBLIC_KEY', 'REVENUECAT_ANDROID_PUBLIC_KEY'
  ];

  IF secret_name = ANY(allowed_secrets) THEN
    SELECT decrypted_secret INTO secret_value
    FROM vault.decrypted_secrets WHERE name = secret_name;
    access_granted := (secret_value IS NOT NULL);
  END IF;

  INSERT INTO audit.vault_access_log (user_id, user_role, secret_name, access_granted, access_method, ip_address, user_agent, request_id)
  VALUES (requesting_user_id, COALESCE(user_role, 'unknown'), secret_name, access_granted, 'rpc',
    (request_metadata->>'ip_address')::inet, request_metadata->>'user_agent', request_metadata->>'request_id');

  RETURN secret_value;
END;
$$;


--
-- Name: FUNCTION get_secret_audited(secret_name text, requesting_user_id uuid, request_metadata jsonb); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.get_secret_audited(secret_name text, requesting_user_id uuid, request_metadata jsonb) IS 'Securely fetch secrets from Supabase Vault with comprehensive audit logging.

SECURITY:
- ONLY accessible by service_role (Edge Functions)
- NOT accessible by iOS app, Android app, or web clients
- NOT accessible by authenticated users
- Implements whitelist of allowed secrets
- Logs all access attempts (success and failure)

USAGE (Edge Functions only):
  const secret = await supabase.rpc("get_secret_audited", {
    secret_name: "UPSTASH_REDIS_URL",
    requesting_user_id: user.id,
    request_metadata: {
      ip_address: req.headers.get("x-forwarded-for"),
      user_agent: req.headers.get("user-agent"),
      request_id: crypto.randomUUID()
    }
  });

AUDIT:
- All calls logged to audit.vault_access_log
- Includes user_id, secret_name, timestamp, IP, user agent
- Failed attempts logged for security monitoring

PARAMETERS:
- secret_name: Name of secret to retrieve (must be in whitelist)
- requesting_user_id: UUID of user making request (defaults to auth.uid())
- request_metadata: JSONB with ip_address, user_agent, request_id

RETURNS:
- Secret value (text) if authorized and found
- NULL if unauthorized or not found';


--
-- Name: get_secrets(text[]); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_secrets(secret_names text[]) RETURNS TABLE(name text, value text)
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO ''
    AS $$
DECLARE
  secret_name text;
  secret_value text;
BEGIN
  -- Loop through each requested secret name
  FOREACH secret_name IN ARRAY secret_names
  LOOP
    BEGIN
      -- Fetch secret from Supabase Vault
      SELECT decrypted_secret INTO secret_value
      FROM vault.decrypted_secrets
      WHERE vault.decrypted_secrets.name = secret_name
      LIMIT 1;

      -- Return the secret if found
      IF secret_value IS NOT NULL THEN
        name := secret_name;
        value := secret_value;
        RETURN NEXT;
      END IF;
    EXCEPTION WHEN OTHERS THEN
      -- Log error but continue with other secrets
      RAISE WARNING 'Failed to fetch secret %: %', secret_name, SQLERRM;
    END;
  END LOOP;

  RETURN;
END;
$$;


--
-- Name: FUNCTION get_secrets(secret_names text[]); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.get_secrets(secret_names text[]) IS 'Batch fetch multiple secrets from Supabase Vault for email provider configuration';


--
-- Name: get_service_config(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_service_config() RETURNS jsonb
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
BEGIN
  -- Return ONLY non-sensitive configuration
  -- This tells the app what features are available
  -- WITHOUT exposing credentials or secrets
  RETURN jsonb_build_object(
    'version', '1.0.0',
    'features', jsonb_build_object(
      'redis_caching_enabled', true,
      'email_notifications_enabled', true,
      'ai_features_enabled', false,
      'push_notifications_enabled', true,
      'real_time_enabled', true
    ),
    'cache', jsonb_build_object(
      'default_ttl_seconds', 3600,
      'max_ttl_seconds', 86400
    ),
    'uploads', jsonb_build_object(
      'max_file_size_mb', 10,
      'supported_image_formats', jsonb_build_array('jpg', 'jpeg', 'png', 'heic', 'webp'),
      'max_images_per_listing', 5
    ),
    'rate_limits', jsonb_build_object(
      'cache_requests_per_minute', 60,
      'email_requests_per_hour', 10,
      'api_requests_per_minute', 100,
      'search_requests_per_minute', 30
    ),
    'search', jsonb_build_object(
      'max_radius_km', 100,
      'default_radius_km', 10,
      'max_results', 100
    )
  );
END;
$$;


--
-- Name: FUNCTION get_service_config(); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.get_service_config() IS 'Returns non-sensitive service configuration for mobile apps.

SECURITY:
- Safe to call from iOS/Android/Web
- Does NOT expose secrets or credentials
- Only returns feature flags and rate limits

USAGE (iOS):
  let config = try await supabase.rpc("get_service_config").execute()
  let cacheEnabled = config["features"]["redis_caching_enabled"]

RETURNS:
- JSONB with service configuration
- Feature flags
- Rate limits
- Upload limits
- Non-sensitive settings';


--
-- Name: get_threaded_comments(bigint); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_threaded_comments(p_forum_id bigint) RETURNS TABLE(id bigint, comment text, user_id uuid, parent_id bigint, depth integer, likes_count integer, replies_count integer, created_at timestamp with time zone, path bigint[])
    LANGUAGE plpgsql STABLE
    SET search_path TO ''
    AS $$
BEGIN
  RETURN QUERY
  WITH RECURSIVE comment_tree AS (
    -- Base case: top-level comments
    SELECT 
      c.id,
      c.comment,
      c.user_id,
      c.parent_id,
      c.depth,
      c.likes_count,
      c.replies_count,
      c.comment_created_at,
      ARRAY[c.id] AS path
    FROM public.comments c
    WHERE c.forum_id = p_forum_id AND c.parent_id IS NULL
    
    UNION ALL
    
    -- Recursive case: child comments
    SELECT 
      c.id,
      c.comment,
      c.user_id,
      c.parent_id,
      c.depth,
      c.likes_count,
      c.replies_count,
      c.comment_created_at,
      ct.path || c.id
    FROM public.comments c
    JOIN comment_tree ct ON c.parent_id = ct.id
  )
  SELECT 
    ct.id,
    ct.comment,
    ct.user_id,
    ct.parent_id,
    ct.depth,
    ct.likes_count,
    ct.replies_count,
    ct.comment_created_at,
    ct.path
  FROM comment_tree ct
  ORDER BY ct.path;
END;
$$;


--
-- Name: FUNCTION get_threaded_comments(p_forum_id bigint); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.get_threaded_comments(p_forum_id bigint) IS 'Returns comments in threaded order with path';


--
-- Name: get_translation_changes_since(character varying, timestamp with time zone); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_translation_changes_since(p_locale character varying, p_since timestamp with time zone) RETURNS TABLE(key_path text, new_value text, change_type character varying, changed_at timestamp with time zone)
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
BEGIN
  RETURN QUERY
  SELECT 
    tcl.key_path,
    tcl.new_value,
    tcl.change_type,
    tcl.created_at as changed_at
  FROM translation_change_log tcl
  WHERE tcl.locale = p_locale
    AND tcl.created_at > p_since
  ORDER BY tcl.created_at ASC;
END;
$$;


--
-- Name: get_translation_stats(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_translation_stats() RETURNS TABLE(locale character varying, message_count integer, version character varying, last_updated timestamp with time zone, size_bytes integer)
    LANGUAGE sql STABLE
    SET search_path TO ''
    AS $$
  SELECT 
    t.locale::VARCHAR,
    (SELECT count(*)::INTEGER FROM jsonb_object_keys(t.messages)),
    t.version::VARCHAR,
    t.updated_at,
    pg_column_size(t.messages)::INTEGER
  FROM translations t
  ORDER BY t.locale;
$$;


--
-- Name: get_translation_stats(text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_translation_stats(p_locale text DEFAULT NULL::text) RETURNS TABLE(target_locale text, total_translations bigint, total_hits bigint, avg_quality numeric, cache_size_mb numeric)
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
BEGIN
    RETURN QUERY
    SELECT
        dct.target_locale,
        COUNT(*),
        SUM(dct.hit_count),
        AVG(dct.quality_score),
        (SUM(LENGTH(dct.source_text) + LENGTH(dct.translated_text)) / 1048576.0)::DECIMAL(10,2)
    FROM dynamic_content_translations dct
    WHERE dct.expires_at > NOW()
      AND (p_locale IS NULL OR dct.target_locale = p_locale)
    GROUP BY dct.target_locale
    ORDER BY COUNT(*) DESC;
END;
$$;


--
-- Name: get_translation_usage(text, text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_translation_usage(p_service text, p_month text) RETURNS TABLE(chars_used bigint, free_limit bigint, remaining bigint)
    LANGUAGE plpgsql
    AS $$
BEGIN
  RETURN QUERY
  SELECT 
    COALESCE(tsu.chars_used, 0) as chars_used,
    COALESCE(tsu.free_limit, 
      CASE p_service
        WHEN 'deepl' THEN 500000
        WHEN 'google' THEN 500000
        WHEN 'microsoft' THEN 2000000
        WHEN 'amazon' THEN 2000000
        ELSE 500000
      END
    ) as free_limit,
    COALESCE(tsu.free_limit, 
      CASE p_service
        WHEN 'deepl' THEN 500000
        WHEN 'google' THEN 500000
        WHEN 'microsoft' THEN 2000000
        WHEN 'amazon' THEN 2000000
        ELSE 500000
      END
    ) - COALESCE(tsu.chars_used, 0) as remaining
  FROM (SELECT 1) dummy
  LEFT JOIN translation_service_usage tsu 
    ON tsu.service_name = p_service AND tsu.month_year = p_month;
END;
$$;


--
-- Name: get_translations_batch(text[], text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_translations_batch(p_texts text[], p_target_locale text) RETURNS TABLE(source_text text, translated_text text, quality_score numeric)
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
BEGIN
  RETURN QUERY
  WITH text_hashes AS (
    SELECT 
      unnest(p_texts) AS src_text,
      encode(sha256(unnest(p_texts)::bytea), 'hex') AS content_hash
  )
  SELECT 
    th.src_text,
    dct.translated_text,
    dct.quality_score
  FROM text_hashes th
  LEFT JOIN dynamic_content_translations dct 
    ON dct.content_hash = th.content_hash
    AND dct.target_locale = p_target_locale
    AND dct.expires_at > NOW();
    
  -- Update hit counts for found translations (fire-and-forget)
  UPDATE dynamic_content_translations
  SET hit_count = hit_count + 1, last_hit_at = NOW()
  WHERE content_hash = ANY(
    SELECT encode(sha256(unnest(p_texts)::bytea), 'hex')
  )
  AND target_locale = p_target_locale
  AND expires_at > NOW();
END;
$$;


--
-- Name: FUNCTION get_translations_batch(p_texts text[], p_target_locale text); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.get_translations_batch(p_texts text[], p_target_locale text) IS 'Batch lookup translations for multiple texts in a single query';


--
-- Name: get_trending_items(double precision, double precision, double precision, integer, text, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_trending_items(p_latitude double precision, p_longitude double precision, p_radius_km double precision DEFAULT 25, p_limit integer DEFAULT 10, p_post_type text DEFAULT NULL::text, p_urgency_threshold_hours integer DEFAULT 48) RETURNS jsonb
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
DECLARE
  v_search_radius_m DOUBLE PRECISION;
  v_result JSONB;
BEGIN
  -- Convert km to meters for PostGIS, 2x radius for trending (wider search)
  v_search_radius_m := p_radius_km * 1000 * 2;
  
  WITH trending_posts AS (
    SELECT 
      p.*,
      -- Engagement score: views + likes*2
      COALESCE(p.post_views, 0) + 
      COALESCE(p.post_like_counter, 0) * 2 AS engagement_score,
      -- Distance in km
      ROUND((extensions.ST_Distance(
        p.location,
        extensions.ST_SetSRID(extensions.ST_MakePoint(p_longitude, p_latitude), 4326)::extensions.geography
      ) / 1000)::NUMERIC, 2) AS distance_km,
      -- Urgency flag: available and older than threshold
      CASE 
        WHEN p.is_arranged = FALSE 
             AND p.created_at < NOW() - (p_urgency_threshold_hours || ' hours')::INTERVAL
        THEN TRUE
        ELSE FALSE
      END AS is_urgent,
      -- Age in hours for freshness
      EXTRACT(EPOCH FROM (NOW() - p.created_at)) / 3600 AS age_hours
    FROM posts p
    WHERE 
      extensions.ST_DWithin(
        p.location,
        extensions.ST_SetSRID(extensions.ST_MakePoint(p_longitude, p_latitude), 4326)::extensions.geography,
        v_search_radius_m
      )
      AND p.is_arranged = FALSE
      AND (p_post_type IS NULL OR p.post_type = p_post_type)
      AND p.is_active = TRUE
      AND p.location IS NOT NULL
    ORDER BY engagement_score DESC, p.created_at DESC
    LIMIT p_limit
  )
  SELECT jsonb_build_object(
    'success', true,
    'trending', COALESCE(
      jsonb_agg(
        jsonb_build_object(
          'id', tp.id,
          'postName', tp.post_name,
          'postType', tp.post_type,
          'postDescription', tp.post_description,
          'postAddress', tp.post_address,
          'postStrippedAddress', tp.post_stripped_address,
          'images', tp.images,
          'engagementScore', tp.engagement_score,
          'distanceKm', tp.distance_km,
          'isUrgent', tp.is_urgent,
          'ageHours', ROUND(tp.age_hours::NUMERIC, 1),
          'postViews', COALESCE(tp.post_views, 0),
          'postLikeCounter', COALESCE(tp.post_like_counter, 0),
          'profileId', tp.profile_id,
          'createdAt', tp.created_at,
          'categoryId', tp.category_id,
          'pickupTime', tp.pickup_time
        ) ORDER BY tp.engagement_score DESC
      ),
      '[]'::jsonb
    ),
    'metadata', jsonb_build_object(
      'searchRadiusKm', p_radius_km * 2,
      'resultCount', (SELECT COUNT(*) FROM trending_posts),
      'calculatedAt', NOW(),
      'urgentCount', (SELECT COUNT(*) FROM trending_posts WHERE is_urgent = TRUE)
    )
  ) INTO v_result
  FROM trending_posts tp;
  
  RETURN v_result;
END;
$$;


--
-- Name: FUNCTION get_trending_items(p_latitude double precision, p_longitude double precision, p_radius_km double precision, p_limit integer, p_post_type text, p_urgency_threshold_hours integer); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.get_trending_items(p_latitude double precision, p_longitude double precision, p_radius_km double precision, p_limit integer, p_post_type text, p_urgency_threshold_hours integer) IS 'Returns trending food items based on engagement scoring (views + likes*2). Includes urgency detection for items older than threshold.';


--
-- Name: get_trending_posts(integer, integer, integer, double precision, double precision, double precision); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_trending_posts(p_limit integer DEFAULT 20, p_offset integer DEFAULT 0, p_hours_window integer DEFAULT 24, p_latitude double precision DEFAULT NULL::double precision, p_longitude double precision DEFAULT NULL::double precision, p_radius_km double precision DEFAULT NULL::double precision) RETURNS jsonb
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public', 'extensions'
    AS $$
DECLARE
    v_result JSONB;
BEGIN
    p_limit := LEAST(p_limit, 100);

    WITH trending_scores AS (
        SELECT 
            p.id,
            p.post_name,
            p.post_description,
            p.images,
            p.post_type,
            (p.location_json->'coordinates'->>1)::DOUBLE PRECISION as latitude,
            (p.location_json->'coordinates'->>0)::DOUBLE PRECISION as longitude,
            p.post_address,
            p.profile_id,
            p.created_at,
            COALESCE(p.post_views, 0) as view_count,
            COALESCE(p.post_like_counter, 0) as like_count,
            COALESCE((
                SELECT COUNT(*) 
                FROM post_views pv 
                WHERE pv.post_id = p.id 
                AND pv.created_at > NOW() - (p_hours_window || ' hours')::INTERVAL
            ), 0) as recent_views_score,
            COALESCE((
                SELECT COUNT(*) * 2 
                FROM likes l 
                WHERE l.post_id = p.id 
                AND l.challenge_id = 0 
                AND l.forum_id = 0
                AND l.created_at > NOW() - (p_hours_window || ' hours')::INTERVAL
            ), 0) as recent_likes_score,
            GREATEST(0, 1 - EXTRACT(EPOCH FROM (NOW() - p.created_at)) / (p_hours_window * 3600 * 7)) as freshness_score,
            CASE 
                WHEN p_latitude IS NOT NULL AND p_longitude IS NOT NULL AND p.location IS NOT NULL THEN
                    ST_Distance(
                        p.location,
                        ST_MakePoint(p_longitude, p_latitude)::geography
                    ) / 1000
                ELSE NULL
            END as distance_km
        FROM posts p
        WHERE p.is_active = true
        AND p.is_arranged = false
        AND (
            p_latitude IS NULL 
            OR p_longitude IS NULL 
            OR p_radius_km IS NULL
            OR p.location IS NULL
            OR ST_DWithin(
                p.location,
                ST_MakePoint(p_longitude, p_latitude)::geography,
                p_radius_km * 1000
            )
        )
    ),
    ranked_posts AS (
        SELECT 
            ts.*,
            (
                ts.recent_views_score + 
                ts.recent_likes_score * 2.0 + 
                ts.freshness_score * 3.0 +
                CASE WHEN ts.view_count > 0 
                    THEN (ts.like_count::FLOAT / ts.view_count) * 5.0 
                    ELSE 0 
                END
            ) as trending_score
        FROM trending_scores ts
    )
    SELECT jsonb_agg(
        jsonb_build_object(
            'id', rp.id,
            'post_name', rp.post_name,
            'post_description', rp.post_description,
            'images', rp.images,
            'post_type', rp.post_type,
            'latitude', rp.latitude,
            'longitude', rp.longitude,
            'post_address', rp.post_address,
            'profile_id', rp.profile_id,
            'created_at', rp.created_at,
            'view_count', rp.view_count,
            'like_count', rp.like_count,
            'trending_score', ROUND(rp.trending_score::NUMERIC, 2),
            'distance_km', ROUND(rp.distance_km::NUMERIC, 2)
        )
        ORDER BY rp.trending_score DESC
    )
    INTO v_result
    FROM (
        SELECT * FROM ranked_posts
        ORDER BY trending_score DESC
        LIMIT p_limit OFFSET p_offset
    ) rp;

    RETURN jsonb_build_object(
        'success', true,
        'posts', COALESCE(v_result, '[]'::JSONB),
        'window_hours', p_hours_window
    );

EXCEPTION WHEN OTHERS THEN
    RETURN jsonb_build_object(
        'success', false,
        'error', jsonb_build_object(
            'code', 'SERVER_ERROR',
            'message', SQLERRM
        )
    );
END;
$$;


--
-- Name: get_trending_searches(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_trending_searches(p_limit integer DEFAULT 10) RETURNS TABLE(query text, search_count integer, last_searched_at timestamp with time zone)
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
BEGIN
  RETURN QUERY
  SELECT ps.query, ps.search_count, ps.last_searched_at
  FROM forum_popular_searches ps
  WHERE ps.last_searched_at > now() - INTERVAL '7 days'
  ORDER BY ps.search_count DESC
  LIMIT p_limit;
END;
$$;


--
-- Name: get_trust_limits(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_trust_limits(p_profile_id uuid) RETURNS jsonb
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
DECLARE
  v_trust_level INTEGER;
  v_limits RECORD;
  v_today_posts INTEGER;
  v_today_topics INTEGER;
  v_today_likes INTEGER;
BEGIN
  SELECT COALESCE(trust_level, 0) INTO v_trust_level 
  FROM forum_user_stats 
  WHERE profile_id = p_profile_id;
  
  v_trust_level := COALESCE(v_trust_level, 0);
  
  SELECT * INTO v_limits FROM forum_trust_levels WHERE level = v_trust_level;
  
  -- Count today's activity
  SELECT COUNT(*) INTO v_today_posts
  FROM comments c
  WHERE c.user_id = p_profile_id
  AND c.comment_created_at > CURRENT_DATE;
  
  SELECT COUNT(*) INTO v_today_topics
  FROM forum f
  WHERE f.profile_id = p_profile_id
  AND f.forum_post_created_at > CURRENT_DATE;
  
  SELECT COUNT(*) INTO v_today_likes
  FROM likes l
  WHERE l.profile_id = p_profile_id
  AND l.created_at > CURRENT_DATE;
  
  RETURN jsonb_build_object(
    'trust_level', v_trust_level,
    'level_name', v_limits.name,
    'posts', jsonb_build_object('used', v_today_posts, 'max', v_limits.max_posts_per_day),
    'topics', jsonb_build_object('used', v_today_topics, 'max', v_limits.max_topics_per_day),
    'likes', jsonb_build_object('used', v_today_likes, 'max', v_limits.max_likes_per_day),
    'permissions', jsonb_build_object(
      'can_flag', v_limits.can_flag,
      'can_upload_images', v_limits.can_upload_images,
      'can_post_links', v_limits.can_post_links,
      'can_mention_users', v_limits.can_mention_users,
      'can_send_messages', v_limits.can_send_messages,
      'can_create_polls', v_limits.can_create_polls
    )
  );
END;
$$;


--
-- Name: get_uncompressed_large_images(text, bigint, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_uncompressed_large_images(p_bucket text, p_min_size bigint, p_limit integer DEFAULT 10) RETURNS TABLE(name text, bucket_id text, metadata jsonb)
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO ''
    AS $$
BEGIN
  RETURN QUERY
  SELECT 
    o.name,
    o.bucket_id,
    o.metadata
  FROM storage.objects o
  LEFT JOIN public.compressed_images ci 
    ON ci.bucket_id = o.bucket_id AND ci.object_path = o.name
  WHERE o.bucket_id = p_bucket
    AND (o.metadata->>'mimetype') LIKE 'image/%'
    AND (o.metadata->>'size')::bigint > p_min_size
    AND ci.id IS NULL  -- Not yet compressed
  ORDER BY (o.metadata->>'size')::bigint DESC
  LIMIT p_limit;
END;
$$;


--
-- Name: get_underserved_users(uuid, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_underserved_users(p_campaign_id uuid, p_limit integer DEFAULT 100) RETURNS TABLE(user_id uuid, last_email_at timestamp with time zone, delivery_rate numeric)
    LANGUAGE sql STABLE SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
  SELECT
    p.id AS user_id,
    h.last_delivered_at AS last_email_at,
    COALESCE(h.delivery_rate, 100) AS delivery_rate
  FROM profiles p
  LEFT JOIN user_email_health h ON h.user_id = p.id
  LEFT JOIN email_delivery_log edl ON edl.user_id = p.id
    AND edl.campaign_id = p_campaign_id
  WHERE p.email IS NOT NULL
    AND edl.id IS NULL  -- Not yet sent this campaign
  ORDER BY
    h.last_delivered_at NULLS FIRST,  -- Prioritize users who haven't received email
    h.delivery_rate DESC NULLS LAST   -- Then by best delivery rate
  LIMIT p_limit;
$$;


--
-- Name: FUNCTION get_underserved_users(p_campaign_id uuid, p_limit integer); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.get_underserved_users(p_campaign_id uuid, p_limit integer) IS 'Gets users who should receive emails first for fairness';


--
-- Name: get_unread_count(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_unread_count() RETURNS json
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
DECLARE
  result json;
  unread_count integer;
BEGIN
  SELECT COUNT(*)
  INTO unread_count
  FROM public.rooms
  WHERE (requester = auth.uid() OR sharer = auth.uid())
    AND last_message_sent_by != auth.uid()
    AND last_message_seen_by != auth.uid();
  
  SELECT json_build_object('unread_count', unread_count) INTO result;
  RETURN result;
END;
$$;


--
-- Name: get_unread_feed_count(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_unread_feed_count() RETURNS integer
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
DECLARE
  v_user_id UUID := auth.uid();
  v_count INTEGER;
BEGIN
  SELECT COUNT(*)::INTEGER INTO v_count
  FROM forum_activities a
  WHERE a.is_public = true
    AND a.profile_id IN (
      SELECT following_id FROM forum_user_follows WHERE follower_id = v_user_id
    )
    AND NOT EXISTS (
      SELECT 1 FROM forum_feed_read_status 
      WHERE profile_id = v_user_id AND activity_id = a.id
    )
    AND a.created_at > (now() - INTERVAL '7 days');
  
  RETURN v_count;
END;
$$;


--
-- Name: get_unread_forum_notification_count(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_unread_forum_notification_count() RETURNS integer
    LANGUAGE sql STABLE SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
  SELECT COUNT(*)::INT
  FROM public.forum_notifications
  WHERE recipient_id = (SELECT auth.uid())
    AND is_read = false;
$$;


--
-- Name: get_unread_message_count(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_unread_message_count(p_profile_id uuid DEFAULT NULL::uuid) RETURNS integer
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
DECLARE
  v_profile_id UUID;
  v_count INTEGER;
BEGIN
  v_profile_id := COALESCE(p_profile_id, auth.uid());
  
  SELECT COUNT(*)::INTEGER INTO v_count
  FROM forum_messages m
  JOIN forum_conversation_participants cp ON cp.conversation_id = m.conversation_id
  WHERE cp.profile_id = v_profile_id
    AND cp.left_at IS NULL
    AND m.sender_id != v_profile_id
    AND m.created_at > cp.last_read_at
    AND m.is_deleted = FALSE;
  
  RETURN v_count;
END;
$$;


--
-- Name: get_unread_notification_count(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_unread_notification_count(p_user_id uuid) RETURNS integer
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
    v_count INTEGER;
BEGIN
    SELECT COUNT(*)::INTEGER INTO v_count
    FROM in_app_notifications
    WHERE user_id = p_user_id
        AND read_at IS NULL;

    RETURN v_count;
END;
$$;


--
-- Name: FUNCTION get_unread_notification_count(p_user_id uuid); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.get_unread_notification_count(p_user_id uuid) IS 'Get count of unread in-app notifications for a user';


--
-- Name: get_unread_posts(integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_unread_posts(p_category_id integer DEFAULT NULL::integer, p_limit integer DEFAULT 20) RETURNS TABLE(forum_id bigint, title text, slug text, category_id integer, new_comments_count bigint, last_activity_at timestamp with time zone)
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
BEGIN
  RETURN QUERY
  SELECT 
    f.id as forum_id,
    f.forum_post_name as title,
    f.slug,
    f.category_id,
    COALESCE(
      (SELECT COUNT(*) FROM comments c 
       WHERE c.forum_id = f.id 
       AND c.comment_created_at > COALESCE(rp.last_read_at, '1970-01-01'::TIMESTAMP WITH TIME ZONE)),
      f.forum_comments_counter::BIGINT
    ) as new_comments_count,
    f.last_activity_at
  FROM forum f
  LEFT JOIN forum_reading_progress rp 
    ON rp.forum_id = f.id AND rp.profile_id = auth.uid()
  WHERE f.forum_published = true
    AND (p_category_id IS NULL OR f.category_id = p_category_id)
    AND (
      rp.id IS NULL -- Never read
      OR f.last_activity_at > rp.last_read_at -- New activity since last read
    )
  ORDER BY f.last_activity_at DESC
  LIMIT p_limit;
END;
$$;


--
-- Name: get_untranslated_challenges(integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_untranslated_challenges(p_limit integer DEFAULT 100, p_offset integer DEFAULT 0) RETURNS TABLE(id bigint, challenge_title text, challenge_description text)
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
BEGIN
  RETURN QUERY
  SELECT c.id, c.challenge_title, c.challenge_description
  FROM challenges c
  WHERE c.challenge_title IS NOT NULL
    AND NOT EXISTS (
      SELECT 1 FROM dynamic_content_translations dct
      WHERE dct.content_type = 'challenge'
        AND dct.source_text = c.challenge_title
        AND dct.target_locale = 'ru'
    )
  ORDER BY c.challenge_created_at DESC
  LIMIT p_limit
  OFFSET p_offset;
END;
$$;


--
-- Name: get_untranslated_forum_posts(integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_untranslated_forum_posts(p_limit integer DEFAULT 100, p_offset integer DEFAULT 0) RETURNS TABLE(id bigint, forum_post_name text, forum_post_description text)
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
BEGIN
  RETURN QUERY
  SELECT f.id, f.forum_post_name, f.forum_post_description
  FROM forum f
  WHERE f.forum_published = true
    AND f.forum_post_name IS NOT NULL
    AND NOT EXISTS (
      SELECT 1 FROM dynamic_content_translations dct
      WHERE dct.content_type = 'forum_post'
        AND dct.source_text = f.forum_post_name
        AND dct.target_locale = 'ru'
    )
  ORDER BY f.forum_post_created_at DESC
  LIMIT p_limit
  OFFSET p_offset;
END;
$$;


--
-- Name: get_untranslated_posts(integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_untranslated_posts(p_limit integer DEFAULT 100, p_offset integer DEFAULT 0) RETURNS TABLE(id bigint, post_name text, post_description text)
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
BEGIN
  RETURN QUERY
  SELECT p.id, p.post_name, p.post_description
  FROM posts p
  WHERE p.is_active = true
    AND p.post_name IS NOT NULL
    AND NOT EXISTS (
      SELECT 1 FROM dynamic_content_translations dct
      WHERE dct.content_type = 'post'
        AND dct.source_text = p.post_name
        AND dct.target_locale = 'ru'
    )
  ORDER BY p.created_at DESC
  LIMIT p_limit
  OFFSET p_offset;
END;
$$;


--
-- Name: get_upstash_redis_token(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_upstash_redis_token() RETURNS text
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
BEGIN
  RETURN vault.read_secret('UPSTASH_REDIS_TOKEN');
END;
$$;


--
-- Name: get_upstash_redis_url(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_upstash_redis_url() RETURNS text
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
BEGIN
  RETURN vault.read_secret('UPSTASH_REDIS_URL');
END;
$$;


--
-- Name: get_user_bookmarks(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_user_bookmarks(p_limit integer DEFAULT 50) RETURNS json
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
DECLARE
    v_user_id UUID;
    v_post_ids INTEGER[];
    v_total INTEGER;
BEGIN
    v_user_id := auth.uid();

    IF v_user_id IS NULL THEN
        RETURN json_build_object('success', false, 'error', json_build_object('code', 'AUTH_REQUIRED', 'message', 'Authentication required'));
    END IF;

    -- Get bookmarked post IDs from unified bookmarks table
    SELECT ARRAY_AGG(post_id ORDER BY created_at DESC)
    INTO v_post_ids
    FROM (
        SELECT post_id, created_at
        FROM bookmarks
        WHERE profile_id = v_user_id AND post_id > 0 AND forum_id = 0
        ORDER BY created_at DESC
        LIMIT p_limit
    ) sub;

    -- Get total count
    SELECT COUNT(*) INTO v_total
    FROM bookmarks
    WHERE profile_id = v_user_id AND post_id > 0 AND forum_id = 0;

    RETURN json_build_object(
        'success', true,
        'post_ids', COALESCE(v_post_ids, ARRAY[]::INTEGER[]),
        'total_count', v_total,
        'has_more', v_total > p_limit
    );
END;
$$;


--
-- Name: FUNCTION get_user_bookmarks(p_limit integer); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.get_user_bookmarks(p_limit integer) IS 'Get user bookmarked post IDs. Uses unified bookmarks table. Fixed overload 2026-01-31.';


--
-- Name: get_user_challenges_with_counts(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_user_challenges_with_counts(p_user_id uuid) RETURNS json
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
DECLARE
    result json;
BEGIN
    SELECT json_build_object(
        'challenges', COALESCE((
            SELECT json_agg(
                json_build_object(
                    'challenge', json_build_object(
                        'id', c.id,
                        'profile_id', c.profile_id,
                        'challenge_title', c.challenge_title,
                        'challenge_description', c.challenge_description,
                        'challenge_difficulty', c.challenge_difficulty,
                        'challenge_action', c.challenge_action,
                        'challenge_score', c.challenge_score,
                        'challenged_people', c.challenged_people,
                        'challenge_image', c.challenge_image,
                        'challenge_views', c.challenge_views,
                        'challenge_published', c.challenge_published,
                        'challenge_likes_counter', c.challenge_likes_counter,
                        'challenge_created_at', c.challenge_created_at,
                        'challenge_updated_at', c.challenge_updated_at
                    ),
                    'activity', json_build_object(
                        'id', ca.id,
                        'challenge_id', ca.challenge_id,
                        'profile_id', p_user_id,
                        'progress', 0,
                        'accepted_at', CASE WHEN ca.user_accepted_challenge = p_user_id THEN ca.created_at ELSE NULL END,
                        'completed_at', CASE WHEN ca.user_completed_challenge = p_user_id THEN ca.created_at ELSE NULL END,
                        'rejected_at', CASE WHEN ca.user_rejected_challenge = p_user_id THEN ca.created_at ELSE NULL END,
                        'created_at', ca.created_at
                    ),
                    'has_accepted', COALESCE(ca.user_accepted_challenge = p_user_id, false),
                    'has_completed', COALESCE(ca.user_completed_challenge = p_user_id, false)
                )
            )
            FROM challenge_activities ca
            JOIN challenges c ON c.id = ca.challenge_id
            WHERE ca.user_accepted_challenge = p_user_id
               OR ca.user_completed_challenge = p_user_id
        ), '[]'::json),
        'joined_count', (
            SELECT COUNT(*)::int
            FROM challenge_activities
            WHERE user_accepted_challenge = p_user_id
        ),
        'completed_count', (
            SELECT COUNT(*)::int
            FROM challenge_activities
            WHERE user_completed_challenge = p_user_id
        )
    ) INTO result;
    
    RETURN result;
END;
$$;


--
-- Name: get_user_comment_reactions(integer[]); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_user_comment_reactions(p_comment_ids integer[]) RETURNS TABLE(comment_id integer, reaction_type_ids integer[])
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
BEGIN
  RETURN QUERY
  SELECT 
    cr.comment_id,
    array_agg(cr.reaction_type_id)
  FROM forum_comment_reactions cr
  WHERE cr.comment_id = ANY(p_comment_ids)
    AND cr.profile_id = auth.uid()
  GROUP BY cr.comment_id;
END;
$$;


--
-- Name: get_user_dashboard(uuid, boolean, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_user_dashboard(p_user_id uuid, p_include_listings boolean DEFAULT true, p_listings_limit integer DEFAULT 5) RETURNS jsonb
    LANGUAGE plpgsql STABLE SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
DECLARE
  v_profile RECORD;
  v_stats RECORD;
  v_profile_stats RECORD;
  v_recent_listings JSONB;
  v_unread_notifications INTEGER;
  v_unread_messages INTEGER;
  v_pending_requests INTEGER;
  v_impact JSONB;
  v_badges JSONB;
BEGIN
  -- Get user profile
  SELECT
    p.id,
    p.nickname AS display_name,
    p.email,
    p.avatar_url,
    p.about_me AS bio,
    p.is_verified,
    p.created_time,
    p.last_seen_at,
    extensions.ST_Y(p.location::extensions.geometry) AS latitude,
    extensions.ST_X(p.location::extensions.geometry) AS longitude
  INTO v_profile
  FROM profiles p
  WHERE p.id = p_user_id AND p.is_active = TRUE;

  IF v_profile IS NULL THEN
    RETURN jsonb_build_object(
      'success', FALSE,
      'error', 'User not found'
    );
  END IF;

  -- Get profile stats
  SELECT * INTO v_profile_stats
  FROM profile_stats
  WHERE profile_id = p_user_id;

  -- Get unread counts
  SELECT COUNT(*)::INTEGER INTO v_unread_notifications
  FROM user_notifications
  WHERE recipient_id = p_user_id AND is_read = FALSE;

  SELECT COUNT(*)::INTEGER INTO v_unread_messages
  FROM rooms r
  WHERE (r.sharer = p_user_id OR r.requester = p_user_id)
    AND r.last_message_sent_by IS NOT NULL
    AND r.last_message_sent_by != p_user_id
    AND (r.last_message_seen_by IS NULL OR r.last_message_seen_by != p_user_id);

  -- Get pending requests (posts where user is the sharer and there are interested parties)
  SELECT COUNT(*)::INTEGER INTO v_pending_requests
  FROM rooms r
  JOIN posts p ON p.id = r.post_id
  WHERE p.profile_id = p_user_id
    AND p.is_active = TRUE
    AND p.is_arranged = FALSE;

  -- Get recent listings if requested
  IF p_include_listings THEN
    SELECT COALESCE(jsonb_agg(jsonb_build_object(
      'id', p.id::TEXT,
      'post_name', p.post_name,
      'images', COALESCE(p.images, ARRAY[]::TEXT[]),
      'is_active', p.is_active,
      'is_arranged', p.is_arranged,
      'view_count', COALESCE(p.post_views, 0),
      'created_at', p.created_at,
      'expires_at', NULL::TIMESTAMPTZ
    ) ORDER BY p.created_at DESC), '[]'::JSONB)
    INTO v_recent_listings
    FROM posts p
    WHERE p.profile_id = p_user_id
    LIMIT p_listings_limit;
  ELSE
    v_recent_listings := '[]'::JSONB;
  END IF;

  -- Calculate impact metrics
  v_impact := jsonb_build_object(
    'food_saved_kg', COALESCE(v_profile_stats.items_shared, 0) * 2,
    'co2_saved_kg', COALESCE(v_profile_stats.items_shared, 0) * 4,
    'meals_provided', COALESCE(v_profile_stats.items_shared, 0) * 3,
    'monthly_rank', NULL::INTEGER
  );

  -- Get badges
  v_badges := '[]'::JSONB;
  IF COALESCE(v_profile_stats.items_shared, 0) >= 10 THEN
    v_badges := v_badges || '"food_hero"'::JSONB;
  END IF;
  IF COALESCE(v_profile_stats.rating_count, 0) >= 5 AND COALESCE(v_profile_stats.rating_average, 0) >= 4.5 THEN
    v_badges := v_badges || '"top_rated"'::JSONB;
  END IF;

  RETURN jsonb_build_object(
    'profile', jsonb_build_object(
      'id', v_profile.id,
      'display_name', v_profile.display_name,
      'email', v_profile.email,
      'avatar_url', v_profile.avatar_url,
      'bio', v_profile.bio,
      'latitude', v_profile.latitude,
      'longitude', v_profile.longitude,
      'city', NULL::TEXT,
      'is_verified', COALESCE(v_profile.is_verified, FALSE),
      'created_at', v_profile.created_time
    ),
    'stats', jsonb_build_object(
      'items_shared', COALESCE(v_profile_stats.items_shared, 0),
      'items_received', COALESCE(v_profile_stats.items_received, 0),
      'active_listings', (
        SELECT COUNT(*)::INTEGER 
        FROM posts 
        WHERE profile_id = p_user_id AND is_active = TRUE AND is_arranged = FALSE
      ),
      'rating_average', v_profile_stats.rating_average,
      'rating_count', COALESCE(v_profile_stats.rating_count, 0),
      'completed_transactions', COALESCE(v_profile_stats.items_shared, 0) + COALESCE(v_profile_stats.items_received, 0)
    ),
    'impact', v_impact,
    'unread_notifications', v_unread_notifications,
    'unread_messages', v_unread_messages,
    'pending_requests', v_pending_requests,
    'recent_listings', v_recent_listings,
    'badges', v_badges,
    'last_active', v_profile.last_seen_at
  );
END;
$$;


--
-- Name: FUNCTION get_user_dashboard(p_user_id uuid, p_include_listings boolean, p_listings_limit integer); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.get_user_dashboard(p_user_id uuid, p_include_listings boolean, p_listings_limit integer) IS 'BFF user dashboard data for cross-platform clients. Returns profile, stats, impact metrics, counts, and recent listings.';


--
-- Name: get_user_dashboard_fast(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_user_dashboard_fast(p_user_id uuid) RETURNS jsonb
    LANGUAGE plpgsql STABLE SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
DECLARE
  v_profile record;
  v_stats record;
  v_profile_stats record;
  v_recent_activity jsonb;
  v_impact_stats jsonb;
BEGIN
  -- Get user profile (always real-time)
  SELECT
    p.id,
    p.nickname,
    p.email,
    p.avatar_url,
    p.about_me,
    p.is_active,
    p.dietary_preferences,
    p.notification_preferences,
    p.created_time,
    p.updated_at
  INTO v_profile
  FROM profiles p
  WHERE p.id = p_user_id AND p.is_active = true;

  IF v_profile IS NULL THEN
    RETURN jsonb_build_object(
      'success', false,
      'error', jsonb_build_object('code', 'USER_NOT_FOUND', 'message', 'User profile not found')
    );
  END IF;

  -- Get profile stats
  SELECT * INTO v_profile_stats
  FROM profile_stats
  WHERE profile_id = p_user_id;

  -- Get precomputed stats from materialized view
  SELECT * INTO v_stats
  FROM mv_user_stats
  WHERE user_id = p_user_id;

  -- Get recent activity (always real-time for freshness)
  SELECT COALESCE(jsonb_agg(
    jsonb_build_object(
      'id', un.id,
      'title', un.title,
      'text', un.body,
      'timestamp', un.created_at,
      'type', un.type,
      'data', un.data,
      'isRead', un.is_read
    ) ORDER BY un.created_at DESC
  ), '[]'::jsonb) INTO v_recent_activity
  FROM (
    SELECT * FROM user_notifications
    WHERE recipient_id = p_user_id
    ORDER BY created_at DESC
    LIMIT 5
  ) un;

  -- Calculate impact stats
  v_impact_stats := jsonb_build_object(
    'itemsShared', COALESCE(v_profile_stats.items_shared, 0),
    'itemsSharedDisplay', COALESCE(v_profile_stats.items_shared, 0) || ' items shared',
    'rating', COALESCE(v_profile_stats.rating_average, 0),
    'ratingDisplay', CASE
      WHEN COALESCE(v_profile_stats.rating_count, 0) > 0 THEN
        ROUND(v_profile_stats.rating_average::numeric, 1)::text || ' * (' || v_profile_stats.rating_count || ' reviews)'
      ELSE 'No ratings yet'
    END,
    'memberSince', to_char(v_profile.created_time, 'Mon YYYY'),
    'memberDays', EXTRACT(DAY FROM NOW() - v_profile.created_time)::integer
  );

  -- Return aggregated dashboard data
  RETURN jsonb_build_object(
    'success', true,
    'profile', jsonb_build_object(
      'id', v_profile.id,
      'nickname', v_profile.nickname,
      'email', v_profile.email,
      'avatarUrl', v_profile.avatar_url,
      'aboutMe', v_profile.about_me,
      'isActive', v_profile.is_active,
      'dietaryPreferences', COALESCE(v_profile.dietary_preferences, '[]'::jsonb),
      'notificationPreferences', COALESCE(v_profile.notification_preferences, '{}'::jsonb)
    ),
    'counts', jsonb_build_object(
      'unreadNotifications', COALESCE(v_stats.unread_notifications, 0),
      'unreadMessages', COALESCE(v_stats.unread_messages, 0),
      'activeListings', COALESCE(v_stats.active_listings, 0),
      'pendingRequests', COALESCE(v_stats.pending_requests, 0)
    ),
    'badges', CASE
      WHEN COALESCE(v_stats.unread_notifications, 0) > 0 OR COALESCE(v_stats.unread_messages, 0) > 0 THEN
        jsonb_build_array(
          CASE WHEN COALESCE(v_stats.unread_notifications, 0) > 0 THEN
            jsonb_build_object('text', v_stats.unread_notifications::text, 'color', 'red', 'screen', 'Notifications')
          ELSE NULL END,
          CASE WHEN COALESCE(v_stats.unread_messages, 0) > 0 THEN
            jsonb_build_object('text', v_stats.unread_messages::text, 'color', 'blue', 'screen', 'Messages')
          ELSE NULL END
        ) - NULL  -- Remove null entries
      ELSE '[]'::jsonb
    END,
    'impactStats', v_impact_stats,
    'recentActivity', v_recent_activity,
    'quickActions', jsonb_build_array(
      jsonb_build_object('label', 'Share Food', 'screen', 'CreateListing', 'icon', 'plus'),
      jsonb_build_object('label', 'Find Food', 'screen', 'Browse', 'icon', 'search'),
      jsonb_build_object('label', 'My Listings', 'screen', 'MyListings', 'icon', 'list'),
      jsonb_build_object('label', 'Messages', 'screen', 'Messages', 'icon', 'message',
        'badge', CASE WHEN COALESCE(v_stats.unread_messages, 0) > 0 THEN v_stats.unread_messages ELSE NULL END)
    ),
    'meta', jsonb_build_object(
      'timestamp', NOW(),
      'cacheTTL', 60,
      'refreshAfter', 300,
      'statsRefreshedAt', v_stats.refreshed_at,
      'usesMaterializedView', v_stats IS NOT NULL
    )
  );
END;
$$;


--
-- Name: FUNCTION get_user_dashboard_fast(p_user_id uuid); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.get_user_dashboard_fast(p_user_id uuid) IS 'Optimized dashboard using materialized view for counts';


--
-- Name: get_user_email_metrics(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_user_email_metrics(p_user_id uuid) RETURNS jsonb
    LANGUAGE sql STABLE SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
  SELECT jsonb_build_object(
    'userId', p_user_id,
    'totalEmails', COUNT(*),
    'delivered', COUNT(*) FILTER (WHERE status IN ('delivered', 'opened', 'clicked')),
    'opened', COUNT(*) FILTER (WHERE status IN ('opened', 'clicked')),
    'clicked', COUNT(*) FILTER (WHERE status = 'clicked'),
    'bounced', COUNT(*) FILTER (WHERE status = 'bounced'),
    'complained', COUNT(*) FILTER (WHERE status = 'complained'),
    'failed', COUNT(*) FILTER (WHERE status = 'failed'),
    'deliveryRate', ROUND(
      COUNT(*) FILTER (WHERE status IN ('delivered', 'opened', 'clicked'))::numeric /
      NULLIF(COUNT(*), 0) * 100, 2
    ),
    'openRate', ROUND(
      COUNT(*) FILTER (WHERE status IN ('opened', 'clicked'))::numeric /
      NULLIF(COUNT(*) FILTER (WHERE status IN ('delivered', 'opened', 'clicked')), 0) * 100, 2
    ),
    'lastDelivered', MAX(delivered_at),
    'lastOpened', MAX(opened_at),
    'recentEmails', (
      SELECT COALESCE(jsonb_agg(jsonb_build_object(
        'id', id,
        'type', email_type,
        'template', template_slug,
        'status', status,
        'sentAt', sent_at,
        'deliveredAt', delivered_at,
        'openedAt', opened_at
      ) ORDER BY queued_at DESC), '[]'::jsonb)
      FROM (
        SELECT id, email_type, template_slug, status, sent_at, delivered_at, opened_at, queued_at
        FROM email_delivery_log
        WHERE user_id = p_user_id
        ORDER BY queued_at DESC
        LIMIT 10
      ) recent
    )
  )
  FROM email_delivery_log
  WHERE user_id = p_user_id
    AND queued_at > NOW() - INTERVAL '90 days';
$$;


--
-- Name: FUNCTION get_user_email_metrics(p_user_id uuid); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.get_user_email_metrics(p_user_id uuid) IS 'Gets comprehensive email metrics for a user';


--
-- Name: get_user_feature_flags(uuid, text, text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_user_feature_flags(p_user_id uuid, p_platform text DEFAULT 'unknown'::text, p_app_version text DEFAULT NULL::text) RETURNS jsonb
    LANGUAGE plpgsql STABLE SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
DECLARE
  v_flags jsonb := '{}'::jsonb;
  v_flag record;
  v_override record;
  v_is_enabled boolean;
  v_user_hash integer;
  v_user_segments text[];
BEGIN
  -- Get deterministic hash for rollout (0-99)
  v_user_hash := abs(hashtext(p_user_id::text)) % 100;

  -- Get user segments (could be extended with actual segment logic)
  -- For now, just check if user is "new" (created in last 30 days)
  SELECT ARRAY_AGG(segment)
  INTO v_user_segments
  FROM (
    SELECT 'new_user' AS segment
    FROM profiles
    WHERE id = p_user_id
      AND created_time > NOW() - INTERVAL '30 days'
    UNION ALL
    SELECT 'all' AS segment
  ) segments;

  -- Process each flag (using existing flag_key column)
  FOR v_flag IN
    SELECT
      flag_key,
      display_name,
      enabled,
      rollout_percentage,
      target_segments,
      target_platforms,
      min_app_version,
      config,
      metadata
    FROM feature_flags
    WHERE (expires_at IS NULL OR expires_at > NOW())
    ORDER BY flag_key
  LOOP
    -- Check for override first
    SELECT * INTO v_override
    FROM feature_flag_overrides
    WHERE user_id = p_user_id
      AND flag_key = v_flag.flag_key
      AND (expires_at IS NULL OR expires_at > NOW());

    IF v_override IS NOT NULL THEN
      v_is_enabled := v_override.enabled;
    ELSE
      -- Check if flag is enabled
      v_is_enabled := v_flag.enabled;

      -- Check rollout percentage
      IF v_is_enabled AND v_flag.rollout_percentage < 100 THEN
        v_is_enabled := v_user_hash < v_flag.rollout_percentage;
      END IF;

      -- Check platform targeting
      IF v_is_enabled AND v_flag.target_platforms IS NOT NULL AND array_length(v_flag.target_platforms, 1) > 0 THEN
        v_is_enabled := p_platform = ANY(v_flag.target_platforms);
      END IF;

      -- Check version requirements
      IF v_is_enabled AND p_app_version IS NOT NULL AND v_flag.min_app_version ? p_platform THEN
        v_is_enabled := p_app_version >= (v_flag.min_app_version->>p_platform);
      END IF;

      -- Check user segments (using target_segments from existing table)
      IF v_is_enabled AND v_flag.target_segments IS NOT NULL AND array_length(v_flag.target_segments, 1) > 0 THEN
        v_is_enabled := v_flag.target_segments && v_user_segments;
      END IF;
    END IF;

    -- Add to result
    v_flags := v_flags || jsonb_build_object(
      v_flag.flag_key,
      jsonb_build_object(
        'enabled', v_is_enabled,
        'config', CASE WHEN v_is_enabled THEN COALESCE(v_flag.config, '{}'::jsonb) ELSE '{}'::jsonb END
      )
    );
  END LOOP;

  RETURN jsonb_build_object(
    'success', true,
    'flags', v_flags,
    'context', jsonb_build_object(
      'platform', p_platform,
      'appVersion', p_app_version,
      'userHash', v_user_hash
    ),
    'meta', jsonb_build_object(
      'timestamp', NOW(),
      'refreshAfter', 300,
      'cacheTTL', 60
    )
  );
END;
$$;


--
-- Name: FUNCTION get_user_feature_flags(p_user_id uuid, p_platform text, p_app_version text); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.get_user_feature_flags(p_user_id uuid, p_platform text, p_app_version text) IS 'Returns feature flags with targeting and rollout logic';


--
-- Name: get_user_feed(integer, integer, boolean); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_user_feed(p_limit integer DEFAULT 20, p_offset integer DEFAULT 0, p_include_own boolean DEFAULT true) RETURNS TABLE(activity_id uuid, activity_type text, actor_id uuid, actor_username text, actor_avatar text, target_forum_id integer, target_forum_title text, target_comment_id integer, target_comment_preview text, target_profile_id uuid, target_profile_username text, target_badge_id integer, target_badge_name text, target_series_id uuid, target_series_title text, metadata jsonb, created_at timestamp with time zone, is_read boolean)
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
DECLARE
  v_user_id UUID := auth.uid();
BEGIN
  RETURN QUERY
  SELECT 
    a.id AS activity_id,
    a.activity_type,
    a.profile_id AS actor_id,
    p.username AS actor_username,
    p.avatar_url AS actor_avatar,
    a.target_forum_id,
    f.forum_post_name AS target_forum_title,
    a.target_comment_id,
    LEFT(c.comment, 100) AS target_comment_preview,
    a.target_profile_id,
    tp.username AS target_profile_username,
    a.target_badge_id,
    b.name AS target_badge_name,
    a.target_series_id,
    s.title AS target_series_title,
    a.metadata,
    a.created_at,
    (rs.id IS NOT NULL) AS is_read
  FROM forum_activities a
  JOIN profiles p ON p.id = a.profile_id
  LEFT JOIN forum f ON f.id = a.target_forum_id
  LEFT JOIN comments c ON c.id = a.target_comment_id
  LEFT JOIN profiles tp ON tp.id = a.target_profile_id
  LEFT JOIN forum_badges b ON b.id = a.target_badge_id
  LEFT JOIN forum_series s ON s.id = a.target_series_id
  LEFT JOIN forum_feed_read_status rs ON rs.activity_id = a.id AND rs.profile_id = v_user_id
  WHERE a.is_public = true
    AND (
      -- Activities from followed users
      a.profile_id IN (
        SELECT following_id FROM forum_user_follows WHERE follower_id = v_user_id
      )
      -- Or own activities if requested
      OR (p_include_own AND a.profile_id = v_user_id)
      -- Or activities where user is mentioned/targeted
      OR a.target_profile_id = v_user_id
    )
    -- Exclude blocked users
    AND NOT EXISTS (
      SELECT 1 FROM forum_user_blocks 
      WHERE (blocker_id = v_user_id AND blocked_id = a.profile_id)
         OR (blocker_id = a.profile_id AND blocked_id = v_user_id)
    )
  ORDER BY a.created_at DESC
  LIMIT p_limit
  OFFSET p_offset;
END;
$$;


--
-- Name: FUNCTION get_user_feed(p_limit integer, p_offset integer, p_include_own boolean); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.get_user_feed(p_limit integer, p_offset integer, p_include_own boolean) IS 'Returns personalized activity feed for the authenticated user';


--
-- Name: get_user_post_activity_summary(uuid, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_user_post_activity_summary(p_user_id uuid, p_days integer DEFAULT 30) RETURNS TABLE(activity_type public.post_activity_type, count bigint, last_activity timestamp with time zone)
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO ''
    AS $$
BEGIN
  RETURN QUERY
  SELECT 
    pal.activity_type,
    COUNT(*) AS count,
    MAX(pal.created_at) AS last_activity
  FROM post_activity_logs pal
  WHERE pal.actor_id = p_user_id
    AND pal.created_at >= NOW() - (p_days || ' days')::INTERVAL
  GROUP BY pal.activity_type
  ORDER BY count DESC;
END;
$$;


--
-- Name: get_user_preferences(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_user_preferences(p_user_id uuid) RETURNS jsonb
    LANGUAGE plpgsql STABLE SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
DECLARE
  v_activity record;
  v_top_categories jsonb;
  v_peak_hours integer[];
BEGIN
  SELECT * INTO v_activity
  FROM user_activity_summary
  WHERE user_id = p_user_id;

  IF v_activity IS NULL THEN
    RETURN jsonb_build_object(
      'success', true,
      'isNewUser', true,
      'preferences', jsonb_build_object()
    );
  END IF;

  SELECT COALESCE(jsonb_agg(
    jsonb_build_object('categoryId', key, 'viewCount', value::integer)
    ORDER BY value::integer DESC
  ), '[]'::jsonb) INTO v_top_categories
  FROM (
    SELECT key, value
    FROM jsonb_each_text(v_activity.categories_viewed)
    ORDER BY value::integer DESC
    LIMIT 5
  ) sub;

  SELECT ARRAY(
    SELECT key::integer
    FROM jsonb_each_text(v_activity.peak_activity_hours)
    ORDER BY value::integer DESC
    LIMIT 3
  ) INTO v_peak_hours;

  RETURN jsonb_build_object(
    'success', true,
    'isNewUser', false,
    'preferences', jsonb_build_object(
      'topCategories', v_top_categories,
      'recentSearches', v_activity.search_terms[1:5],
      'peakHours', v_peak_hours,
      'engagementLevel', CASE
        WHEN v_activity.listings_viewed > 100 THEN 'high'
        WHEN v_activity.listings_viewed > 20 THEN 'medium'
        ELSE 'low'
      END
    ),
    'stats', jsonb_build_object(
      'listingsViewed', v_activity.listings_viewed,
      'listingsSaved', v_activity.listings_saved,
      'messagesInitiated', v_activity.messages_initiated,
      'sharesCompleted', v_activity.shares_completed,
      'searchCount', v_activity.search_count
    ),
    'activity', jsonb_build_object(
      'firstActivityAt', v_activity.first_activity_at,
      'lastActivityAt', v_activity.last_activity_at,
      'daysSinceFirstActivity', EXTRACT(DAY FROM NOW() - v_activity.first_activity_at)::integer
    )
  );
END;
$$;


--
-- Name: get_user_reputation(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_user_reputation(p_profile_id uuid DEFAULT NULL::uuid) RETURNS TABLE(profile_id uuid, total_points integer, reputation_level integer, level_title text, level_color text, points_this_week integer, points_this_month integer, next_level integer, points_to_next_level integer)
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
DECLARE
  v_profile_id UUID := COALESCE(p_profile_id, auth.uid());
BEGIN
  RETURN QUERY
  WITH user_rep AS (
    SELECT ur.*, rl.color AS level_color FROM forum_user_reputation ur
    LEFT JOIN forum_reputation_levels rl ON rl.level = ur.reputation_level WHERE ur.profile_id = v_profile_id
  ),
  next_lvl AS (
    SELECT level, min_points FROM forum_reputation_levels
    WHERE min_points > COALESCE((SELECT total_points FROM user_rep), 0) ORDER BY min_points ASC LIMIT 1
  )
  SELECT v_profile_id, COALESCE(ur.total_points, 0), COALESCE(ur.reputation_level, 1), COALESCE(ur.level_title, 'Newcomer'),
    COALESCE(ur.level_color, '#9CA3AF'), COALESCE(ur.points_this_week, 0), COALESCE(ur.points_this_month, 0),
    nl.level, nl.min_points - COALESCE(ur.total_points, 0)
  FROM (SELECT 1) AS dummy LEFT JOIN user_rep ur ON true LEFT JOIN next_lvl nl ON true;
END;
$$;


--
-- Name: get_user_reviews_with_average(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_user_reviews_with_average(p_user_id uuid) RETURNS jsonb
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
DECLARE
  v_reviews JSONB;
  v_average_rating NUMERIC;
  v_total_count INTEGER;
BEGIN
  -- Get average rating for reviews about this user
  SELECT 
    COALESCE(AVG(reviewed_rating)::NUMERIC(3,2), 0),
    COUNT(*)
  INTO v_average_rating, v_total_count
  FROM reviews
  WHERE reviewed_user_id = p_user_id;

  -- Get reviews with reviewer profile
  SELECT COALESCE(jsonb_agg(
    jsonb_build_object(
      'id', r.id,
      'post_id', r.post_id,
      'reviewed_user_id', r.reviewed_user_id,
      'reviewer_user_id', r.reviewer_user_id,
      'reviewed_rating', r.reviewed_rating,
      'reviewed_comment', r.reviewed_comment,
      'created_at', r.created_at,
      'updated_at', r.updated_at,
      'reviewer_profile', CASE 
        WHEN r.reviewer_user_id IS NOT NULL THEN (
          SELECT jsonb_build_object(
            'id', p.id,
            'nickname', p.nickname,
            'avatar_url', p.avatar_url
          )
          FROM profiles p
          WHERE p.id = r.reviewer_user_id
        )
        ELSE NULL
      END
    ) ORDER BY r.created_at DESC
  ), '[]'::jsonb)
  INTO v_reviews
  FROM reviews r
  WHERE r.reviewed_user_id = p_user_id;

  RETURN jsonb_build_object(
    'reviews', v_reviews,
    'average_rating', v_average_rating,
    'total_count', v_total_count
  );
END;
$$;


--
-- Name: get_user_roles(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_user_roles(user_id uuid) RETURNS TABLE(role_id integer, role_name text, role_description text, granted_at timestamp with time zone)
    LANGUAGE sql STABLE SECURITY DEFINER
    SET search_path TO ''
    AS $$
  SELECT 
    r.id,
    r.name,
    r.description,
    ur.granted_at
  FROM public.user_roles ur
  JOIN public.roles r ON ur.role_id = r.id
  WHERE ur.profile_id = user_id
  ORDER BY r.name;
$$;


--
-- Name: FUNCTION get_user_roles(user_id uuid); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.get_user_roles(user_id uuid) IS 'Get all roles for a user';


--
-- Name: get_user_rooms(uuid, text, text, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_user_rooms(p_user_id uuid, p_search_query text DEFAULT NULL::text, p_filter_type text DEFAULT 'all'::text, p_limit integer DEFAULT 50, p_offset integer DEFAULT 0) RETURNS jsonb
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public', 'pg_temp'
    AS $$
DECLARE
    v_result JSONB;
BEGIN
    WITH filtered_rooms AS (
        SELECT 
            r.*,
            -- Unread: last message wasn't sent by this user AND wasn't seen by this user
            CASE 
                WHEN r.last_message_sent_by IS NOT NULL 
                     AND r.last_message_sent_by != p_user_id
                     AND (r.last_message_seen_by IS NULL OR r.last_message_seen_by != p_user_id)
                THEN TRUE
                ELSE FALSE
            END AS has_unread,
            -- Role in conversation
            CASE WHEN r.sharer = p_user_id THEN 'sharer' ELSE 'requester' END AS user_role
        FROM rooms r
        WHERE 
            -- User must be participant
            (r.sharer = p_user_id OR r.requester = p_user_id)
            -- Optional text search on last_message
            AND (
                p_search_query IS NULL 
                OR p_search_query = ''
                OR r.last_message ILIKE '%' || p_search_query || '%'
            )
    ),
    type_filtered AS (
        SELECT *
        FROM filtered_rooms
        WHERE
            CASE p_filter_type
                WHEN 'unread' THEN has_unread = TRUE
                WHEN 'sharing' THEN user_role = 'sharer'
                WHEN 'receiving' THEN user_role = 'requester'
                ELSE TRUE -- 'all'
            END
    )
    SELECT jsonb_build_object(
        'success', true,
        'rooms', COALESCE(
            (SELECT jsonb_agg(
                jsonb_build_object(
                    'id', tr.id,
                    'postId', tr.post_id,
                    'sharer', tr.sharer,
                    'requester', tr.requester,
                    'lastMessage', tr.last_message,
                    'lastMessageTime', tr.last_message_time,
                    'lastMessageSentBy', tr.last_message_sent_by,
                    'lastMessageSeenBy', tr.last_message_seen_by,
                    'postArrangedTo', tr.post_arranged_to,
                    'emailTo', tr.email_to,
                    'hasUnread', tr.has_unread,
                    'userRole', tr.user_role
                ) ORDER BY tr.last_message_time DESC NULLS LAST
            ) FROM type_filtered tr),
            '[]'::jsonb
        ),
        'totalCount', (SELECT COUNT(*) FROM type_filtered),
        'unreadCount', (SELECT COUNT(*) FROM filtered_rooms WHERE has_unread = TRUE),
        'pagination', jsonb_build_object(
            'limit', p_limit,
            'offset', p_offset,
            'hasMore', (SELECT COUNT(*) FROM type_filtered) > p_offset + p_limit
        )
    ) INTO v_result;

    RETURN v_result;
END;
$$;


--
-- Name: get_user_settings(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_user_settings(p_user_id uuid) RETURNS jsonb
    LANGUAGE plpgsql STABLE SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
DECLARE
  v_profile record;
BEGIN
  SELECT
    p.id,
    p.username,
    p.email,
    p.notification_preferences,
    p.dietary_preferences,
    p.created_at
  INTO v_profile
  FROM profiles p
  WHERE p.id = p_user_id
    AND p.deleted_at IS NULL;

  IF v_profile IS NULL THEN
    RETURN jsonb_build_object(
      'success', false,
      'error', jsonb_build_object('code', 'NOT_FOUND', 'message', 'User not found')
    );
  END IF;

  RETURN jsonb_build_object(
    'success', true,
    'settings', jsonb_build_object(
      -- Notification Settings
      'notifications', jsonb_build_object(
        'pushEnabled', COALESCE((v_profile.notification_preferences->>'push_enabled')::boolean, true),
        'emailEnabled', COALESCE((v_profile.notification_preferences->>'email_enabled')::boolean, true),
        'newListings', COALESCE((v_profile.notification_preferences->>'new_listings')::boolean, true),
        'messages', COALESCE((v_profile.notification_preferences->>'messages')::boolean, true),
        'reminders', COALESCE((v_profile.notification_preferences->>'reminders')::boolean, true),
        'marketing', COALESCE((v_profile.notification_preferences->>'marketing')::boolean, false),
        'quietHoursEnabled', COALESCE((v_profile.notification_preferences->>'quiet_hours_enabled')::boolean, false),
        'quietHoursStart', COALESCE(v_profile.notification_preferences->>'quiet_hours_start', '22:00'),
        'quietHoursEnd', COALESCE(v_profile.notification_preferences->>'quiet_hours_end', '08:00')
      ),
      -- Privacy Settings
      'privacy', jsonb_build_object(
        'showEmail', COALESCE((v_profile.notification_preferences->>'show_email')::boolean, false),
        'showLocation', COALESCE((v_profile.notification_preferences->>'show_location')::boolean, true),
        'showOnlineStatus', COALESCE((v_profile.notification_preferences->>'show_online_status')::boolean, true),
        'allowMessages', COALESCE((v_profile.notification_preferences->>'allow_messages')::boolean, true),
        'allowRatings', COALESCE((v_profile.notification_preferences->>'allow_ratings')::boolean, true)
      ),
      -- Preferences
      'preferences', jsonb_build_object(
        'dietary', COALESCE(v_profile.dietary_preferences, '[]'::jsonb),
        'searchRadiusKm', COALESCE((v_profile.notification_preferences->>'search_radius')::integer, 10),
        'language', COALESCE(v_profile.notification_preferences->>'language', 'en'),
        'units', COALESCE(v_profile.notification_preferences->>'units', 'metric'),
        'theme', COALESCE(v_profile.notification_preferences->>'theme', 'system')
      ),
      -- Account Settings
      'account', jsonb_build_object(
        'email', v_profile.email,
        'emailVerified', true, -- Assuming verified through Supabase Auth
        'memberSince', to_char(v_profile.created_at, 'Mon DD, YYYY')
      )
    ),
    'sections', jsonb_build_array(
      jsonb_build_object(
        'id', 'notifications',
        'title', 'Notifications',
        'icon', 'bell',
        'description', 'Manage how you receive notifications',
        'fields', jsonb_build_array(
          jsonb_build_object('key', 'pushEnabled', 'label', 'Push Notifications', 'type', 'toggle', 'description', 'Receive push notifications on your device'),
          jsonb_build_object('key', 'emailEnabled', 'label', 'Email Notifications', 'type', 'toggle', 'description', 'Receive email updates'),
          jsonb_build_object('key', 'newListings', 'label', 'New Listings Nearby', 'type', 'toggle', 'description', 'Get notified when new food is shared near you'),
          jsonb_build_object('key', 'messages', 'label', 'Messages', 'type', 'toggle', 'description', 'Get notified when you receive messages'),
          jsonb_build_object('key', 'reminders', 'label', 'Reminders', 'type', 'toggle', 'description', 'Get pickup reminders'),
          jsonb_build_object('key', 'marketing', 'label', 'Marketing', 'type', 'toggle', 'description', 'Receive tips and community updates'),
          jsonb_build_object('key', 'quietHoursEnabled', 'label', 'Quiet Hours', 'type', 'toggle', 'description', 'Pause notifications during set hours'),
          jsonb_build_object('key', 'quietHoursStart', 'label', 'Start Time', 'type', 'time', 'dependsOn', 'quietHoursEnabled'),
          jsonb_build_object('key', 'quietHoursEnd', 'label', 'End Time', 'type', 'time', 'dependsOn', 'quietHoursEnabled')
        )
      ),
      jsonb_build_object(
        'id', 'privacy',
        'title', 'Privacy',
        'icon', 'shield',
        'description', 'Control your privacy settings',
        'fields', jsonb_build_array(
          jsonb_build_object('key', 'showEmail', 'label', 'Show Email', 'type', 'toggle', 'description', 'Allow others to see your email'),
          jsonb_build_object('key', 'showLocation', 'label', 'Show Location', 'type', 'toggle', 'description', 'Show your general location on listings'),
          jsonb_build_object('key', 'showOnlineStatus', 'label', 'Show Online Status', 'type', 'toggle', 'description', 'Let others see when you are online'),
          jsonb_build_object('key', 'allowMessages', 'label', 'Allow Messages', 'type', 'toggle', 'description', 'Allow others to message you'),
          jsonb_build_object('key', 'allowRatings', 'label', 'Allow Ratings', 'type', 'toggle', 'description', 'Allow others to rate you after transactions')
        )
      ),
      jsonb_build_object(
        'id', 'preferences',
        'title', 'Preferences',
        'icon', 'sliders',
        'description', 'Customize your experience',
        'fields', jsonb_build_array(
          jsonb_build_object('key', 'dietary', 'label', 'Dietary Preferences', 'type', 'multiselect',
            'options', jsonb_build_array(
              jsonb_build_object('value', 'vegetarian', 'label', 'Vegetarian'),
              jsonb_build_object('value', 'vegan', 'label', 'Vegan'),
              jsonb_build_object('value', 'gluten-free', 'label', 'Gluten-Free'),
              jsonb_build_object('value', 'dairy-free', 'label', 'Dairy-Free'),
              jsonb_build_object('value', 'nut-free', 'label', 'Nut-Free'),
              jsonb_build_object('value', 'halal', 'label', 'Halal'),
              jsonb_build_object('value', 'kosher', 'label', 'Kosher')
            )
          ),
          jsonb_build_object('key', 'searchRadiusKm', 'label', 'Search Radius', 'type', 'slider',
            'min', 1, 'max', 50, 'step', 1, 'unit', 'km'),
          jsonb_build_object('key', 'language', 'label', 'Language', 'type', 'select',
            'options', jsonb_build_array(
              jsonb_build_object('value', 'en', 'label', 'English'),
              jsonb_build_object('value', 'de', 'label', 'Deutsch'),
              jsonb_build_object('value', 'es', 'label', 'Espaol'),
              jsonb_build_object('value', 'fr', 'label', 'Franais'),
              jsonb_build_object('value', 'ru', 'label', '')
            )
          ),
          jsonb_build_object('key', 'units', 'label', 'Units', 'type', 'select',
            'options', jsonb_build_array(
              jsonb_build_object('value', 'metric', 'label', 'Metric (km)'),
              jsonb_build_object('value', 'imperial', 'label', 'Imperial (mi)')
            )
          ),
          jsonb_build_object('key', 'theme', 'label', 'Theme', 'type', 'select',
            'options', jsonb_build_array(
              jsonb_build_object('value', 'system', 'label', 'System'),
              jsonb_build_object('value', 'light', 'label', 'Light'),
              jsonb_build_object('value', 'dark', 'label', 'Dark')
            )
          )
        )
      ),
      jsonb_build_object(
        'id', 'account',
        'title', 'Account',
        'icon', 'user',
        'description', 'Manage your account',
        'fields', jsonb_build_array(
          jsonb_build_object('key', 'email', 'label', 'Email', 'type', 'display', 'description', 'Your registered email address'),
          jsonb_build_object('key', 'memberSince', 'label', 'Member Since', 'type', 'display')
        ),
        'actions', jsonb_build_array(
          jsonb_build_object('label', 'Change Password', 'action', 'change_password', 'style', 'secondary'),
          jsonb_build_object('label', 'Export My Data', 'action', 'export_data', 'style', 'secondary'),
          jsonb_build_object('label', 'Delete Account', 'action', 'delete_account', 'style', 'danger')
        )
      )
    ),
    'meta', jsonb_build_object(
      'timestamp', NOW(),
      'cacheTTL', 300
    )
  );
END;
$$;


--
-- Name: FUNCTION get_user_settings(p_user_id uuid); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.get_user_settings(p_user_id uuid) IS 'BFF endpoint: Returns complete settings screen data';


--
-- Name: get_user_stats(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_user_stats(p_user_id uuid) RETURNS jsonb
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
DECLARE
  v_shared_count int;
  v_received_count int;
  v_rating double precision;
BEGIN
  -- Count shared posts
  SELECT COUNT(*)
  INTO v_shared_count
  FROM posts
  WHERE profile_id = p_user_id;
  
  -- Count received posts (arranged posts where user is recipient)
  SELECT COUNT(*)
  INTO v_received_count
  FROM posts
  WHERE post_arranged_to = p_user_id
    AND is_arranged = true;
  
  -- Get rating from profile
  SELECT COALESCE(rating_average, 0.0)
  INTO v_rating
  FROM profiles
  WHERE id = p_user_id;
  
  RETURN jsonb_build_object(
    'shared', v_shared_count,
    'received', v_received_count,
    'rating', v_rating
  );
END;
$$;


--
-- Name: FUNCTION get_user_stats(p_user_id uuid); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.get_user_stats(p_user_id uuid) IS 'Returns user sharing statistics (shared count, received count, rating). Replaces 3 separate queries.';


--
-- Name: get_user_stats_fast(uuid, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_user_stats_fast(p_user_id uuid, p_max_stale_minutes integer DEFAULT 30) RETURNS jsonb
    LANGUAGE plpgsql STABLE SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
DECLARE
  v_stats record;
  v_is_stale boolean;
BEGIN
  -- Try to get from materialized view
  SELECT
    *,
    (NOW() - refreshed_at) > (p_max_stale_minutes * INTERVAL '1 minute') AS is_stale
  INTO v_stats
  FROM mv_user_stats
  WHERE user_id = p_user_id;

  -- If not found or too stale, return empty with refresh hint
  IF v_stats IS NULL THEN
    RETURN jsonb_build_object(
      'success', false,
      'error', 'NOT_CACHED',
      'hint', 'User stats not yet cached, use get_user_dashboard for real-time data'
    );
  END IF;

  v_is_stale := COALESCE(v_stats.is_stale, false);

  RETURN jsonb_build_object(
    'success', true,
    'stats', jsonb_build_object(
      'activeListings', v_stats.active_listings,
      'pendingRequests', v_stats.pending_requests,
      'unreadNotifications', v_stats.unread_notifications,
      'unreadMessages', v_stats.unread_messages,
      'itemsShared', v_stats.items_shared,
      'ratingAverage', v_stats.rating_average,
      'ratingCount', v_stats.rating_count
    ),
    'activity', jsonb_build_object(
      'lastListingAt', v_stats.last_listing_at,
      'lastNotificationAt', v_stats.last_notification_at,
      'lastMessageAt', v_stats.last_message_at
    ),
    'meta', jsonb_build_object(
      'refreshedAt', v_stats.refreshed_at,
      'isStale', v_is_stale,
      'staleness', EXTRACT(EPOCH FROM (NOW() - v_stats.refreshed_at))::integer
    )
  );
END;
$$;


--
-- Name: FUNCTION get_user_stats_fast(p_user_id uuid, p_max_stale_minutes integer); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.get_user_stats_fast(p_user_id uuid, p_max_stale_minutes integer) IS 'Fast user stats lookup using materialized view';


--
-- Name: get_user_trust_level(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_user_trust_level(p_user_id uuid DEFAULT NULL::uuid) RETURNS integer
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
DECLARE
  v_level INTEGER;
BEGIN
  SELECT current_level INTO v_level
  FROM forum_trust_progress
  WHERE profile_id = COALESCE(p_user_id, auth.uid());
  
  RETURN COALESCE(v_level, 0);
END;
$$;


--
-- Name: get_user_vault_access_summary(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_user_vault_access_summary(user_uuid uuid DEFAULT auth.uid()) RETURNS jsonb
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'audit', 'public'
    AS $$
DECLARE
  summary jsonb;
  total_requests integer;
  failed_requests integer;
  last_request timestamptz;
  most_requested text;
BEGIN
  -- Count total requests
  SELECT COUNT(*) INTO total_requests
  FROM audit.vault_access_log
  WHERE user_id = user_uuid;
  
  -- Count failed requests
  SELECT COUNT(*) INTO failed_requests
  FROM audit.vault_access_log
  WHERE user_id = user_uuid
    AND access_granted = false;
  
  -- Get last request time
  SELECT MAX(accessed_at) INTO last_request
  FROM audit.vault_access_log
  WHERE user_id = user_uuid;
  
  -- Get most requested secret
  SELECT secret_name INTO most_requested
  FROM audit.vault_access_log
  WHERE user_id = user_uuid
  GROUP BY secret_name
  ORDER BY COUNT(*) DESC
  LIMIT 1;
  
  -- Build summary
  summary := jsonb_build_object(
    'user_id', user_uuid,
    'total_requests', total_requests,
    'failed_requests', failed_requests,
    'success_rate', 
      CASE 
        WHEN total_requests > 0 THEN 
          ROUND((total_requests - failed_requests)::numeric / total_requests::numeric * 100, 2)
        ELSE 0
      END,
    'last_request', last_request,
    'most_requested_secret', most_requested
  );
  
  RETURN summary;
END;
$$;


--
-- Name: FUNCTION get_user_vault_access_summary(user_uuid uuid); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.get_user_vault_access_summary(user_uuid uuid) IS 'Get vault access summary statistics for a specific user.

SECURITY:
- Accessible by service_role only
- Returns aggregated statistics only
- Used for monitoring and debugging

USAGE (Edge Functions):
  const summary = await supabase.rpc("get_user_vault_access_summary", {
    user_uuid: user.id
  });

PARAMETERS:
- user_uuid: UUID of user (defaults to auth.uid())

RETURNS:
- JSONB with total_requests, failed_requests, success_rate, last_request, most_requested_secret';


--
-- Name: get_vault_failure_count(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_vault_failure_count(p_hours integer DEFAULT 1) RETURNS integer
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public', 'pg_temp'
    AS $$
DECLARE
    v_count INT;
BEGIN
    SELECT COUNT(*)::INT INTO v_count
    FROM audit.vault_access_log
    WHERE access_result = 'denied'
      AND created_at > now() - (p_hours || ' hours')::INTERVAL;

    RETURN COALESCE(v_count, 0);
EXCEPTION WHEN OTHERS THEN
    RETURN 0;
END;
$$;


--
-- Name: FUNCTION get_vault_failure_count(p_hours integer); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.get_vault_failure_count(p_hours integer) IS 'Returns count of vault access failures in last N hours';


--
-- Name: get_vault_secret(text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_vault_secret(secret_name text) RETURNS text
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO ''
    AS $$
DECLARE
  secret_value text;
BEGIN
  SELECT decrypted_secret INTO secret_value
  FROM vault.decrypted_secrets
  WHERE name = secret_name;
  
  RETURN secret_value;
END;
$$;


--
-- Name: handle_comment_delete(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.handle_comment_delete() RETURNS trigger
    LANGUAGE plpgsql
    SET search_path TO ''
    AS $$
BEGIN
  -- Update parent's replies count
  IF OLD.parent_id IS NOT NULL THEN
    UPDATE public.comments
    SET replies_count = GREATEST(replies_count - 1, 0)
    WHERE id = OLD.parent_id;
  END IF;
  
  -- Update forum comments counter
  IF OLD.forum_id IS NOT NULL THEN
    UPDATE public.forum
    SET forum_comments_counter = GREATEST(COALESCE(forum_comments_counter, 0) - 1, 0)
    WHERE id = OLD.forum_id;
  END IF;
  
  RETURN OLD;
END;
$$;


--
-- Name: handle_comment_insert(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.handle_comment_insert() RETURNS trigger
    LANGUAGE plpgsql
    SET search_path TO ''
    AS $$
BEGIN
  -- Calculate depth based on parent
  IF NEW.parent_id IS NOT NULL THEN
    SELECT depth + 1 INTO NEW.depth
    FROM public.comments
    WHERE id = NEW.parent_id;
    
    -- Prevent too deep nesting
    IF NEW.depth > 2 THEN
      NEW.depth := 2;
      -- Set parent to the grandparent to flatten
      SELECT parent_id INTO NEW.parent_id
      FROM public.comments
      WHERE id = NEW.parent_id;
    END IF;
    
    -- Update parent's replies count
    UPDATE public.comments
    SET replies_count = replies_count + 1
    WHERE id = NEW.parent_id;
  ELSE
    NEW.depth := 0;
  END IF;
  
  -- Update forum comments counter
  IF NEW.forum_id IS NOT NULL THEN
    UPDATE public.forum
    SET forum_comments_counter = COALESCE(forum_comments_counter, 0) + 1
    WHERE id = NEW.forum_id;
  END IF;
  
  RETURN NEW;
END;
$$;


--
-- Name: handle_new_user(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.handle_new_user() RETURNS trigger
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public', 'extensions'
    AS $$
DECLARE
  signup_lat double precision;
  signup_lon double precision;
  user_location extensions.geography;
BEGIN
  -- Extract signup location from user_metadata if available
  -- This is populated by the geolocate-user edge function via before-user-created hook
  signup_lat := (new.raw_user_meta_data->'signup_location'->>'latitude')::double precision;
  signup_lon := (new.raw_user_meta_data->'signup_location'->>'longitude')::double precision;
  
  -- Create PostGIS point if coordinates are valid
  IF signup_lat IS NOT NULL AND signup_lon IS NOT NULL 
     AND signup_lat >= -90 AND signup_lat <= 90 
     AND signup_lon >= -180 AND signup_lon <= 180 THEN
    user_location := extensions.ST_SetSRID(extensions.ST_MakePoint(signup_lon, signup_lat), 4326)::extensions.geography;
  ELSE
    user_location := NULL;
  END IF;

  -- Insert profile with location
  INSERT INTO public.profiles (id, email, location)
  VALUES (new.id, new.email, user_location)
  ON CONFLICT (id) DO UPDATE SET
    location = COALESCE(profiles.location, EXCLUDED.location);
  
  RETURN new;
END;
$$;


--
-- Name: FUNCTION handle_new_user(); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.handle_new_user() IS 'Creates a profile when a new user signs up. Copies signup location from user_metadata (populated by geolocate-user edge function) to profiles.location column.';


--
-- Name: handle_new_user_notifications(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.handle_new_user_notifications() RETURNS trigger
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
BEGIN
  PERFORM init_notification_preferences(NEW.id);
  RETURN NEW;
END;
$$;


--
-- Name: handle_new_user_to_address(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.handle_new_user_to_address() RETURNS trigger
    LANGUAGE plpgsql
    SET search_path TO 'public'
    AS $$
BEGIN
  INSERT INTO public.address (profile_id)
  VALUES (NEW.id)
  ON CONFLICT (profile_id) DO NOTHING;
  RETURN NEW;
END;
$$;


--
-- Name: handle_post_delete(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.handle_post_delete() RETURNS trigger
    LANGUAGE plpgsql
    SET search_path TO 'public'
    AS $$
BEGIN
  DELETE FROM public.views WHERE post_id = OLD.id;
  DELETE FROM public.likes WHERE post_id = OLD.id;
  DELETE FROM public.reviews WHERE post_id = OLD.id;
  RETURN OLD;
END;
$$;


--
-- Name: has_any_role(uuid, text[]); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.has_any_role(user_id uuid, role_names text[]) RETURNS boolean
    LANGUAGE sql STABLE SECURITY DEFINER
    SET search_path TO ''
    AS $$
  SELECT EXISTS (
    SELECT 1
    FROM public.user_roles ur
    JOIN public.roles r ON ur.role_id = r.id
    WHERE ur.profile_id = user_id
      AND r.name = ANY(role_names)
  );
$$;


--
-- Name: FUNCTION has_any_role(user_id uuid, role_names text[]); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.has_any_role(user_id uuid, role_names text[]) IS 'Check if a user has any of the specified roles';


--
-- Name: has_block_relationship(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.has_block_relationship(p_user_id uuid) RETURNS boolean
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
BEGIN
  RETURN EXISTS (
    SELECT 1 FROM forum_user_blocks
    WHERE (blocker_id = auth.uid() AND blocked_id = p_user_id)
       OR (blocker_id = p_user_id AND blocked_id = auth.uid())
  );
END;
$$;


--
-- Name: FUNCTION has_block_relationship(p_user_id uuid); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.has_block_relationship(p_user_id uuid) IS 'Check if any block exists between two users';


--
-- Name: has_role(uuid, text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.has_role(user_id uuid, role_name text) RETURNS boolean
    LANGUAGE sql STABLE SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
  SELECT EXISTS (
    SELECT 1 
    FROM user_roles ur
    JOIN roles r ON ur.role_id = r.id
    WHERE ur.profile_id = user_id
    AND r.name = role_name
  );
$$;


--
-- Name: FUNCTION has_role(user_id uuid, role_name text); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.has_role(user_id uuid, role_name text) IS 'Check if user has a specific role. Uses user_roles table (migrated from deprecated profiles.role JSONB column).';


--
-- Name: hash_mfa_code(text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.hash_mfa_code(code text) RETURNS text
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO ''
    AS $$
BEGIN
  RETURN crypt(code, gen_salt('bf', 10));
END;
$$;


--
-- Name: http_wrapper(text, text, text[], text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.http_wrapper(method text, url text, headers text[], body text) RETURNS json
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'extensions', 'public', 'pg_temp'
    AS $$
DECLARE
  result json;
BEGIN
  SELECT content::json INTO result
  FROM extensions.http((method, url, headers, body, 10)::extensions.http_request);
  RETURN result;
END;
$$;


--
-- Name: increment_challenge_views(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.increment_challenge_views(p_challenge_id integer) RETURNS json
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
DECLARE
    v_new_count INTEGER;
BEGIN
    UPDATE challenges SET challenge_views = COALESCE(challenge_views, 0) + 1
    WHERE id = p_challenge_id
    RETURNING challenge_views INTO v_new_count;

    IF v_new_count IS NULL THEN
        RETURN json_build_object('success', false, 'error', json_build_object('code', 'CHALLENGE_NOT_FOUND', 'message', 'Challenge not found'));
    END IF;

    RETURN json_build_object('success', true, 'view_count', v_new_count);
END;
$$;


--
-- Name: increment_challenged_people(bigint); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.increment_challenged_people(p_challenge_id bigint) RETURNS void
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO ''
    AS $$
BEGIN
  UPDATE challenges
  SET challenged_people = challenged_people + 1
  WHERE id = p_challenge_id;
END;
$$;


--
-- Name: increment_email_provider_stats(text, boolean, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.increment_email_provider_stats(p_provider text, p_success boolean, p_latency_ms integer DEFAULT 0) RETURNS void
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
BEGIN
  INSERT INTO email_provider_stats (
    provider, date, requests_total, requests_success, requests_failed,
    emails_sent, avg_latency_ms, total_latency_ms
  )
  VALUES (
    p_provider, CURRENT_DATE, 1,
    CASE WHEN p_success THEN 1 ELSE 0 END,
    CASE WHEN p_success THEN 0 ELSE 1 END,
    CASE WHEN p_success THEN 1 ELSE 0 END,
    p_latency_ms, p_latency_ms
  )
  ON CONFLICT (provider, date) DO UPDATE SET
    requests_total = email_provider_stats.requests_total + 1,
    requests_success = email_provider_stats.requests_success + CASE WHEN p_success THEN 1 ELSE 0 END,
    requests_failed = email_provider_stats.requests_failed + CASE WHEN p_success THEN 0 ELSE 1 END,
    emails_sent = email_provider_stats.emails_sent + CASE WHEN p_success THEN 1 ELSE 0 END,
    total_latency_ms = email_provider_stats.total_latency_ms + p_latency_ms,
    avg_latency_ms = CASE
      WHEN email_provider_stats.requests_total > 0
      THEN ((email_provider_stats.total_latency_ms + p_latency_ms) / (email_provider_stats.requests_total + 1))::integer
      ELSE p_latency_ms
    END,
    updated_at = now();
END;
$$;


--
-- Name: FUNCTION increment_email_provider_stats(p_provider text, p_success boolean, p_latency_ms integer); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.increment_email_provider_stats(p_provider text, p_success boolean, p_latency_ms integer) IS 'Called after each email send attempt to track provider performance';


--
-- Name: increment_forum_likes(bigint); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.increment_forum_likes(forum_id bigint) RETURNS void
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
BEGIN
  UPDATE forum
  SET forum_likes_counter = COALESCE(forum_likes_counter, 0) + 1
  WHERE id = forum_id;
END;
$$;


--
-- Name: increment_forum_view(bigint); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.increment_forum_view(p_forum_id bigint) RETURNS void
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
BEGIN
  UPDATE public.forum
  SET views_count = COALESCE(views_count, 0) + 1
  WHERE id = p_forum_id;
END;
$$;


--
-- Name: increment_forum_views(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.increment_forum_views(p_forum_id integer) RETURNS json
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
DECLARE
    v_new_count INTEGER;
BEGIN
    UPDATE forum SET views_count = COALESCE(views_count, 0) + 1
    WHERE id = p_forum_id AND deleted_at IS NULL
    RETURNING views_count INTO v_new_count;

    IF v_new_count IS NULL THEN
        RETURN json_build_object('success', false, 'error', json_build_object('code', 'FORUM_NOT_FOUND', 'message', 'Forum post not found'));
    END IF;

    RETURN json_build_object('success', true, 'view_count', v_new_count);
END;
$$;


--
-- Name: increment_monthly_quota(text, uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.increment_monthly_quota(p_provider text, p_organization_id uuid DEFAULT '00000000-0000-0000-0000-000000000001'::uuid) RETURNS integer
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO ''
    AS $$
DECLARE
  v_year_month text;
  v_emails_sent integer;
  v_monthly_limit integer;
BEGIN
  v_year_month := to_char(CURRENT_DATE, 'YYYY-MM');
  
  v_monthly_limit := CASE p_provider
    WHEN 'resend' THEN 3000
    WHEN 'brevo' THEN 9000
    WHEN 'aws_ses' THEN 62000
    ELSE 1000
  END;

  INSERT INTO public.email_provider_monthly_quota (provider, year_month, emails_sent, monthly_limit, organization_id)
  VALUES (p_provider, v_year_month, 1, v_monthly_limit, p_organization_id)
  ON CONFLICT (provider, year_month, organization_id)
  DO UPDATE SET
    emails_sent = public.email_provider_monthly_quota.emails_sent + 1,
    updated_at = now()
  RETURNING emails_sent INTO v_emails_sent;

  RETURN v_emails_sent;
END;
$$;


--
-- Name: increment_post_views(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.increment_post_views(p_post_id integer) RETURNS json
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
DECLARE
    v_user_id UUID;
    v_new_count INTEGER;
BEGIN
    v_user_id := auth.uid();

    -- Update view count on posts table
    UPDATE posts
    SET post_views = COALESCE(post_views, 0) + 1
    WHERE id = p_post_id
    RETURNING post_views INTO v_new_count;

    IF v_new_count IS NULL THEN
        RETURN json_build_object('success', false, 'error', json_build_object('code', 'POST_NOT_FOUND', 'message', 'Post not found'));
    END IF;

    -- Record view in unified views table (for analytics)
    IF v_user_id IS NOT NULL THEN
        INSERT INTO views (post_id, profile_id, forum_id, challenge_id)
        VALUES (p_post_id, v_user_id, 0, 0)
        ON CONFLICT DO NOTHING;
    END IF;

    RETURN json_build_object(
        'success', true,
        'view_count', v_new_count
    );
END;
$$;


--
-- Name: FUNCTION increment_post_views(p_post_id integer); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.increment_post_views(p_post_id integer) IS 'Increment view count for a post. Records in unified views table.';


--
-- Name: increment_post_views(bigint); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.increment_post_views(IN post_id bigint)
    LANGUAGE plpgsql
    SET search_path TO ''
    AS $$
BEGIN
  -- Procedure logic would go here 
  RAISE LOG 'Incrementing views for post %', post_id;
END;
$$;


--
-- Name: increment_provider_quota(text, date); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.increment_provider_quota(p_provider text, p_date date DEFAULT CURRENT_DATE) RETURNS integer
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
DECLARE
  v_emails_sent INTEGER;
  v_daily_limit INTEGER;
  v_monthly_limit INTEGER;
BEGIN
  -- Get the daily and monthly limits for the provider
  SELECT
    CASE p_provider
      WHEN 'resend' THEN 100
      WHEN 'brevo' THEN 300
      WHEN 'mailersend' THEN 400
      WHEN 'aws_ses' THEN 100
      ELSE 0
    END,
    CASE p_provider
      WHEN 'resend' THEN 3000
      WHEN 'brevo' THEN 9000
      WHEN 'mailersend' THEN 12000
      WHEN 'aws_ses' THEN 62000
      ELSE 0
    END
  INTO v_daily_limit, v_monthly_limit;

  -- Insert or update the quota record
  INSERT INTO public.email_provider_quota (provider, date, emails_sent, daily_limit, monthly_limit)
  VALUES (p_provider, p_date, 1, v_daily_limit, v_monthly_limit)
  ON CONFLICT (provider, date)
  DO UPDATE SET
    emails_sent = public.email_provider_quota.emails_sent + 1,
    updated_at = now()
  RETURNING emails_sent INTO v_emails_sent;

  RETURN v_emails_sent;
END;
$$;


--
-- Name: increment_provider_quota(text, date, uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.increment_provider_quota(p_provider text, p_date date DEFAULT CURRENT_DATE, p_organization_id uuid DEFAULT '00000000-0000-0000-0000-000000000001'::uuid) RETURNS integer
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
DECLARE
  v_emails_sent INTEGER;
  v_daily_limit INTEGER;
BEGIN
  v_daily_limit := CASE p_provider
    WHEN 'resend' THEN 100
    WHEN 'brevo' THEN 300
    WHEN 'aws_ses' THEN 100
    ELSE 100
  END;

  -- Increment daily quota
  INSERT INTO public.email_provider_quota (provider, date, emails_sent, daily_limit, organization_id)
  VALUES (p_provider, p_date, 1, v_daily_limit, p_organization_id)
  ON CONFLICT (provider, date, organization_id)
  DO UPDATE SET
    emails_sent = public.email_provider_quota.emails_sent + 1,
    updated_at = now()
  RETURNING emails_sent INTO v_emails_sent;

  -- Also increment monthly quota
  PERFORM public.increment_monthly_quota(p_provider, p_organization_id);

  RETURN v_emails_sent;
END;
$$;


--
-- Name: increment_translation_usage(text, text, bigint, bigint); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.increment_translation_usage(p_service text, p_month text, p_chars bigint, p_limit bigint) RETURNS TABLE(chars_used bigint, free_limit bigint, remaining bigint)
    LANGUAGE plpgsql
    AS $$
BEGIN
  INSERT INTO translation_service_usage (service_name, month_year, chars_used, free_limit)
  VALUES (p_service, p_month, p_chars, p_limit)
  ON CONFLICT (service_name, month_year)
  DO UPDATE SET
    chars_used = translation_service_usage.chars_used + p_chars,
    updated_at = NOW();

  RETURN QUERY
  SELECT
    t.chars_used,
    t.free_limit,
    t.free_limit - t.chars_used as remaining
  FROM translation_service_usage t
  WHERE t.service_name = p_service AND t.month_year = p_month;
END;
$$;


--
-- Name: increment_view_count(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.increment_view_count(item_id integer) RETURNS void
    LANGUAGE plpgsql
    SET search_path TO ''
    AS $$
BEGIN
  UPDATE public.posts
  SET post_views = post_views + 1
  WHERE id = item_id;
END;
$$;


--
-- Name: increment_view_count(bigint); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.increment_view_count(item_id bigint) RETURNS void
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO ''
    AS $$
BEGIN
    UPDATE public.food_items
    SET 
        view_count = view_count + 1,
        updated_at = NOW()
    WHERE id = item_id;
END;
$$;


--
-- Name: FUNCTION increment_view_count(item_id bigint); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.increment_view_count(item_id bigint) IS 'Increment view count for a food item';


--
-- Name: init_notification_preferences(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.init_notification_preferences(p_user_id uuid) RETURNS void
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
BEGIN
  -- Create global settings if not exists
  INSERT INTO notification_settings (user_id)
  VALUES (p_user_id)
  ON CONFLICT (user_id) DO NOTHING;

  -- Create default preferences for each category/channel
  INSERT INTO notification_preferences (user_id, category, channel, enabled, frequency)
  VALUES
    -- Posts
    (p_user_id, 'posts', 'push', true, 'instant'),
    (p_user_id, 'posts', 'email', true, 'daily'),
    (p_user_id, 'posts', 'sms', false, 'never'),
    -- Forum
    (p_user_id, 'forum', 'push', true, 'instant'),
    (p_user_id, 'forum', 'email', true, 'daily'),
    (p_user_id, 'forum', 'sms', false, 'never'),
    -- Challenges
    (p_user_id, 'challenges', 'push', true, 'instant'),
    (p_user_id, 'challenges', 'email', true, 'instant'),
    (p_user_id, 'challenges', 'sms', false, 'never'),
    -- Comments
    (p_user_id, 'comments', 'push', true, 'instant'),
    (p_user_id, 'comments', 'email', true, 'hourly'),
    (p_user_id, 'comments', 'sms', false, 'never'),
    -- Chats
    (p_user_id, 'chats', 'push', true, 'instant'),
    (p_user_id, 'chats', 'email', false, 'never'),
    (p_user_id, 'chats', 'sms', false, 'never'),
    -- Social
    (p_user_id, 'social', 'push', true, 'instant'),
    (p_user_id, 'social', 'email', true, 'daily'),
    (p_user_id, 'social', 'sms', false, 'never'),
    -- System
    (p_user_id, 'system', 'push', true, 'instant'),
    (p_user_id, 'system', 'email', true, 'instant'),
    (p_user_id, 'system', 'sms', false, 'never'),
    -- Marketing
    (p_user_id, 'marketing', 'push', false, 'never'),
    (p_user_id, 'marketing', 'email', false, 'weekly'),
    (p_user_id, 'marketing', 'sms', false, 'never')
  ON CONFLICT (user_id, category, channel) DO NOTHING;
END;
$$;


--
-- Name: insert_creator_into_room(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.insert_creator_into_room() RETURNS trigger
    LANGUAGE plpgsql
    SET search_path TO 'public'
    AS $$
BEGIN
  INSERT INTO public.room_participants (profile_id, room_id)
  VALUES (NEW.requester, NEW.id), (NEW.sharer, NEW.id);
  RETURN NEW;
END;
$$;


--
-- Name: invoke_image_compression(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.invoke_image_compression() RETURNS void
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO ''
    AS $$
DECLARE
  v_request_id bigint;
  v_pending_count int;
  v_bucket text;
  v_buckets text[] := ARRAY['posts', 'profiles', 'forum'];
BEGIN
  SELECT COUNT(*) INTO v_pending_count
  FROM storage.objects so
  WHERE so.bucket_id = ANY(v_buckets)
    AND (so.metadata->>'size')::BIGINT > 100000
    AND so.metadata->>'mimetype' LIKE 'image/%'
    AND NOT EXISTS (
      SELECT 1 FROM public.image_compressions ic 
      WHERE ic.bucket = so.bucket_id 
        AND ic.original_path = so.name
        AND ic.status IN ('completed', 'processing', 'failed', 'skipped')
    );

  IF v_pending_count > 0 THEN
    SELECT so.bucket_id INTO v_bucket
    FROM storage.objects so
    WHERE so.bucket_id = ANY(v_buckets)
      AND (so.metadata->>'size')::BIGINT > 100000
      AND so.metadata->>'mimetype' LIKE 'image/%'
      AND NOT EXISTS (
        SELECT 1 FROM public.image_compressions ic 
        WHERE ic.bucket = so.bucket_id 
          AND ic.original_path = so.name
          AND ic.status IN ('completed', 'processing', 'failed', 'skipped')
      )
    ORDER BY (so.metadata->>'size')::bigint DESC
    LIMIT 1;

    SELECT net.http_post(
      url := format('https://***REMOVED***/functions/v1/resize-tinify-upload-image?mode=batch&bucket=%s&limit=3&concurrency=3', v_bucket),
      headers := '{"Content-Type": "application/json"}'::jsonb,
      body := '{}'::jsonb,
      timeout_milliseconds := 120000
    ) INTO v_request_id;
    
    RAISE NOTICE 'Compression job: bucket=%, pending=%, request=%', v_bucket, v_pending_count, v_request_id;
  ELSE
    RAISE NOTICE 'No pending images to compress';
  END IF;
END;
$$;


--
-- Name: FUNCTION invoke_image_compression(); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.invoke_image_compression() IS 'Invokes edge function to compress 1 large image. Runs every 2 minutes via cron.';


--
-- Name: invoke_update_post_coordinates(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.invoke_update_post_coordinates() RETURNS void
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
BEGIN
  -- Placeholder for edge function invocation
  -- This would typically call an edge function to geocode addresses
  RAISE NOTICE 'Geocoding function invoked';
END;
$$;


--
-- Name: invoke_upstash_health_check(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.invoke_upstash_health_check() RETURNS void
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
BEGIN
  -- Placeholder for edge function invocation
  RAISE NOTICE 'Upstash health check invoked';
END;
$$;


--
-- Name: is_admin(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.is_admin() RETURNS boolean
    LANGUAGE sql STABLE SECURITY DEFINER
    AS $$
  SELECT EXISTS (
    SELECT 1
    FROM public.user_roles ur
    JOIN public.roles r ON ur.role_id = r.id
    WHERE ur.profile_id = (SELECT auth.uid())
    AND r.name IN ('admin', 'superadmin')
  );
$$;


--
-- Name: FUNCTION is_admin(); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.is_admin() IS 'Check if current user has admin or superadmin role via user_roles table';


--
-- Name: is_admin(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.is_admin(user_id uuid) RETURNS boolean
    LANGUAGE sql STABLE SECURITY DEFINER
    SET search_path TO 'public', 'pg_temp'
    AS $$
  SELECT EXISTS (
    SELECT 1 
    FROM user_roles ur
    JOIN roles r ON ur.role_id = r.id
    WHERE ur.profile_id = user_id 
    AND r.name = 'admin'
  );
$$;


--
-- Name: is_admin_jsonb(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.is_admin_jsonb() RETURNS boolean
    LANGUAGE sql STABLE SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
  SELECT EXISTS (
    SELECT 1 
    FROM user_roles ur
    JOIN roles r ON ur.role_id = r.id
    WHERE ur.profile_id = auth.uid()
    AND r.name IN ('admin', 'superadmin')
  );
$$;


--
-- Name: FUNCTION is_admin_jsonb(); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.is_admin_jsonb() IS 'Check if current user is admin (legacy name). Uses user_roles table (migrated from deprecated profiles.role JSONB column).';


--
-- Name: is_blocked_by_user(uuid, uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.is_blocked_by_user(p_user_id uuid, p_target_user_id uuid) RETURNS boolean
    LANGUAGE plpgsql STABLE SECURITY DEFINER
    AS $$
BEGIN
    -- Check both directions: if user blocked target OR target blocked user
    RETURN EXISTS (
        SELECT 1 FROM blocked_users
        WHERE (user_id = p_user_id AND blocked_user_id = p_target_user_id)
           OR (user_id = p_target_user_id AND blocked_user_id = p_user_id)
    );
END;
$$;


--
-- Name: FUNCTION is_blocked_by_user(p_user_id uuid, p_target_user_id uuid); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.is_blocked_by_user(p_user_id uuid, p_target_user_id uuid) IS 'Check if users have blocked each other (bidirectional)';


--
-- Name: is_email_suppressed(text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.is_email_suppressed(p_email text) RETURNS boolean
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO ''
    AS $$
BEGIN
  RETURN EXISTS (
    SELECT 1 FROM public.email_suppression_list
    WHERE email = lower(p_email)
    AND (expires_at IS NULL OR expires_at > now())
  );
END;
$$;


--
-- Name: is_room_participant(bigint, uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.is_room_participant(room_id bigint, profile_id uuid) RETURNS boolean
    LANGUAGE sql STABLE SECURITY DEFINER
    SET search_path TO ''
    AS $$select exists (
  select 1
  from room_participants rp
  where rp.room_id = is_room_participant.room_id
  and rp.profile_id = is_room_participant.profile_id
);$$;


--
-- Name: is_room_participant(text, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.is_room_participant(profile_id text, room_id integer) RETURNS boolean
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO ''
    AS $$
DECLARE
  is_participant boolean;
BEGIN
  SELECT EXISTS(
    SELECT 1 FROM public.room_participants
    WHERE room_participants.profile_id = is_room_participant.profile_id
      AND room_participants.room_id::integer = is_room_participant.room_id
  ) INTO is_participant;
  
  RETURN is_participant;
END;
$$;


--
-- Name: is_user_blocked(uuid, uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.is_user_blocked(p_user_id uuid, p_target_user_id uuid) RETURNS boolean
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
BEGIN
    RETURN EXISTS (
        SELECT 1 FROM blocked_users
        WHERE user_id = p_user_id
        AND blocked_user_id = p_target_user_id
    );
END;
$$;


--
-- Name: is_valid_locale(character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.is_valid_locale(p_locale character varying) RETURNS boolean
    LANGUAGE sql IMMUTABLE
    SET search_path TO ''
    AS $$
  SELECT p_locale = ANY(ARRAY[
    'en', 'cs', 'de', 'es', 'fr', 'pt', 'ru', 'uk',
    'zh', 'hi', 'ar', 'it', 'pl', 'nl', 'ja', 'ko', 'tr'
  ]::VARCHAR[]);
$$;


--
-- Name: join_challenge(uuid, bigint); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.join_challenge(p_user_id uuid, p_challenge_id bigint) RETURNS jsonb
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
DECLARE
  v_challenge_exists BOOLEAN;
  v_already_joined BOOLEAN;
  v_creator_id UUID;
  v_challenge_title TEXT;
BEGIN
  SELECT TRUE, profile_id, challenge_title
  INTO v_challenge_exists, v_creator_id, v_challenge_title
  FROM challenges WHERE id = p_challenge_id AND challenge_published = TRUE;

  IF NOT COALESCE(v_challenge_exists, FALSE) THEN
    RETURN jsonb_build_object('success', FALSE, 'error', 'Challenge not found');
  END IF;

  SELECT EXISTS(SELECT 1 FROM challenge_participants WHERE challenge_id = p_challenge_id AND profile_id = p_user_id)
  INTO v_already_joined;

  IF v_already_joined THEN
    RETURN jsonb_build_object('success', FALSE, 'error', 'Already joined this challenge');
  END IF;

  INSERT INTO challenge_participants (challenge_id, profile_id, accepted_at, is_completed)
  VALUES (p_challenge_id, p_user_id, NOW(), FALSE);

  UPDATE challenges SET challenged_people = challenged_people + 1 WHERE id = p_challenge_id;

  IF v_creator_id != p_user_id THEN
    INSERT INTO user_notifications (
      user_id, notification_type, title, body, data, created_at
    ) VALUES (
      v_creator_id,
      'challenge_joined',
      'New challenger!',
      (SELECT COALESCE(nickname, first_name, 'Someone') FROM profiles WHERE id = p_user_id) || ' joined your challenge "' || v_challenge_title || '"',
      jsonb_build_object('challengeId', p_challenge_id, 'userId', p_user_id),
      NOW()
    );
  END IF;

  RETURN jsonb_build_object(
    'success', TRUE,
    'message', 'Successfully joined challenge',
    'participation', jsonb_build_object(
      'challengeId', p_challenge_id,
      'joinedAt', NOW(),
      'isCompleted', FALSE
    )
  );
END;
$$;


--
-- Name: jsonb_add_missing(jsonb, jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.jsonb_add_missing(target jsonb, source jsonb) RETURNS jsonb
    LANGUAGE plpgsql IMMUTABLE
    AS $$
DECLARE
  result jsonb;
  key text;
  target_val jsonb;
  source_val jsonb;
BEGIN
  IF target IS NULL THEN RETURN source; END IF;
  IF source IS NULL THEN RETURN target; END IF;
  IF jsonb_typeof(target) != 'object' OR jsonb_typeof(source) != 'object' THEN
    RETURN target;
  END IF;
  
  result := target;
  
  FOR key IN SELECT jsonb_object_keys(source)
  LOOP
    target_val := target->key;
    source_val := source->key;
    
    IF target_val IS NULL THEN
      -- Key missing in target, add from source
      result := jsonb_set(result, ARRAY[key], source_val);
    ELSIF jsonb_typeof(target_val) = 'object' AND jsonb_typeof(source_val) = 'object' THEN
      -- Both are objects, recurse
      result := jsonb_set(result, ARRAY[key], jsonb_add_missing(target_val, source_val));
    END IF;
    -- If key exists in target, keep target's value (don't overwrite)
  END LOOP;
  
  RETURN result;
END;
$$;


--
-- Name: jsonb_deep_merge(jsonb, jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.jsonb_deep_merge(a jsonb, b jsonb) RETURNS jsonb
    LANGUAGE plpgsql IMMUTABLE
    AS $$
DECLARE
  result jsonb;
  key text;
  a_val jsonb;
  b_val jsonb;
BEGIN
  -- If either is null, return the other
  IF a IS NULL THEN RETURN b; END IF;
  IF b IS NULL THEN RETURN a; END IF;
  
  -- If both are not objects, prefer a (existing value)
  IF jsonb_typeof(a) != 'object' OR jsonb_typeof(b) != 'object' THEN
    RETURN a;
  END IF;
  
  -- Start with a
  result := a;
  
  -- Merge keys from b
  FOR key IN SELECT jsonb_object_keys(b)
  LOOP
    a_val := a->key;
    b_val := b->key;
    
    IF a_val IS NULL THEN
      -- Key only in b, add it
      result := jsonb_set(result, ARRAY[key], b_val);
    ELSIF jsonb_typeof(a_val) = 'object' AND jsonb_typeof(b_val) = 'object' THEN
      -- Both are objects, recurse
      result := jsonb_set(result, ARRAY[key], jsonb_deep_merge(a_val, b_val));
    END IF;
    -- If key exists in a and is not an object, keep a's value
  END LOOP;
  
  RETURN result;
END;
$$;


--
-- Name: jsonb_set(text, text, json); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.jsonb_set(field text, path text, value json) RETURNS void
    LANGUAGE plpgsql
    SET search_path TO ''
    AS $$
BEGIN
  -- Placeholder function
  RAISE NOTICE 'jsonb_set called with field: %, path: %', field, path;
END;
$$;


--
-- Name: jsonb_set(text, text, jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.jsonb_set(field text, path text, value jsonb) RETURNS void
    LANGUAGE plpgsql
    SET search_path TO ''
    AS $$
BEGIN
  EXECUTE format('UPDATE telegram_user_activity SET %I = jsonb_set(%I, %L, %L)', field, field, path, value);
END;
$$;


--
-- Name: lat_lng_to_geohash(double precision, double precision, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.lat_lng_to_geohash(p_lat double precision, p_lng double precision, p_precision integer DEFAULT 5) RETURNS text
    LANGUAGE plpgsql IMMUTABLE
    SET search_path TO 'public', 'pg_temp'
    AS $$
DECLARE
  v_lat_bin text := '';
  v_lng_bin text := '';
  v_combined text := '';
  v_hash text := '';
  v_base32 text := '0123456789bcdefghjkmnpqrstuvwxyz';
  v_lat_min double precision := -90;
  v_lat_max double precision := 90;
  v_lng_min double precision := -180;
  v_lng_max double precision := 180;
  v_lat_mid double precision;
  v_lng_mid double precision;
  v_bits integer;
  v_char_idx integer;
  i integer;
  j integer;
BEGIN
  -- Calculate required bits (5 bits per character)
  v_bits := p_precision * 5;

  -- Generate latitude and longitude bit strings
  FOR i IN 1..v_bits LOOP
    -- Longitude bit (even positions)
    v_lng_mid := (v_lng_min + v_lng_max) / 2;
    IF p_lng >= v_lng_mid THEN
      v_lng_bin := v_lng_bin || '1';
      v_lng_min := v_lng_mid;
    ELSE
      v_lng_bin := v_lng_bin || '0';
      v_lng_max := v_lng_mid;
    END IF;

    -- Latitude bit (odd positions)
    v_lat_mid := (v_lat_min + v_lat_max) / 2;
    IF p_lat >= v_lat_mid THEN
      v_lat_bin := v_lat_bin || '1';
      v_lat_min := v_lat_mid;
    ELSE
      v_lat_bin := v_lat_bin || '0';
      v_lat_max := v_lat_mid;
    END IF;
  END LOOP;

  -- Interleave longitude and latitude bits
  FOR i IN 1..v_bits LOOP
    v_combined := v_combined || substring(v_lng_bin, i, 1) || substring(v_lat_bin, i, 1);
  END LOOP;

  -- Convert to base32
  FOR i IN 0..(p_precision - 1) LOOP
    v_char_idx := 0;
    FOR j IN 1..5 LOOP
      v_char_idx := v_char_idx * 2;
      IF substring(v_combined, i * 5 + j, 1) = '1' THEN
        v_char_idx := v_char_idx + 1;
      END IF;
    END LOOP;
    v_hash := v_hash || substring(v_base32, v_char_idx + 1, 1);
  END LOOP;

  RETURN v_hash;
END;
$$;


--
-- Name: FUNCTION lat_lng_to_geohash(p_lat double precision, p_lng double precision, p_precision integer); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.lat_lng_to_geohash(p_lat double precision, p_lng double precision, p_precision integer) IS 'Converts lat/lng to geohash for cell-based caching';


--
-- Name: list_email_templates(text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.list_email_templates(p_category text DEFAULT NULL::text) RETURNS TABLE(id uuid, slug text, name text, category text, subject text, variables jsonb, metadata jsonb, version integer, updated_at timestamp with time zone)
    LANGUAGE plpgsql STABLE SECURITY DEFINER
    AS $$
BEGIN
  RETURN QUERY SELECT et.id, et.slug, et.name, et.category, et.subject, et.variables, et.metadata, et.version, et.updated_at
  FROM email_templates et WHERE et.is_active = true AND (p_category IS NULL OR et.category = p_category) ORDER BY et.name;
END;
$$;


--
-- Name: list_required_secrets(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.list_required_secrets() RETURNS TABLE(secret_name text, secret_exists boolean, description text, is_whitelisted boolean)
    LANGUAGE sql SECURITY DEFINER
    SET search_path TO 'vault', 'public'
    AS $$
  SELECT 
    required.name,
    vault.secrets.name IS NOT NULL as secret_exists,
    required.description,
    required.is_whitelisted
  FROM (
    VALUES 
      ('UPSTASH_REDIS_URL', 'Upstash Redis REST endpoint (alias)', true),
      ('UPSTASH_REDIS_TOKEN', 'Upstash Redis authentication token (alias)', true),
      ('UPSTASH_REDIS_REST_URL', 'Upstash Redis REST endpoint', true),
      ('UPSTASH_REDIS_REST_TOKEN', 'Upstash Redis authentication token', true),
      ('RESEND_API_KEY', 'Resend email API key', true),
      ('MAPBOX_ACCESS_TOKEN', 'Mapbox access token', true),
      ('MAPBOX_SECRET_TOKEN', 'Mapbox secret token (optional)', true),
      ('OPENAI_API_KEY', 'OpenAI API key for AI features', true),
      ('REVENUECAT_IOS_PUBLIC_KEY', 'RevenueCat iOS Public API Key', true),
      ('REVENUECAT_ANDROID_PUBLIC_KEY', 'RevenueCat Android Public API Key', true),
      ('REVENUECAT_SECRET_API_KEY', 'RevenueCat Secret API Key (admin only)', false),
      ('SUPABASE_SERVICE_ROLE_KEY', 'Supabase Service Role Key (never expose)', false)
  ) AS required(name, description, is_whitelisted)
  LEFT JOIN vault.secrets ON vault.secrets.name = required.name
  ORDER BY required.name;
$$;


--
-- Name: FUNCTION list_required_secrets(); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.list_required_secrets() IS 'List all required secrets with their existence status and whitelist status.

SECURITY:
- Accessible by service_role only
- Does not return secret values
- Shows which secrets are in whitelist vs admin-only

USAGE (Edge Functions):
  const secrets = await supabase.rpc("list_required_secrets");
  
  // Check for missing secrets
  const missing = secrets.filter(s => !s.secret_exists && s.is_whitelisted);

RETURNS:
- Table with secret_name, secret_exists, description, is_whitelisted columns
- is_whitelisted = true means accessible via get_secret_audited()
- is_whitelisted = false means admin-only (not accessible via RPC)';


--
-- Name: log_audit_event(uuid, text, text, text, jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.log_audit_event(p_user_id uuid, p_action text, p_resource_type text, p_resource_id text, p_metadata jsonb DEFAULT '{}'::jsonb) RETURNS uuid
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
DECLARE
  v_log_id UUID;
BEGIN
  INSERT INTO public.audit_logs (user_id, action, resource_type, resource_id, metadata)
  VALUES (p_user_id, p_action, p_resource_type, p_resource_id, p_metadata)
  RETURNING id INTO v_log_id;
  
  RETURN v_log_id;
END;
$$;


--
-- Name: log_moderator_action(text, text, text, uuid, text, jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.log_moderator_action(p_action_type text, p_target_type text, p_target_id text, p_target_profile_id uuid DEFAULT NULL::uuid, p_reason text DEFAULT NULL::text, p_details jsonb DEFAULT '{}'::jsonb) RETURNS uuid
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
DECLARE
  v_log_id UUID;
  v_is_moderator BOOLEAN;
BEGIN
  -- Check if user is a moderator
  SELECT EXISTS (
    SELECT 1 FROM user_roles ur
    JOIN roles r ON ur.role_id = r.id
    WHERE ur.profile_id = auth.uid()
    AND r.name IN ('admin', 'super_admin', 'moderator')
  ) INTO v_is_moderator;
  
  IF NOT v_is_moderator THEN
    RAISE EXCEPTION 'Only moderators can log actions';
  END IF;
  
  INSERT INTO forum_moderator_logs (
    moderator_id,
    action_type,
    target_type,
    target_id,
    target_profile_id,
    reason,
    details
  ) VALUES (
    auth.uid(),
    p_action_type,
    p_target_type,
    p_target_id,
    p_target_profile_id,
    p_reason,
    p_details
  )
  RETURNING id INTO v_log_id;
  
  RETURN v_log_id;
END;
$$;


--
-- Name: log_post_activity(bigint, uuid, public.post_activity_type, jsonb, jsonb, jsonb, jsonb, text, text, inet, text, text, bigint, uuid, uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.log_post_activity(p_post_id bigint, p_actor_id uuid, p_activity_type public.post_activity_type, p_previous_state jsonb DEFAULT '{}'::jsonb, p_new_state jsonb DEFAULT '{}'::jsonb, p_changes jsonb DEFAULT '{}'::jsonb, p_metadata jsonb DEFAULT '{}'::jsonb, p_reason text DEFAULT NULL::text, p_notes text DEFAULT NULL::text, p_ip_address inet DEFAULT NULL::inet, p_user_agent text DEFAULT NULL::text, p_request_id text DEFAULT NULL::text, p_related_post_id bigint DEFAULT NULL::bigint, p_related_profile_id uuid DEFAULT NULL::uuid, p_related_room_id uuid DEFAULT NULL::uuid) RETURNS uuid
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO ''
    AS $$
DECLARE
  v_log_id UUID;
BEGIN
  INSERT INTO post_activity_logs (
    post_id,
    actor_id,
    activity_type,
    previous_state,
    new_state,
    changes,
    metadata,
    reason,
    notes,
    ip_address,
    user_agent,
    request_id,
    related_post_id,
    related_profile_id,
    related_room_id
  ) VALUES (
    p_post_id,
    p_actor_id,
    p_activity_type,
    p_previous_state,
    p_new_state,
    p_changes,
    p_metadata,
    p_reason,
    p_notes,
    p_ip_address,
    p_user_agent,
    p_request_id,
    p_related_post_id,
    p_related_profile_id,
    p_related_room_id
  ) RETURNING id INTO v_log_id;
  
  RETURN v_log_id;
END;
$$;


--
-- Name: manage_post_like_counter(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.manage_post_like_counter() RETURNS trigger
    LANGUAGE plpgsql
    SET search_path TO 'public'
    AS $$
BEGIN
  IF TG_OP = 'INSERT' THEN
    UPDATE public.posts
    SET post_like_counter = COALESCE(post_like_counter, 0) + 1
    WHERE id = NEW.post_id;
    RETURN NEW;
  ELSIF TG_OP = 'DELETE' THEN
    UPDATE public.posts
    SET post_like_counter = GREATEST(COALESCE(post_like_counter, 0) - 1, 0)
    WHERE id = OLD.post_id;
    RETURN OLD;
  END IF;
  RETURN NULL;
END;
$$;


--
-- Name: mark_all_notifications_read(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.mark_all_notifications_read(p_user_id uuid) RETURNS void
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
BEGIN
    UPDATE in_app_notifications
    SET read_at = NOW()
    WHERE user_id = p_user_id
        AND read_at IS NULL;
END;
$$;


--
-- Name: FUNCTION mark_all_notifications_read(p_user_id uuid); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.mark_all_notifications_read(p_user_id uuid) IS 'Mark all in-app notifications as read for a user';


--
-- Name: mark_automation_email_sent(uuid, boolean, text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.mark_automation_email_sent(p_queue_id uuid, p_success boolean, p_error_message text DEFAULT NULL::text) RETURNS void
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
DECLARE
  v_queue_item record;
  v_next_step jsonb;
  v_next_step_index integer;
  v_delay_minutes integer;
  v_flow record;
BEGIN
  SELECT * INTO v_queue_item FROM public.email_automation_queue WHERE id = p_queue_id;
  
  IF v_queue_item IS NULL THEN
    RAISE EXCEPTION 'Queue item not found';
  END IF;
  
  IF p_success THEN
    UPDATE public.email_automation_queue 
    SET status = 'sent', sent_at = now(), updated_at = now()
    WHERE id = p_queue_id;
    
    UPDATE public.automation_enrollments 
    SET current_step = v_queue_item.step_index + 1, updated_at = now()
    WHERE id = v_queue_item.enrollment_id;
    
    UPDATE public.email_automation_flows 
    SET total_completed = total_completed + 1, updated_at = now()
    WHERE id = v_queue_item.flow_id;
    
    SELECT * INTO v_flow FROM public.email_automation_flows WHERE id = v_queue_item.flow_id;
    v_next_step_index := v_queue_item.step_index + 1;
    
    IF v_flow IS NOT NULL AND jsonb_array_length(v_flow.steps) > v_next_step_index THEN
      v_next_step := v_flow.steps->v_next_step_index;
      v_delay_minutes := COALESCE((v_next_step->>'delay_minutes')::integer, 0);
      
      INSERT INTO public.email_automation_queue (
        enrollment_id, flow_id, profile_id, step_index,
        scheduled_for, email_data
      ) VALUES (
        v_queue_item.enrollment_id, v_queue_item.flow_id, v_queue_item.profile_id, v_next_step_index,
        now() + (v_delay_minutes || ' minutes')::interval,
        v_next_step
      );
    ELSE
      UPDATE public.automation_enrollments 
      SET status = 'completed', completed_at = now(), updated_at = now()
      WHERE id = v_queue_item.enrollment_id;
    END IF;
  ELSE
    UPDATE public.email_automation_queue 
    SET 
      status = CASE WHEN retry_count >= 3 THEN 'failed' ELSE 'pending' END,
      retry_count = retry_count + 1,
      error_message = p_error_message,
      scheduled_for = CASE WHEN retry_count < 3 THEN now() + interval '5 minutes' ELSE scheduled_for END,
      updated_at = now()
    WHERE id = p_queue_id;
  END IF;
END;
$$;


--
-- Name: mark_best_answer(bigint); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.mark_best_answer(p_comment_id bigint) RETURNS jsonb
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
DECLARE
  v_user_id UUID := auth.uid();
  v_comment RECORD;
  v_forum RECORD;
  v_previous_best BIGINT;
  v_commenter_id UUID;
BEGIN
  IF v_user_id IS NULL THEN
    RAISE EXCEPTION 'Not authenticated';
  END IF;
  
  -- Get comment and verify it exists
  SELECT * INTO v_comment FROM public.comments WHERE id = p_comment_id;
  IF v_comment IS NULL THEN
    RAISE EXCEPTION 'Comment not found';
  END IF;
  
  -- Get forum post
  SELECT * INTO v_forum FROM public.forum WHERE id = v_comment.forum_id;
  
  -- Only post author can mark best answer
  IF v_forum.profile_id != v_user_id THEN
    RAISE EXCEPTION 'Only the post author can mark best answer';
  END IF;
  
  -- Only for question type posts
  IF v_forum.post_type != 'question' THEN
    RAISE EXCEPTION 'Best answer can only be marked on question posts';
  END IF;
  
  -- Store previous best answer
  v_previous_best := v_forum.best_answer_id;
  
  -- Toggle if same comment
  IF v_previous_best = p_comment_id THEN
    -- Unmark
    UPDATE public.forum SET best_answer_id = NULL WHERE id = v_forum.id;
    UPDATE public.comments SET is_best_answer = false WHERE id = p_comment_id;
    
    -- Remove reputation from commenter
    SELECT user_id INTO v_commenter_id FROM public.comments WHERE id = p_comment_id;
    IF v_commenter_id IS NOT NULL THEN
      UPDATE public.forum_user_stats
      SET reputation_score = GREATEST(0, reputation_score - 25)
      WHERE profile_id = v_commenter_id;
    END IF;
    
    RETURN jsonb_build_object('action', 'unmarked', 'comment_id', NULL);
  ELSE
    -- Clear previous best answer
    IF v_previous_best IS NOT NULL THEN
      UPDATE public.comments SET is_best_answer = false WHERE id = v_previous_best;
      
      -- Remove reputation from previous
      SELECT user_id INTO v_commenter_id FROM public.comments WHERE id = v_previous_best;
      IF v_commenter_id IS NOT NULL THEN
        UPDATE public.forum_user_stats
        SET reputation_score = GREATEST(0, reputation_score - 25)
        WHERE profile_id = v_commenter_id;
      END IF;
    END IF;
    
    -- Set new best answer
    UPDATE public.forum SET best_answer_id = p_comment_id WHERE id = v_forum.id;
    UPDATE public.comments SET is_best_answer = true WHERE id = p_comment_id;
    
    -- Award reputation to commenter (+25 for best answer)
    SELECT user_id INTO v_commenter_id FROM public.comments WHERE id = p_comment_id;
    IF v_commenter_id IS NOT NULL AND v_commenter_id != v_user_id THEN
      PERFORM public.ensure_forum_user_stats(v_commenter_id);
      UPDATE public.forum_user_stats
      SET reputation_score = reputation_score + 25
      WHERE profile_id = v_commenter_id;
    END IF;
    
    RETURN jsonb_build_object('action', 'marked', 'comment_id', p_comment_id);
  END IF;
END;
$$;


--
-- Name: mark_category_as_read(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.mark_category_as_read(p_category_id integer) RETURNS integer
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
DECLARE
  v_count INTEGER;
BEGIN
  WITH inserted AS (
    INSERT INTO forum_reading_progress (profile_id, forum_id, is_fully_read, last_read_at)
    SELECT auth.uid(), f.id, true, now()
    FROM forum f
    WHERE f.category_id = p_category_id
    AND f.forum_published = true
    ON CONFLICT (profile_id, forum_id) DO UPDATE SET
      last_read_at = now(),
      is_fully_read = true
    RETURNING 1
  )
  SELECT COUNT(*) INTO v_count FROM inserted;
  
  RETURN v_count;
END;
$$;


--
-- Name: mark_conversation_read(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.mark_conversation_read(p_conversation_id uuid) RETURNS void
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
BEGIN
  -- Update participant's last read timestamp
  UPDATE forum_conversation_participants
  SET last_read_at = now()
  WHERE conversation_id = p_conversation_id
    AND profile_id = auth.uid();
  
  -- Add read receipts for all unread messages
  INSERT INTO forum_message_read_receipts (message_id, profile_id)
  SELECT m.id, auth.uid()
  FROM forum_messages m
  JOIN forum_conversation_participants cp ON cp.conversation_id = m.conversation_id
  WHERE m.conversation_id = p_conversation_id
    AND cp.profile_id = auth.uid()
    AND m.sender_id != auth.uid()
    AND NOT EXISTS (
      SELECT 1 FROM forum_message_read_receipts
      WHERE message_id = m.id AND profile_id = auth.uid()
    )
  ON CONFLICT (message_id, profile_id) DO NOTHING;
END;
$$;


--
-- Name: mark_digest_notifications_sent(uuid[]); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.mark_digest_notifications_sent(p_notification_ids uuid[]) RETURNS void
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
BEGIN
    UPDATE notification_digest_queue
    SET
        status = 'sent',
        sent_at = NOW()
    WHERE id = ANY(p_notification_ids);
END;
$$;


--
-- Name: FUNCTION mark_digest_notifications_sent(p_notification_ids uuid[]); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.mark_digest_notifications_sent(p_notification_ids uuid[]) IS 'Mark digest notifications as sent';


--
-- Name: mark_email_as_failed(uuid, text, text, boolean); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.mark_email_as_failed(p_delivery_id uuid, p_error_code text, p_error_message text, p_should_retry boolean DEFAULT true) RETURNS boolean
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
BEGIN
  UPDATE email_delivery_log
  SET
    status = CASE WHEN p_should_retry AND retry_count < 2 THEN 'queued' ELSE 'failed' END,
    error_code = p_error_code,
    error_message = p_error_message,
    retry_count = retry_count + 1,
    updated_at = now()
  WHERE id = p_delivery_id;

  RETURN FOUND;
END;
$$;


--
-- Name: mark_email_as_sent(uuid, text, text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.mark_email_as_sent(p_delivery_id uuid, p_provider text, p_message_id text) RETURNS boolean
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
BEGIN
  UPDATE email_delivery_log
  SET
    status = 'sent',
    provider = p_provider,
    message_id = p_message_id,
    sent_at = now(),
    updated_at = now()
  WHERE id = p_delivery_id
    AND status = 'queued';

  RETURN FOUND;
END;
$$;


--
-- Name: mark_feed_read(uuid[]); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.mark_feed_read(p_activity_ids uuid[]) RETURNS integer
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
DECLARE
  v_count INTEGER;
BEGIN
  INSERT INTO forum_feed_read_status (profile_id, activity_id)
  SELECT auth.uid(), unnest(p_activity_ids)
  ON CONFLICT (profile_id, activity_id) DO NOTHING;
  
  GET DIAGNOSTICS v_count = ROW_COUNT;
  RETURN v_count;
END;
$$;


--
-- Name: mark_forum_notifications_read(uuid[]); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.mark_forum_notifications_read(p_notification_ids uuid[] DEFAULT NULL::uuid[]) RETURNS integer
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
DECLARE
  v_count INT;
BEGIN
  IF p_notification_ids IS NULL THEN
    -- Mark all as read
    UPDATE public.forum_notifications
    SET is_read = true
    WHERE recipient_id = (SELECT auth.uid())
      AND is_read = false;
  ELSE
    -- Mark specific notifications as read
    UPDATE public.forum_notifications
    SET is_read = true
    WHERE id = ANY(p_notification_ids)
      AND recipient_id = (SELECT auth.uid())
      AND is_read = false;
  END IF;
  
  GET DIAGNOSTICS v_count = ROW_COUNT;
  RETURN v_count;
END;
$$;


--
-- Name: mark_geocode_completed(bigint); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.mark_geocode_completed(queue_id bigint) RETURNS void
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO ''
    AS $$
BEGIN
  UPDATE public.location_update_queue
  SET
    status = 'completed',
    completed_at = NOW(),
    error_message = NULL
  WHERE id = queue_id;
END;
$$;


--
-- Name: mark_geocode_failed(bigint, text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.mark_geocode_failed(queue_id bigint, error_msg text) RETURNS void
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO ''
    AS $$
DECLARE
  v_retry_count INTEGER;
  v_max_retries INTEGER;
BEGIN
  -- Get current retry info
  SELECT retry_count, max_retries
  INTO v_retry_count, v_max_retries
  FROM public.location_update_queue
  WHERE id = queue_id;

  -- Update status based on retry count
  UPDATE public.location_update_queue
  SET
    status = CASE
      WHEN v_retry_count >= v_max_retries THEN 'failed'
      ELSE 'pending' -- Will be retried
    END,
    error_message = error_msg,
    last_attempt_at = NOW()
  WHERE id = queue_id;
END;
$$;


--
-- Name: FUNCTION mark_geocode_failed(queue_id bigint, error_msg text); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.mark_geocode_failed(queue_id bigint, error_msg text) IS 'Mark geocoding attempt as failed. Automatically retries if under max_retries, otherwise marks as permanently failed';


--
-- Name: mark_geocode_processing(bigint); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.mark_geocode_processing(queue_id bigint) RETURNS void
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO ''
    AS $$
BEGIN
  UPDATE public.location_update_queue
  SET
    status = 'processing',
    last_attempt_at = NOW(),
    retry_count = retry_count + 1
  WHERE id = queue_id;
END;
$$;


--
-- Name: mark_messages_read(text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.mark_messages_read(conversation_uuid text) RETURNS json
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO ''
    AS $$
DECLARE
  result json;
BEGIN
  UPDATE public.rooms
  SET last_message_seen_by = auth.uid()
  WHERE id = conversation_uuid::uuid
    AND (requester = auth.uid() OR sharer = auth.uid());
  
  SELECT json_build_object('success', true) INTO result;
  RETURN result;
END;
$$;


--
-- Name: mark_messages_read(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.mark_messages_read(conversation_uuid uuid) RETURNS json
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO ''
    AS $$
DECLARE
    updated_count INTEGER;
    current_user_id UUID;
BEGIN
    current_user_id := auth.uid();
    
    -- Mark all unread messages in the conversation as read
    WITH updated AS (
        UPDATE public.messages
        SET is_read = true, read_at = NOW()
        WHERE 
            conversation_id = conversation_uuid
            AND sender_id != current_user_id
            AND is_read = false
        RETURNING *
    )
    SELECT COUNT(*) INTO updated_count FROM updated;
    
    -- Reset unread count for the current user in the conversation
    UPDATE public.conversations
    SET 
        owner_unread_count = CASE 
            WHEN owner_id = current_user_id THEN 0
            ELSE owner_unread_count
        END,
        requester_unread_count = CASE 
            WHEN requester_id = current_user_id THEN 0
            ELSE requester_unread_count
        END,
        owner_last_read_at = CASE
            WHEN owner_id = current_user_id THEN NOW()
            ELSE owner_last_read_at
        END,
        requester_last_read_at = CASE
            WHEN requester_id = current_user_id THEN NOW()
            ELSE requester_last_read_at
        END
    WHERE id = conversation_uuid;
    
    RETURN json_build_object(
        'success', true,
        'messages_marked_read', updated_count
    );
END;
$$;


--
-- Name: FUNCTION mark_messages_read(conversation_uuid uuid); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.mark_messages_read(conversation_uuid uuid) IS 'Mark all messages in a conversation as read for current user';


--
-- Name: mark_notification_read(uuid, uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.mark_notification_read(p_user_id uuid, p_notification_id uuid) RETURNS jsonb
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
DECLARE
  v_affected integer;
BEGIN
  UPDATE user_notifications
  SET is_read = true,
      read_at = NOW(),
      updated_at = NOW()
  WHERE id = p_notification_id
    AND recipient_id = p_user_id
    AND is_read = false;

  GET DIAGNOSTICS v_affected = ROW_COUNT;

  IF v_affected = 0 THEN
    -- Check if notification exists
    IF NOT EXISTS (SELECT 1 FROM user_notifications WHERE id = p_notification_id AND recipient_id = p_user_id) THEN
      RETURN jsonb_build_object('success', false, 'error', 'NOT_FOUND');
    END IF;
    -- Already read
    RETURN jsonb_build_object('success', true, 'alreadyRead', true);
  END IF;

  RETURN jsonb_build_object(
    'success', true,
    'notificationId', p_notification_id,
    'readAt', NOW()
  );
END;
$$;


--
-- Name: mark_notifications_read(uuid[]); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.mark_notifications_read(p_notification_ids uuid[]) RETURNS void
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public', 'pg_temp'
    AS $$
BEGIN
    UPDATE notifications
    SET read_at = NOW()
    WHERE id = ANY(p_notification_ids)
      AND read_at IS NULL;
END;
$$;


--
-- Name: moderate_remove_post(bigint, text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.moderate_remove_post(p_forum_id bigint, p_reason text DEFAULT NULL::text) RETURNS boolean
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
DECLARE
  v_post_author UUID;
  v_post_title TEXT;
BEGIN
  -- Get post info before modifying
  SELECT profile_id, forum_post_name INTO v_post_author, v_post_title
  FROM forum WHERE id = p_forum_id;
  
  IF NOT FOUND THEN
    RAISE EXCEPTION 'Post not found';
  END IF;
  
  -- Mark post as unpublished (soft delete)
  UPDATE forum SET forum_published = false WHERE id = p_forum_id;
  
  -- Log the action
  PERFORM log_moderator_action(
    'post_remove',
    'post',
    p_forum_id::TEXT,
    v_post_author,
    p_reason,
    jsonb_build_object('title', v_post_title)
  );
  
  RETURN true;
END;
$$;


--
-- Name: moderate_toggle_post_lock(bigint, text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.moderate_toggle_post_lock(p_forum_id bigint, p_reason text DEFAULT NULL::text) RETURNS boolean
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
DECLARE
  v_is_locked BOOLEAN;
  v_post_author UUID;
BEGIN
  SELECT is_locked, profile_id INTO v_is_locked, v_post_author
  FROM forum WHERE id = p_forum_id;
  
  IF NOT FOUND THEN
    RAISE EXCEPTION 'Post not found';
  END IF;
  
  -- Toggle lock status
  UPDATE forum SET is_locked = NOT v_is_locked WHERE id = p_forum_id;
  
  -- Log the action
  PERFORM log_moderator_action(
    CASE WHEN v_is_locked THEN 'post_unlock' ELSE 'post_lock' END,
    'post',
    p_forum_id::TEXT,
    v_post_author,
    p_reason
  );
  
  RETURN NOT v_is_locked;
END;
$$;


--
-- Name: move_bookmark_to_collection(integer, uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.move_bookmark_to_collection(p_bookmark_id integer, p_new_collection_id uuid) RETURNS boolean
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
DECLARE
  v_old_collection_id UUID;
BEGIN
  -- Get old collection
  SELECT collection_id INTO v_old_collection_id
  FROM forum_bookmarks
  WHERE id = p_bookmark_id AND profile_id = auth.uid();
  
  IF NOT FOUND THEN
    RETURN FALSE;
  END IF;
  
  -- Update bookmark
  UPDATE forum_bookmarks
  SET collection_id = p_new_collection_id
  WHERE id = p_bookmark_id AND profile_id = auth.uid();
  
  -- Update old collection count
  IF v_old_collection_id IS NOT NULL THEN
    UPDATE forum_bookmark_collections
    SET bookmarks_count = (
      SELECT COUNT(*) FROM forum_bookmarks WHERE collection_id = v_old_collection_id
    ),
    updated_at = now()
    WHERE id = v_old_collection_id;
  END IF;
  
  -- Update new collection count
  UPDATE forum_bookmark_collections
  SET bookmarks_count = (
    SELECT COUNT(*) FROM forum_bookmarks WHERE collection_id = p_new_collection_id
  ),
  updated_at = now()
  WHERE id = p_new_collection_id;
  
  RETURN TRUE;
END;
$$;


--
-- Name: move_failed_email_to_dlq(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.move_failed_email_to_dlq() RETURNS trigger
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
BEGIN
  -- Only trigger when status changes to 'failed'
  IF NEW.status = 'failed' AND (OLD.status IS NULL OR OLD.status != 'failed') THEN
    INSERT INTO email_dead_letter_queue (
      original_queue_id,
      recipient_email,
      email_type,
      template_name,
      template_data,
      failed_providers,
      last_error,
      attempts,
      created_at
    ) VALUES (
      NEW.id,
      NEW.recipient_email,
      NEW.email_type,
      NEW.template_name,
      NEW.template_data,
      ARRAY['resend', 'brevo', 'mailersend', 'aws_ses']::text[], -- all attempted
      NEW.last_error,
      NEW.attempts,
      NOW()
    );
  END IF;
  RETURN NEW;
END;
$$;


--
-- Name: move_to_dead_letter_queue(uuid, text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.move_to_dead_letter_queue(p_queue_id uuid, p_failure_reason text) RETURNS uuid
    LANGUAGE plpgsql
    SET search_path TO ''
    AS $$
DECLARE
  v_dlq_id UUID;
  v_queue_record RECORD;
BEGIN
  -- Get the queued email record
  SELECT * INTO v_queue_record
  FROM email_queue
  WHERE id = p_queue_id;
  
  IF NOT FOUND THEN
    RAISE EXCEPTION 'Queue record not found: %', p_queue_id;
  END IF;
  
  -- Insert into dead letter queue
  INSERT INTO email_dead_letter_queue (
    original_queue_id,
    recipient_id,
    recipient_email,
    email_type,
    template_name,
    template_data,
    total_attempts,
    failure_reason,
    last_error,
    first_attempt_at,
    last_attempt_at
  ) VALUES (
    p_queue_id,
    v_queue_record.recipient_id,
    v_queue_record.recipient_email,
    v_queue_record.email_type,
    v_queue_record.template_name,
    v_queue_record.template_data,
    v_queue_record.attempts,
    p_failure_reason,
    v_queue_record.last_error,
    v_queue_record.created_at,
    v_queue_record.updated_at
  )
  RETURNING id INTO v_dlq_id;
  
  -- Mark queue item as failed (don't delete to maintain audit trail)
  UPDATE email_queue 
  SET status = 'failed', 
      updated_at = NOW()
  WHERE id = p_queue_id;
  
  RETURN v_dlq_id;
END;
$$;


--
-- Name: FUNCTION move_to_dead_letter_queue(p_queue_id uuid, p_failure_reason text); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.move_to_dead_letter_queue(p_queue_id uuid, p_failure_reason text) IS 'Moves a failed email from queue to dead letter queue';


--
-- Name: nearby_address(double precision, double precision); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.nearby_address(lat double precision, long double precision) RETURNS SETOF record
    LANGUAGE sql
    SET search_path TO ''
    AS $$
  select profile_id, address_line_1, st_astext(location) as location, st_distance(location, st_point(long, lat)::geography) as dist_meters
  from public.address
  order by location <-> st_point(long, lat)::geography;
$$;


--
-- Name: nearby_address(numeric, numeric); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.nearby_address(lat numeric, long numeric) RETURNS SETOF record
    LANGUAGE plpgsql STABLE
    SET search_path TO ''
    AS $$
BEGIN
  RETURN QUERY
  SELECT *
  FROM public.address
  WHERE location IS NOT NULL
    AND ST_DWithin(
      location::geography,
      ST_SetSRID(ST_MakePoint(long, lat), 4326)::geography,
      50000
    )
  ORDER BY location <-> ST_SetSRID(ST_MakePoint(long, lat), 4326)
  LIMIT 50;
END;
$$;


--
-- Name: nearby_community_fridges(double precision, double precision, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.nearby_community_fridges(user_lat double precision, user_lng double precision, radius_meters integer DEFAULT 10000, limit_count integer DEFAULT 50) RETURNS TABLE(id uuid, name text, status text, description text, street_address text, city text, state text, zip_code text, full_address text, latitude double precision, longitude double precision, reference_directions text, location_type text, host_company text, company_type text, point_person_name text, point_person_email text, available_hours text, has_pantry boolean, languages text[], latest_food_status text, latest_cleanliness_status text, total_check_ins integer, last_check_in timestamp with time zone, status_last_updated timestamp with time zone, launch_date date, created_date date, age_years double precision, check_in_link text, slack_channel_id text, slack_channel_link text, photo_url text, qr_code_url text, created_at timestamp with time zone, updated_at timestamp with time zone, distance_meters double precision)
    LANGUAGE sql STABLE SECURITY DEFINER
    SET search_path TO ''
    AS $$
  SELECT 
    cf.id,
    cf.name,
    cf.status,
    cf.description,
    cf.street_address,
    cf.city,
    cf.state,
    cf.zip_code,
    cf.full_address,
    cf.latitude,
    cf.longitude,
    cf.reference_directions,
    cf.location_type,
    cf.host_company,
    cf.company_type,
    cf.point_person_name,
    cf.point_person_email,
    cf.available_hours,
    cf.has_pantry,
    cf.languages,
    cf.latest_food_status,
    cf.latest_cleanliness_status,
    cf.total_check_ins,
    cf.last_check_in,
    cf.status_last_updated,
    cf.launch_date,
    cf.created_date,
    cf.age_years,
    cf.check_in_link,
    cf.slack_channel_id,
    cf.slack_channel_link,
    cf.photo_url,
    cf.qr_code_url,
    cf.created_at,
    cf.updated_at,
    ST_Distance(
      ST_SetSRID(ST_MakePoint(cf.longitude, cf.latitude), 4326)::geography,
      ST_SetSRID(ST_MakePoint(user_lng, user_lat), 4326)::geography
    ) as distance_meters
  FROM community_fridges cf
  WHERE cf.status = 'Active'
    AND cf.latitude IS NOT NULL
    AND cf.longitude IS NOT NULL
    AND ST_DWithin(
      ST_SetSRID(ST_MakePoint(cf.longitude, cf.latitude), 4326)::geography,
      ST_SetSRID(ST_MakePoint(user_lng, user_lat), 4326)::geography,
      radius_meters
    )
  ORDER BY distance_meters
  LIMIT limit_count;
$$;


--
-- Name: FUNCTION nearby_community_fridges(user_lat double precision, user_lng double precision, radius_meters integer, limit_count integer); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.nearby_community_fridges(user_lat double precision, user_lng double precision, radius_meters integer, limit_count integer) IS 'Returns nearby active community fridges within a radius. Used by iOS app.';


--
-- Name: nearby_posts(double precision, double precision, text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.nearby_posts(lat double precision, long double precision, p_post_type text) RETURNS SETOF record
    LANGUAGE sql
    SET search_path TO ''
    AS $$
  select id, post_name, post_type, st_astext(location) as location, st_distance(location, st_point(long, lat)::geography) as dist_meters
  from public.posts
  where post_type = p_post_type
  order by location <-> st_point(long, lat)::geography;
$$;


--
-- Name: nearby_posts(numeric, numeric, text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.nearby_posts(lat numeric, long numeric, p_post_type text) RETURNS SETOF record
    LANGUAGE plpgsql STABLE
    SET search_path TO ''
    AS $$
BEGIN
  RETURN QUERY
  SELECT *
  FROM public.posts
  WHERE post_type = p_post_type
    AND active = true
    AND location IS NOT NULL
    AND ST_DWithin(
      location::geography,
      ST_SetSRID(ST_MakePoint(long, lat), 4326)::geography,
      50000
    )
  ORDER BY location <-> ST_SetSRID(ST_MakePoint(long, lat), 4326)
  LIMIT 50;
END;
$$;


--
-- Name: nearby_posts_full(double precision, double precision, integer, text, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.nearby_posts_full(user_lat double precision, user_lng double precision, radius_meters integer, post_type_filter text DEFAULT NULL::text, category_filter integer DEFAULT NULL::integer, limit_count integer DEFAULT 50) RETURNS TABLE(id bigint, profile_id uuid, post_name text, post_description text, post_type text, pickup_time text, available_hours text, post_address text, post_stripped_address text, latitude double precision, longitude double precision, images text[], is_active boolean, is_arranged boolean, post_arranged_to uuid, post_arranged_at timestamp with time zone, post_views integer, post_like_counter integer, has_pantry boolean, food_status text, network text, website text, donation text, donation_rules text, category_id integer, created_at timestamp with time zone, updated_at timestamp with time zone, distance_meters double precision)
    LANGUAGE sql STABLE
    SET search_path TO 'public, extensions'
    AS $$
  SELECT 
    p.id,
    p.profile_id,
    p.post_name,
    p.post_description,
    p.post_type,
    p.pickup_time,
    p.available_hours,
    p.post_address,
    p.post_stripped_address,
    extensions.ST_Y(p.location::extensions.geometry) as latitude,
    extensions.ST_X(p.location::extensions.geometry) as longitude,
    p.images,
    p.is_active,
    p.is_arranged,
    p.post_arranged_to,
    p.post_arranged_at,
    p.post_views,
    p.post_like_counter,
    p.has_pantry,
    p.condition as food_status,
    p.network,
    p.website,
    p.donation,
    p.donation_rules,
    p.category_id::integer,
    p.created_at,
    p.updated_at,
    extensions.ST_Distance(
      p.location,
      extensions.ST_SetSRID(extensions.ST_MakePoint(user_lng, user_lat), 4326)::extensions.geography
    ) as distance_meters
  FROM public.posts p
  WHERE p.is_active = true
    AND p.is_arranged = false
    AND extensions.ST_DWithin(
      p.location,
      extensions.ST_SetSRID(extensions.ST_MakePoint(user_lng, user_lat), 4326)::extensions.geography,
      radius_meters
    )
    AND (post_type_filter IS NULL OR p.post_type = post_type_filter)
    AND (category_filter IS NULL OR p.category_id = category_filter)
  ORDER BY distance_meters
  LIMIT limit_count;
$$;


--
-- Name: notify_forum_post_telegram(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.notify_forum_post_telegram() RETURNS trigger
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public', 'extensions'
    AS $$
DECLARE
  edge_function_url TEXT;
  payload JSONB;
BEGIN
  -- Only trigger for published posts
  IF NEW.forum_published = true THEN
    -- Build the edge function URL
    edge_function_url := current_setting('app.settings.supabase_url', true) || '/functions/v1/notify-forum-post';
    
    -- If setting not available, use the project URL directly
    IF edge_function_url IS NULL OR edge_function_url = '/functions/v1/notify-forum-post' THEN
      edge_function_url := 'https://***REMOVED***/functions/v1/notify-forum-post';
    END IF;
    
    -- Build payload with the new record
    payload := jsonb_build_object(
      'record', jsonb_build_object(
        'id', NEW.id,
        'profile_id', NEW.profile_id,
        'forum_post_name', NEW.forum_post_name,
        'forum_post_description', NEW.forum_post_description,
        'slug', NEW.slug,
        'post_type', NEW.post_type,
        'forum_published', NEW.forum_published,
        'forum_post_created_at', NEW.forum_post_created_at
      )
    );
    
    -- Send async HTTP request using pg_net
    PERFORM net.http_post(
      url := edge_function_url,
      body := payload,
      headers := jsonb_build_object(
        'Content-Type', 'application/json'
      )
    );
  END IF;
  
  RETURN NEW;
END;
$$;


--
-- Name: FUNCTION notify_forum_post_telegram(); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.notify_forum_post_telegram() IS 'Sends Telegram notification when a new forum post is created. Admin gets all notifications, superadmin posts are also published to @foodshare_club channel.';


--
-- Name: notify_new_chat_message(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.notify_new_chat_message() RETURNS trigger
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO ''
    AS $$
DECLARE
  v_sender_id UUID;
  v_recipient_id UUID;
  v_sender_name TEXT;
  v_room_id UUID;
BEGIN
  SELECT rp.profile_id INTO v_sender_id
  FROM public.room_participants rp
  WHERE rp.id = NEW.id;

  SELECT rp.profile_id, r.id INTO v_recipient_id, v_room_id
  FROM public.room_participants rp
  JOIN public.rooms r ON rp.room_id = r.id
  WHERE rp.room_id = (SELECT room_id FROM public.room_participants WHERE id = NEW.id)
    AND rp.profile_id != v_sender_id
  LIMIT 1;

  IF v_recipient_id IS NOT NULL AND should_send_email_notification(v_recipient_id, 'chat') THEN
    SELECT COALESCE(full_name, email) INTO v_sender_name
    FROM public.profiles
    WHERE id = v_sender_id;

    PERFORM queue_email(
      v_recipient_id,
      (SELECT email FROM public.profiles WHERE id = v_recipient_id),
      'chat',
      'chat-notification',
      jsonb_build_object(
        'sender_name', v_sender_name,
        'sender_id', v_sender_id,
        'message_preview', LEFT(NEW.message, 100),
        'room_id', v_room_id
      )
    );
  END IF;

  RETURN NEW;
END;
$$;


--
-- Name: FUNCTION notify_new_chat_message(); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.notify_new_chat_message() IS 'Automatically queues email notification when new chat message is received';


--
-- Name: notify_new_feedback(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.notify_new_feedback() RETURNS trigger
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO ''
    AS $$
BEGIN
  -- Queue email to support
  PERFORM public.queue_email(
    NULL::uuid,  -- no recipient_id for support email
    'support@foodshare.club',
    'feedback',
    'feedback-alert',
    jsonb_build_object(
      'feedback_id', NEW.id,
      'feedback_type', NEW.feedback_type,
      'subject', NEW.subject,
      'submitter_name', NEW.name,
      'submitter_email', NEW.email,
      'message', NEW.message,
      'message_preview', LEFT(NEW.message, 200),
      'created_at', NEW.created_at
    )
  );
  
  RETURN NEW;
END;
$$;


--
-- Name: notify_new_interest(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.notify_new_interest() RETURNS trigger
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
DECLARE
  v_requester_name TEXT;
  v_post_name TEXT;
BEGIN
  -- Only notify if there's a post associated
  IF NEW.post_id IS NULL THEN
    RETURN NEW;
  END IF;

  -- Don't notify if sharer is the requester
  IF NEW.sharer = NEW.requester THEN
    RETURN NEW;
  END IF;

  -- Get requester name
  SELECT nickname INTO v_requester_name
  FROM profiles
  WHERE id = NEW.requester;

  -- Get post name
  SELECT post_name INTO v_post_name
  FROM posts
  WHERE id = NEW.post_id;

  -- Notify the sharer
  INSERT INTO user_notifications (
    id,
    recipient_id,
    actor_id,
    type,
    title,
    body,
    post_id,
    room_id,
    data,
    is_read,
    created_at
  ) VALUES (
    gen_random_uuid(),
    NEW.sharer,
    NEW.requester,
    'interest',
    COALESCE(v_requester_name, 'Someone') || ' is interested',
    'Interested in: ' || COALESCE(v_post_name, 'your item'),
    NEW.post_id,
    NEW.id,
    jsonb_build_object(
      'room_id', NEW.id,
      'post_id', NEW.post_id,
      'post_name', v_post_name,
      'requester_name', v_requester_name
    ),
    FALSE,
    NOW()
  )
  ON CONFLICT DO NOTHING;

  RETURN NEW;
END;
$$;


--
-- Name: FUNCTION notify_new_interest(); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.notify_new_interest() IS 'Creates notification when someone shows interest in a post';


--
-- Name: notify_new_message(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.notify_new_message() RETURNS trigger
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO ''
    AS $$
DECLARE
  v_room RECORD;
  v_recipient_id uuid;
  v_sender_name text;
BEGIN
  -- Get room details
  SELECT * INTO v_room FROM rooms WHERE id = NEW.room_id;
  
  IF v_room IS NULL THEN
    RETURN NEW;
  END IF;

  -- Determine recipient (the other person in the room)
  IF NEW.profile_id = v_room.sharer THEN
    v_recipient_id := v_room.requester;
  ELSE
    v_recipient_id := v_room.sharer;
  END IF;

  -- Get sender name
  SELECT COALESCE(first_name, 'Someone') INTO v_sender_name
  FROM profiles WHERE id = NEW.profile_id;

  -- Create notification
  PERFORM create_user_notification(
    p_recipient_id := v_recipient_id,
    p_actor_id := NEW.profile_id,
    p_type := 'new_message',
    p_title := v_sender_name || ' sent you a message',
    p_body := LEFT(NEW.message, 100),
    p_room_id := NEW.room_id,
    p_post_id := v_room.post_id
  );

  RETURN NEW;
END;
$$;


--
-- Name: notify_new_post(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.notify_new_post() RETURNS trigger
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO ''
    AS $$
DECLARE
  request_id bigint;
BEGIN
  -- Only notify for active posts
  IF NEW.is_active = true THEN
    -- Use pg_net to make HTTP request to edge function
    SELECT INTO request_id net.http_post(
      url := 'https://***REMOVED***/functions/v1/notify-new-post',
      headers := '{"Content-Type": "application/json", "Authorization": "Bearer ***REMOVED***"}'::jsonb,
      body := jsonb_build_object(
        'record', jsonb_build_object(
          'id', NEW.id,
          'post_name', NEW.post_name,
          'post_type', NEW.post_type,
          'post_address', NEW.post_address,
          'post_description', NEW.post_description,
          'profile_id', NEW.profile_id
        )
      )
    );
  END IF;
  
  RETURN NEW;
END;
$$;


--
-- Name: FUNCTION notify_new_post(); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.notify_new_post() IS 'Sends Telegram notification when a new post is created';


--
-- Name: notify_new_report(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.notify_new_report() RETURNS trigger
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO ''
    AS $$
DECLARE
  request_id bigint;
BEGIN
  -- Use pg_net to make HTTP request to edge function
  SELECT INTO request_id net.http_post(
    url := 'https://***REMOVED***/functions/v1/notify-new-report',
    headers := '{"Content-Type": "application/json", "Authorization": "Bearer ***REMOVED***"}'::jsonb,
    body := jsonb_build_object(
      'record', row_to_json(NEW)::jsonb,
      'table', TG_TABLE_NAME,
      'type', TG_OP
    )
  );
  
  RETURN NEW;
END;
$$;


--
-- Name: FUNCTION notify_new_report(); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.notify_new_report() IS 'Sends Telegram notification to admin when a new report is submitted';


--
-- Name: notify_new_review(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.notify_new_review() RETURNS trigger
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
DECLARE
  v_post_owner_id UUID;
  v_reviewer_name TEXT;
  v_post_name TEXT;
BEGIN
  -- Get reviewer name
  SELECT nickname INTO v_reviewer_name
  FROM profiles
  WHERE id = NEW.profile_id;

  -- Get post owner and name
  SELECT profile_id, post_name INTO v_post_owner_id, v_post_name
  FROM posts
  WHERE id = NEW.post_id;

  -- Don't notify if reviewer is the post owner
  IF v_post_owner_id = NEW.profile_id OR v_post_owner_id IS NULL THEN
    RETURN NEW;
  END IF;

  -- Create notification
  INSERT INTO user_notifications (
    id,
    recipient_id,
    actor_id,
    type,
    title,
    body,
    post_id,
    review_id,
    data,
    is_read,
    created_at
  ) VALUES (
    gen_random_uuid(),
    v_post_owner_id,
    NEW.profile_id,
    'review',
    COALESCE(v_reviewer_name, 'Someone') || ' left a review',
    CASE 
      WHEN NEW.reviewed_rating >= 4 THEN ' ' || NEW.reviewed_rating || ' stars - ' || LEFT(COALESCE(NEW.feedback, 'Great!'), 80)
      ELSE ' ' || NEW.reviewed_rating || ' stars'
    END,
    NEW.post_id,
    NEW.id,
    jsonb_build_object(
      'review_id', NEW.id,
      'post_id', NEW.post_id,
      'post_name', v_post_name,
      'rating', NEW.reviewed_rating,
      'reviewer_name', v_reviewer_name
    ),
    FALSE,
    NOW()
  )
  ON CONFLICT DO NOTHING;

  RETURN NEW;
END;
$$;


--
-- Name: FUNCTION notify_new_review(); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.notify_new_review() IS 'Creates notification when a new review is submitted';


--
-- Name: notify_new_room_message(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.notify_new_room_message() RETURNS trigger
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
DECLARE
  v_recipient_id UUID;
  v_sender_name TEXT;
  v_post_name TEXT;
BEGIN
  -- Determine recipient (the other person in the room)
  IF NEW.last_message_sent_by = NEW.sharer THEN
    v_recipient_id := NEW.requester;
  ELSE
    v_recipient_id := NEW.sharer;
  END IF;

  -- Don't notify if sender is recipient
  IF v_recipient_id = NEW.last_message_sent_by OR v_recipient_id IS NULL THEN
    RETURN NEW;
  END IF;

  -- Get sender name
  SELECT nickname INTO v_sender_name
  FROM profiles
  WHERE id = NEW.last_message_sent_by;

  -- Get post name if exists
  IF NEW.post_id IS NOT NULL THEN
    SELECT post_name INTO v_post_name
    FROM posts
    WHERE id = NEW.post_id;
  END IF;

  -- Create notification
  INSERT INTO user_notifications (
    id,
    recipient_id,
    actor_id,
    type,
    title,
    body,
    room_id,
    post_id,
    data,
    is_read,
    created_at
  ) VALUES (
    gen_random_uuid(),
    v_recipient_id,
    NEW.last_message_sent_by,
    'message',
    COALESCE(v_sender_name, 'Someone') || ' sent you a message',
    LEFT(NEW.last_message, 100),
    NEW.id,
    NEW.post_id,
    jsonb_build_object(
      'room_id', NEW.id,
      'post_id', NEW.post_id,
      'post_name', v_post_name,
      'sender_name', v_sender_name
    ),
    FALSE,
    NOW()
  )
  ON CONFLICT DO NOTHING;

  RETURN NEW;
END;
$$;


--
-- Name: FUNCTION notify_new_room_message(); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.notify_new_room_message() IS 'Creates notification when a new message is sent in a room';


--
-- Name: notify_new_user(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.notify_new_user() RETURNS trigger
    LANGUAGE plpgsql
    SET search_path TO ''
    AS $$
DECLARE
  request_id bigint;
BEGIN
  -- Call the edge function with comprehensive profile data
  SELECT INTO request_id net.http_post(
    url := 'https://***REMOVED***/functions/v1/notify-new-user',
    headers := '{"Content-Type": "application/json", "Authorization": "Bearer ***REMOVED***"}'::jsonb,
    body := jsonb_build_object(
      'record', jsonb_build_object(
        -- Identity
        'id', NEW.id,
        'nickname', NEW.nickname,
        'first_name', NEW.first_name,
        'second_name', NEW.second_name,
        
        -- Contact
        'email', NEW.email,
        'phone', NEW.phone,
        
        -- Profile info
        'about_me', NEW.about_me,
        'bio', NEW.bio,
        'avatar_url', NEW.avatar_url,
        
        -- Preferences
        'transportation', NEW.transportation,
        'dietary_preferences', NEW.dietary_preferences,
        'search_radius_km', NEW.search_radius_km,
        
        -- Social media
        'facebook', NEW.facebook,
        'instagram', NEW.instagram,
        'twitter', NEW.twitter,
        
        -- Status
        'is_verified', NEW.is_verified,
        'is_active', NEW.is_active,
        -- Note: user_role removed - roles are now managed via user_roles table
        -- New users won't have roles assigned at profile creation time
        
        -- Timestamps
        'created_time', NEW.created_time,
        'updated_at', NEW.updated_at
      )
    )
  );
  
  RETURN NEW;
END;
$$;


--
-- Name: FUNCTION notify_new_user(); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.notify_new_user() IS 'Trigger function to notify edge function when new user profile is created. Roles are managed via user_roles table separately.';


--
-- Name: notify_on_forum_comment(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.notify_on_forum_comment() RETURNS trigger
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
DECLARE
  v_post_author_id UUID;
  v_parent_comment_author_id UUID;
  v_post_title TEXT;
BEGIN
  -- Get post author and title
  SELECT profile_id, title INTO v_post_author_id, v_post_title
  FROM public.forum
  WHERE id = NEW.forum_id;
  
  -- Check if this is a reply to another comment
  IF NEW.parent_id IS NOT NULL THEN
    -- Get parent comment author
    SELECT profile_id INTO v_parent_comment_author_id
    FROM public.comments
    WHERE id = NEW.parent_id;
    
    -- Notify parent comment author
    IF v_parent_comment_author_id IS NOT NULL THEN
      PERFORM public.create_forum_notification(
        v_parent_comment_author_id,
        NEW.profile_id,
        'comment_reply',
        NEW.forum_id,
        NEW.id,
        jsonb_build_object('preview', LEFT(NEW.content, 100), 'post_title', v_post_title)
      );
    END IF;
  ELSE
    -- Direct reply to post - notify post author
    IF v_post_author_id IS NOT NULL THEN
      PERFORM public.create_forum_notification(
        v_post_author_id,
        NEW.profile_id,
        'forum_reply',
        NEW.forum_id,
        NEW.id,
        jsonb_build_object('preview', LEFT(NEW.content, 100), 'post_title', v_post_title)
      );
    END IF;
  END IF;
  
  RETURN NEW;
END;
$$;


--
-- Name: notify_on_forum_mention(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.notify_on_forum_mention() RETURNS trigger
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
DECLARE
  v_type TEXT;
  v_post_title TEXT;
BEGIN
  -- Determine notification type
  IF NEW.forum_id IS NOT NULL THEN
    v_type := 'mention_post';
    SELECT title INTO v_post_title FROM public.forum WHERE id = NEW.forum_id;
  ELSE
    v_type := 'mention_comment';
    SELECT f.title INTO v_post_title 
    FROM public.comments c 
    JOIN public.forum f ON c.forum_id = f.id 
    WHERE c.id = NEW.comment_id;
  END IF;
  
  -- Create notification
  PERFORM public.create_forum_notification(
    NEW.mentioned_profile_id,
    NEW.mentioner_profile_id,
    v_type,
    NEW.forum_id,
    NEW.comment_id,
    jsonb_build_object('post_title', v_post_title)
  );
  
  RETURN NEW;
END;
$$;


--
-- Name: notify_on_forum_reaction(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.notify_on_forum_reaction() RETURNS trigger
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
DECLARE
  v_post_author_id UUID;
  v_post_title TEXT;
  v_reaction_name TEXT;
BEGIN
  -- Get post author and title
  SELECT profile_id, title INTO v_post_author_id, v_post_title
  FROM public.forum
  WHERE id = NEW.forum_id;
  
  -- Get reaction name
  SELECT name INTO v_reaction_name
  FROM public.reaction_types
  WHERE id = NEW.reaction_type_id;
  
  -- Create notification
  PERFORM public.create_forum_notification(
    v_post_author_id,
    NEW.profile_id,
    'reaction',
    NEW.forum_id,
    NULL,
    jsonb_build_object('reaction', v_reaction_name, 'post_title', v_post_title)
  );
  
  RETURN NEW;
END;
$$;


--
-- Name: notify_post_arranged(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.notify_post_arranged() RETURNS trigger
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
DECLARE
  v_sharer_id UUID;
  v_sharer_name TEXT;
  v_receiver_name TEXT;
BEGIN
  -- Only trigger when is_arranged changes to TRUE
  IF NOT NEW.is_arranged OR OLD.is_arranged THEN
    RETURN NEW;
  END IF;

  -- Get sharer info
  v_sharer_id := NEW.profile_id;
  SELECT nickname INTO v_sharer_name
  FROM profiles
  WHERE id = v_sharer_id;

  -- Get receiver name
  SELECT nickname INTO v_receiver_name
  FROM profiles
  WHERE id = NEW.post_arranged_to;

  -- Notify the receiver that they got the item
  IF NEW.post_arranged_to IS NOT NULL AND NEW.post_arranged_to != v_sharer_id THEN
    INSERT INTO user_notifications (
      id,
      recipient_id,
      actor_id,
      type,
      title,
      body,
      post_id,
      data,
      is_read,
      created_at
    ) VALUES (
      gen_random_uuid(),
      NEW.post_arranged_to,
      v_sharer_id,
      'transaction_complete',
      'You received: ' || NEW.post_name,
      COALESCE(v_sharer_name, 'Someone') || ' shared this item with you',
      NEW.id,
      jsonb_build_object(
        'post_id', NEW.id,
        'post_name', NEW.post_name,
        'sharer_id', v_sharer_id,
        'sharer_name', v_sharer_name
      ),
      FALSE,
      NOW()
    )
    ON CONFLICT DO NOTHING;
  END IF;

  -- Notify the sharer that transaction is complete
  INSERT INTO user_notifications (
    id,
    recipient_id,
    actor_id,
    type,
    title,
    body,
    post_id,
    data,
    is_read,
    created_at
  ) VALUES (
    gen_random_uuid(),
    v_sharer_id,
    NEW.post_arranged_to,
    'transaction_complete',
    'Item shared: ' || NEW.post_name,
    'Your item was shared with ' || COALESCE(v_receiver_name, 'someone'),
    NEW.id,
    jsonb_build_object(
      'post_id', NEW.id,
      'post_name', NEW.post_name,
      'receiver_id', NEW.post_arranged_to,
      'receiver_name', v_receiver_name
    ),
    FALSE,
    NOW()
  )
  ON CONFLICT DO NOTHING;

  RETURN NEW;
END;
$$;


--
-- Name: FUNCTION notify_post_arranged(); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.notify_post_arranged() IS 'Creates notifications when a post transaction is completed';


--
-- Name: notify_review_received(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.notify_review_received() RETURNS trigger
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO ''
    AS $$
DECLARE
  v_reviewer_name text;
  v_post_owner_id uuid;
BEGIN
  -- Get reviewer name
  SELECT COALESCE(first_name, 'Someone') INTO v_reviewer_name
  FROM profiles WHERE id = NEW.reviewer_id;

  -- Get post owner if this is a post review
  IF NEW.post_id IS NOT NULL THEN
    SELECT profile_id INTO v_post_owner_id
    FROM posts WHERE id = NEW.post_id;

    IF v_post_owner_id IS NOT NULL THEN
      PERFORM create_user_notification(
        p_recipient_id := v_post_owner_id,
        p_actor_id := NEW.reviewer_id,
        p_type := 'review_received',
        p_title := v_reviewer_name || ' left you a review',
        p_body := LEFT(NEW.review_text, 100),
        p_post_id := NEW.post_id,
        p_review_id := NEW.id,
        p_data := jsonb_build_object('rating', NEW.rating)
      );
    END IF;
  END IF;

  RETURN NEW;
END;
$$;


--
-- Name: notify_user_blocked(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.notify_user_blocked() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    -- Insert into moderation queue for review
    INSERT INTO moderation_queue (
        item_type,
        item_id,
        reporter_id,
        reason,
        status
    ) VALUES (
        'user_block',
        NEW.blocked_user_id,
        NEW.user_id,
        COALESCE(NEW.reason, 'User blocked'),
        'pending'
    )
    ON CONFLICT DO NOTHING;
    
    RETURN NEW;
END;
$$;


--
-- Name: FUNCTION notify_user_blocked(); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.notify_user_blocked() IS 'Notify developers when user is blocked for moderation review';


--
-- Name: on_email_queued(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.on_email_queued() RETURNS trigger
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
  v_url text;
  v_service_key text;
BEGIN
  v_url := 'https://***REMOVED***/functions/v1/email';
  
  SELECT decrypted_secret INTO v_service_key
  FROM vault.decrypted_secrets
  WHERE name = 'SUPABASE_SERVICE_ROLE_KEY'
  LIMIT 1;
  
  -- Trigger queue processing asynchronously
  PERFORM net.http_post(
    url := v_url,
    headers := jsonb_build_object(
      'Content-Type', 'application/json',
      'Authorization', 'Bearer ' || v_service_key
    ),
    body := '{"action": "process-queue", "batchSize": 10}'::jsonb
  );
  
  RETURN NEW;
END;
$$;


--
-- Name: on_post_user_unliked(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.on_post_user_unliked() RETURNS trigger
    LANGUAGE plpgsql
    SET search_path TO 'public'
    AS $$
BEGIN
  UPDATE public.posts
  SET post_like_counter = GREATEST(COALESCE(post_like_counter, 0) - 1, 0)
  WHERE id = OLD.post_id;
  RETURN OLD;
END;
$$;


--
-- Name: post_views_trigger_func(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.post_views_trigger_func() RETURNS trigger
    LANGUAGE plpgsql
    SET search_path TO 'public'
    AS $$
BEGIN
  UPDATE public.posts
  SET post_views = post_views + 1
  WHERE id = NEW.post_id;
  RETURN NEW;
END;
$$;


--
-- Name: posts_in_view(double precision, double precision, double precision, double precision); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.posts_in_view(min_lat double precision, min_long double precision, max_lat double precision, max_long double precision) RETURNS SETOF record
    LANGUAGE sql
    SET search_path TO ''
    AS $$
	select id, post_name, st_astext(location) as location
	from public.posts
	where location && ST_SetSRID(ST_MakeBox2D(ST_Point(min_long, min_lat), ST_Point(max_long, max_lat)),4326)
$$;


--
-- Name: posts_in_view(numeric, numeric, numeric, numeric); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.posts_in_view(min_lat numeric, min_long numeric, max_lat numeric, max_long numeric) RETURNS SETOF record
    LANGUAGE plpgsql STABLE
    SET search_path TO ''
    AS $$
BEGIN
  RETURN QUERY
  SELECT *
  FROM public.posts
  WHERE active = true
    AND latitude BETWEEN min_lat AND max_lat
    AND longitude BETWEEN min_long AND max_long;
END;
$$;


--
-- Name: sync_version_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.sync_version_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: SEQUENCE sync_version_seq; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON SEQUENCE public.sync_version_seq IS 'Global version counter for sync tracking';


--
-- Name: posts; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.posts (
    post_address text DEFAULT '-'::text NOT NULL,
    post_views integer DEFAULT 0 NOT NULL,
    post_description text DEFAULT '-'::text NOT NULL,
    pickup_time text DEFAULT '-'::text NOT NULL,
    post_type text DEFAULT 'food'::text NOT NULL,
    is_active boolean DEFAULT true NOT NULL,
    post_name text DEFAULT '-'::text NOT NULL,
    transportation text DEFAULT '-'::text,
    id bigint NOT NULL,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT (now() AT TIME ZONE 'utc'::text) NOT NULL,
    post_arranged_to uuid,
    is_arranged boolean DEFAULT false NOT NULL,
    post_arranged_at timestamp with time zone,
    has_pantry boolean DEFAULT false NOT NULL,
    available_hours text DEFAULT '-'::text NOT NULL,
    profile_id uuid NOT NULL,
    website text DEFAULT '-'::text NOT NULL,
    food_in_fridge jsonb,
    fridge_id text,
    network text DEFAULT '-'::text,
    location extensions.geography(Point,4326) DEFAULT NULL::extensions.geography,
    linktree text DEFAULT '-'::text NOT NULL,
    donation text DEFAULT '-'::text NOT NULL,
    location_type text DEFAULT '-'::text NOT NULL,
    local_map text DEFAULT '-'::text NOT NULL,
    news_articles text DEFAULT '-'::text NOT NULL,
    label text DEFAULT '-'::text,
    donation_rules text DEFAULT '-'::text NOT NULL,
    condition character varying(20) DEFAULT 'room for more'::character varying NOT NULL,
    prefill_form text DEFAULT '-'::text NOT NULL,
    post_viewed_at timestamp with time zone DEFAULT (now() AT TIME ZONE 'utc'::text) NOT NULL,
    post_like_counter integer DEFAULT 0,
    post_stripped_address text,
    category_id bigint,
    images text[] DEFAULT '{}'::text[],
    admin_notes text,
    tags text[] DEFAULT '{}'::text[],
    quantity text,
    contact_preferences text[] DEFAULT '{chat}'::text[],
    location_json jsonb GENERATED ALWAYS AS (
CASE
    WHEN (location IS NOT NULL) THEN (extensions.st_asgeojson(location))::jsonb
    ELSE NULL::jsonb
END) STORED,
    sync_version bigint DEFAULT nextval('public.sync_version_seq'::regclass),
    synced_to_motherduck boolean DEFAULT false,
    CONSTRAINT check_post_likes_non_negative CHECK (((post_like_counter IS NULL) OR (post_like_counter >= 0))),
    CONSTRAINT check_post_views_non_negative CHECK ((post_views >= 0)),
    CONSTRAINT posts_condition_check CHECK (((condition)::text = ANY ((ARRAY[''::character varying, 'nearly empty'::character varying, 'room for more'::character varying, 'pretty full'::character varying, 'overflowing'::character varying, 'new'::character varying, 'like-new'::character varying, 'good'::character varying, 'fair'::character varying])::text[]))),
    CONSTRAINT posts_label_check CHECK (((label IS NULL) OR (label = ANY (ARRAY['Network'::text, 'Freedge'::text, 'Farm Collective'::text, '-'::text]))))
);


--
-- Name: TABLE posts; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE public.posts IS 'Stores user posts.';


--
-- Name: COLUMN posts.post_description; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.posts.post_description IS 'Describe your post or project.';


--
-- Name: COLUMN posts.post_type; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.posts.post_type IS 'Type of post - uses singular form (food, things, borrow, wanted, foodbanks, fridges, organisations, volunteers, zero waste, vegan.)';


--
-- Name: COLUMN posts.is_active; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.posts.is_active IS 'Whether the post is active and visible (uses is_ prefix for boolean state)';


--
-- Name: COLUMN posts.created_at; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.posts.created_at IS 'Date Installed for the Fridges or date opened for the Foodbanks';


--
-- Name: COLUMN posts.is_arranged; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.posts.is_arranged IS 'Whether the post has been arranged with someone (uses is_ prefix for boolean state)';


--
-- Name: COLUMN posts.post_arranged_at; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.posts.post_arranged_at IS 'Timestamp when the post was arranged/reserved with someone';


--
-- Name: COLUMN posts.has_pantry; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.posts.has_pantry IS 'Whether the fridge/foodbank has a pantry (uses has_ prefix for boolean possession)';


--
-- Name: COLUMN posts.available_hours; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.posts.available_hours IS 'Available hours for the street fridges and foodbanks';


--
-- Name: COLUMN posts.food_in_fridge; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.posts.food_in_fridge IS 'It can hold one status: "nearly_empty", "room_for_more", "pretty_full", "overflowing" and "unknown" by default';


--
-- Name: COLUMN posts.fridge_id; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.posts.fridge_id IS 'Airtable id';


--
-- Name: COLUMN posts.network; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.posts.network IS 'Fridge and Foodbank networks';


--
-- Name: COLUMN posts.location; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.posts.location IS 'PostGIS geography point (SRID 4326). NULL until geocoded. Automatically populated via location_update_queue system.';


--
-- Name: COLUMN posts.linktree; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.posts.linktree IS 'Linktree is a freemium social media reference landing page developed by Alex Zaccaria, Anthony Zaccaria, and Nick Humphreys, headquartered in Melbourne Australia.';


--
-- Name: COLUMN posts.donation; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.posts.donation IS 'Donation Rules: What food does your fridge accept / not accept (i.e produce, frozen foods, raw meats, hygiene items, other items, etc.)? Accepts $$ donations? (include where: venmo, gofundme, etc.)';


--
-- Name: COLUMN posts.location_type; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.posts.location_type IS 'Location type (church, storefront, etc.)';


--
-- Name: COLUMN posts.local_map; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.posts.local_map IS 'Do you have a local map? (Link to Map)';


--
-- Name: COLUMN posts.news_articles; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.posts.news_articles IS 'News articles (link).';


--
-- Name: COLUMN posts.donation_rules; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.posts.donation_rules IS 'Donation Rules: What food does your fridge accept / not accept (i.e produce, frozen foods, raw meats, hygiene items, other items, etc.)?';


--
-- Name: COLUMN posts.post_viewed_at; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.posts.post_viewed_at IS 'Changed on a raw select';


--
-- Name: COLUMN posts.images; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.posts.images IS 'Array of image URLs. Final correction: using posts bucket for post/listing images on 2024-11-30';


--
-- Name: COLUMN posts.admin_notes; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.posts.admin_notes IS 'Internal admin notes about this listing (not visible to users)';


--
-- Name: COLUMN posts.tags; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.posts.tags IS 'Array of user-defined tags for categorization and search (max 5 tags)';


--
-- Name: COLUMN posts.quantity; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.posts.quantity IS 'Description of quantity available (e.g., "3 portions", "1 bag")';


--
-- Name: COLUMN posts.contact_preferences; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.posts.contact_preferences IS 'Array of contact preferences: chat, phone, email. Defaults to chat only.';


--
-- Name: posts_location_json(public.posts); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.posts_location_json(public.posts) RETURNS json
    LANGUAGE sql STABLE
    SET search_path TO ''
    AS $_$
  SELECT ST_AsGeoJSON($1.location)::json;
$_$;


--
-- Name: FUNCTION posts_location_json(public.posts); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.posts_location_json(public.posts) IS 'Computed column: converts PostGIS geography to GeoJSON for API consumption';


--
-- Name: posts_within_radius(double precision, double precision, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.posts_within_radius(user_lat double precision, user_lng double precision, radius_meters integer DEFAULT 5000) RETURNS TABLE(id integer, post_name text, post_type text, distance_meters double precision, latitude double precision, longitude double precision)
    LANGUAGE sql STABLE
    SET search_path TO ''
    AS $$
  SELECT 
    p.id,
    p.post_name,
    p.post_type,
    ST_Distance(
      p.location,
      ST_SetSRID(ST_MakePoint(user_lng, user_lat), 4326)::geography
    ) as distance_meters,
    ST_Y(p.location::geometry) as latitude,
    ST_X(p.location::geometry) as longitude
  FROM posts p
  WHERE p.is_active = true
    AND ST_DWithin(
      p.location,
      ST_SetSRID(ST_MakePoint(user_lng, user_lat), 4326)::geography,
      radius_meters
    )
  ORDER BY distance_meters;
$$;


--
-- Name: prevent_duplicate_rooms_insert(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.prevent_duplicate_rooms_insert() RETURNS trigger
    LANGUAGE plpgsql
    SET search_path TO 'public'
    AS $$
BEGIN
  IF EXISTS (
    SELECT 1 FROM public.rooms
    WHERE post_id = NEW.post_id
      AND ((requester = NEW.requester AND sharer = NEW.sharer)
        OR (requester = NEW.sharer AND sharer = NEW.requester))
  ) THEN
    RAISE EXCEPTION 'Room already exists for this post and users';
  END IF;
  RETURN NEW;
END;
$$;


--
-- Name: prevent_duplicate_rooms_insert_function(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.prevent_duplicate_rooms_insert_function() RETURNS trigger
    LANGUAGE plpgsql
    SET search_path TO 'public'
    AS $$
BEGIN
  IF EXISTS (
    SELECT 1 FROM public.rooms
    WHERE post_id = NEW.post_id
      AND ((requester = NEW.requester AND sharer = NEW.sharer)
        OR (requester = NEW.sharer AND sharer = NEW.requester))
  ) THEN
    RAISE EXCEPTION 'Room already exists';
  END IF;
  RETURN NEW;
END;
$$;


--
-- Name: process_automation_queue_item(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.process_automation_queue_item(p_queue_id uuid) RETURNS jsonb
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
DECLARE
  v_queue_item record;
  v_profile record;
  v_flow record;
  v_result jsonb;
BEGIN
  SELECT * INTO v_queue_item 
  FROM public.email_automation_queue 
  WHERE id = p_queue_id AND status = 'pending' AND scheduled_for <= now()
  FOR UPDATE SKIP LOCKED;
  
  IF v_queue_item IS NULL THEN
    RETURN jsonb_build_object('success', false, 'error', 'Queue item not found or not ready');
  END IF;
  
  UPDATE public.email_automation_queue SET status = 'processing' WHERE id = p_queue_id;
  
  SELECT * INTO v_profile FROM public.profiles WHERE id = v_queue_item.profile_id;
  SELECT * INTO v_flow FROM public.email_automation_flows WHERE id = v_queue_item.flow_id;
  
  IF v_profile IS NULL OR v_flow IS NULL THEN
    UPDATE public.email_automation_queue SET status = 'failed', error_message = 'Profile or flow not found' WHERE id = p_queue_id;
    RETURN jsonb_build_object('success', false, 'error', 'Profile or flow not found');
  END IF;
  
  v_result := jsonb_build_object(
    'queue_id', p_queue_id,
    'email', v_profile.email,
    'first_name', v_profile.first_name,
    'flow_name', v_flow.name,
    'step_index', v_queue_item.step_index,
    'email_data', v_queue_item.email_data
  );
  
  RETURN v_result;
END;
$$;


--
-- Name: process_bounce_event(text, text, text, text, text, text, jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.process_bounce_event(p_email text, p_provider text, p_event_type text, p_bounce_type text DEFAULT NULL::text, p_bounce_category text DEFAULT NULL::text, p_message_id text DEFAULT NULL::text, p_raw_payload jsonb DEFAULT '{}'::jsonb) RETURNS void
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO ''
    AS $$
BEGIN
  -- Log the event
  INSERT INTO public.email_bounce_events (
    email, provider, event_type, bounce_type, bounce_category, message_id, raw_payload
  ) VALUES (
    lower(p_email), p_provider, p_event_type, p_bounce_type, p_bounce_category, p_message_id, p_raw_payload
  );
  
  -- Add to suppression list for hard bounces and complaints
  IF p_event_type = 'bounce' AND p_bounce_type = 'hard' THEN
    PERFORM public.add_to_suppression_list(
      p_email, 'hard_bounce', p_provider, 'permanent', p_bounce_category, p_message_id, NULL
    );
  ELSIF p_event_type = 'bounce' AND p_bounce_type = 'soft' THEN
    -- Soft bounces: temporary suppression for 24 hours
    PERFORM public.add_to_suppression_list(
      p_email, 'soft_bounce', p_provider, 'transient', p_bounce_category, p_message_id, 
      now() + interval '24 hours'
    );
  ELSIF p_event_type = 'complaint' THEN
    -- Complaints: permanent suppression
    PERFORM public.add_to_suppression_list(
      p_email, 'complaint', p_provider, NULL, NULL, p_message_id, NULL
    );
  ELSIF p_event_type = 'unsubscribe' THEN
    PERFORM public.add_to_suppression_list(
      p_email, 'unsubscribe', p_provider, NULL, NULL, p_message_id, NULL
    );
  END IF;
END;
$$;


--
-- Name: process_location_update_queue(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.process_location_update_queue() RETURNS void
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
DECLARE
  queue_item record;
BEGIN
  FOR queue_item IN 
    SELECT id, post_id FROM public.location_update_queue
    ORDER BY created_at ASC
    LIMIT 10
  LOOP
    PERFORM public.invoke_update_post_coordinates();
    DELETE FROM public.location_update_queue WHERE id = queue_item.id;
  END LOOP;
END;
$$;


--
-- Name: process_notification_digest(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.process_notification_digest() RETURNS jsonb
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
DECLARE
  v_user_id uuid;
  v_frequency text;
  v_notifications jsonb;
  v_count int := 0;
  v_users_processed int := 0;
BEGIN
  -- Process pending digests that are due
  FOR v_user_id, v_frequency IN
    SELECT DISTINCT user_id, frequency
    FROM notification_digest_queue
    WHERE status = 'pending'
      AND scheduled_for <= now()
    ORDER BY user_id
  LOOP
    -- Get all pending notifications for this user/frequency
    SELECT jsonb_agg(
      jsonb_build_object(
        'id', id,
        'type', notification_type,
        'category', category,
        'title', title,
        'body', body,
        'data', data
      )
    ) INTO v_notifications
    FROM notification_digest_queue
    WHERE user_id = v_user_id
      AND frequency = v_frequency
      AND status = 'pending'
      AND scheduled_for <= now();

    -- Mark as sent (actual sending is done by caller)
    UPDATE notification_digest_queue
    SET status = 'sent', sent_at = now()
    WHERE user_id = v_user_id
      AND frequency = v_frequency
      AND status = 'pending'
      AND scheduled_for <= now();

    v_count := v_count + jsonb_array_length(v_notifications);
    v_users_processed := v_users_processed + 1;
  END LOOP;

  RETURN jsonb_build_object(
    'processed', v_count,
    'users', v_users_processed
  );
END;
$$;


--
-- Name: process_notification_queue(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.process_notification_queue(p_batch_size integer DEFAULT 100) RETURNS jsonb
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
DECLARE
  v_processed integer := 0;
  v_consolidated integer := 0;
  v_sent integer := 0;
  v_skipped integer := 0;
  v_group record;
  v_config record;
  v_notification_id uuid;
  v_consolidated_title text;
  v_consolidated_body text;
BEGIN
  -- Process notifications grouped by consolidation key
  FOR v_group IN
    SELECT
      user_id,
      consolidation_key,
      notification_type,
      array_agg(id ORDER BY created_at) AS queue_ids,
      array_agg(title ORDER BY created_at) AS titles,
      array_agg(payload ORDER BY created_at) AS payloads,
      COUNT(*) AS count,
      MAX(priority) AS max_priority,
      MIN(scheduled_for) AS first_scheduled
    FROM notification_queue
    WHERE status = 'pending'
      AND scheduled_for <= NOW()
    GROUP BY user_id, consolidation_key, notification_type
    ORDER BY MAX(priority) DESC, MIN(scheduled_for)
    LIMIT p_batch_size
  LOOP
    v_processed := v_processed + v_group.count;

    -- Get config for this type
    SELECT * INTO v_config
    FROM notification_priority_config
    WHERE notification_type = v_group.notification_type;

    -- Recheck quiet hours (might have changed)
    IF NOT COALESCE(v_config.bypass_quiet_hours, false) AND check_quiet_hours(v_group.user_id) THEN
      -- Reschedule for after quiet hours
      UPDATE notification_queue
      SET scheduled_for = get_quiet_hours_end(v_group.user_id)
      WHERE id = ANY(v_group.queue_ids);

      v_skipped := v_skipped + v_group.count;
      CONTINUE;
    END IF;

    -- Consolidate if multiple and allowed
    IF v_group.count > 1 AND NOT COALESCE(v_config.bypass_consolidation, false) THEN
      -- Create consolidated notification
      v_consolidated_title := CASE v_group.notification_type
        WHEN 'new_listing' THEN v_group.count || ' new listings nearby'
        WHEN 'message' THEN v_group.count || ' new messages'
        WHEN 'match_found' THEN v_group.count || ' new matches'
        ELSE v_group.count || ' new notifications'
      END;

      v_consolidated_body := 'Tap to view all';

      INSERT INTO notifications (
        profile_id,
        notification_title,
        notification_text,
        parameter_data,
        initial_page_name,
        status
      ) VALUES (
        v_group.user_id,
        v_consolidated_title,
        v_consolidated_body,
        jsonb_build_object(
          'type', 'consolidated',
          'originalType', v_group.notification_type,
          'count', v_group.count,
          'items', v_group.payloads
        ),
        CASE v_group.notification_type
          WHEN 'message' THEN 'Messages'
          WHEN 'new_listing' THEN 'Browse'
          ELSE 'Notifications'
        END,
        'pending'
      )
      RETURNING id INTO v_notification_id;

      -- Mark queue items as consolidated
      UPDATE notification_queue
      SET status = 'consolidated',
          processed_at = NOW(),
          consolidated_count = v_group.count
      WHERE id = ANY(v_group.queue_ids);

      v_consolidated := v_consolidated + 1;
      v_sent := v_sent + 1;
    ELSE
      -- Send individual notification(s)
      FOR i IN 1..array_length(v_group.queue_ids, 1) LOOP
        INSERT INTO notifications (
          profile_id,
          notification_title,
          notification_text,
          parameter_data,
          initial_page_name,
          status
        ) VALUES (
          v_group.user_id,
          v_group.titles[i],
          (v_group.payloads[i])->>'body',
          v_group.payloads[i],
          COALESCE((v_group.payloads[i])->>'screen', 'Notifications'),
          'pending'
        );

        -- Mark as sent
        UPDATE notification_queue
        SET status = 'sent',
            processed_at = NOW()
        WHERE id = v_group.queue_ids[i];

        v_sent := v_sent + 1;
      END LOOP;
    END IF;
  END LOOP;

  RETURN jsonb_build_object(
    'success', true,
    'stats', jsonb_build_object(
      'processed', v_processed,
      'consolidated', v_consolidated,
      'sent', v_sent,
      'skipped', v_skipped
    ),
    'meta', jsonb_build_object('timestamp', NOW())
  );
END;
$$;


--
-- Name: FUNCTION process_notification_queue(p_batch_size integer); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.process_notification_queue(p_batch_size integer) IS 'Processes and consolidates queued notifications';


--
-- Name: process_publication_queue(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.process_publication_queue() RETURNS integer
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
DECLARE
  v_queue_item RECORD;
  v_new_forum_id INTEGER;
  v_processed INTEGER := 0;
BEGIN
  FOR v_queue_item IN 
    SELECT pq.*, sp.*
    FROM forum_publication_queue pq
    JOIN forum_scheduled_posts sp ON sp.id = pq.scheduled_post_id
    WHERE pq.status = 'pending'
      AND pq.scheduled_for <= now()
      AND pq.attempts < pq.max_attempts
    ORDER BY pq.scheduled_for, pq.priority DESC
    LIMIT 10
    FOR UPDATE OF pq SKIP LOCKED
  LOOP
    BEGIN
      -- Mark as processing
      UPDATE forum_publication_queue
      SET status = 'processing', last_attempt_at = now(), attempts = attempts + 1
      WHERE id = v_queue_item.id;
      
      -- Create the actual forum post
      INSERT INTO forum (
        profile_id, forum_post_name, forum_post_description,
        category_id, post_type, rich_content, forum_post_image,
        series_id, series_order, forum_published
      ) VALUES (
        v_queue_item.profile_id, v_queue_item.title, v_queue_item.description,
        v_queue_item.category_id, v_queue_item.post_type, v_queue_item.rich_content,
        v_queue_item.image_url, v_queue_item.series_id, v_queue_item.series_order, true
      )
      RETURNING id INTO v_new_forum_id;
      
      -- Handle tags if present
      IF v_queue_item.tags IS NOT NULL AND array_length(v_queue_item.tags, 1) > 0 THEN
        INSERT INTO forum_post_tags (forum_id, tag_id)
        SELECT v_new_forum_id, unnest(v_queue_item.tags);
      END IF;
      
      -- Handle poll if present
      IF v_queue_item.poll_data IS NOT NULL THEN
        -- Create poll logic here
        NULL;
      END IF;
      
      -- Update scheduled post status
      UPDATE forum_scheduled_posts
      SET status = 'published', published_at = now(), published_forum_id = v_new_forum_id
      WHERE id = v_queue_item.scheduled_post_id;
      
      -- Mark queue item as completed
      UPDATE forum_publication_queue
      SET status = 'completed'
      WHERE id = v_queue_item.id;
      
      v_processed := v_processed + 1;
      
    EXCEPTION WHEN OTHERS THEN
      -- Mark as failed if max attempts reached
      UPDATE forum_publication_queue
      SET 
        status = CASE WHEN attempts >= max_attempts THEN 'failed' ELSE 'pending' END,
        error_message = SQLERRM
      WHERE id = v_queue_item.id;
      
      IF v_queue_item.attempts >= v_queue_item.max_attempts THEN
        UPDATE forum_scheduled_posts
        SET status = 'failed', failure_reason = SQLERRM
        WHERE id = v_queue_item.scheduled_post_id;
      END IF;
    END;
  END LOOP;
  
  RETURN v_processed;
END;
$$;


--
-- Name: publish_draft(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.publish_draft(p_draft_id uuid) RETURNS jsonb
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
DECLARE
  v_user_id UUID := auth.uid();
  v_draft RECORD;
  v_forum_id BIGINT;
  v_poll_id UUID;
  v_tag_id INT;
BEGIN
  IF v_user_id IS NULL THEN
    RAISE EXCEPTION 'Not authenticated';
  END IF;
  
  -- Get draft
  SELECT * INTO v_draft FROM public.forum_drafts
  WHERE id = p_draft_id AND profile_id = v_user_id;
  
  IF v_draft IS NULL THEN
    RAISE EXCEPTION 'Draft not found';
  END IF;
  
  -- Validate required fields
  IF v_draft.title IS NULL OR v_draft.title = '' THEN
    RAISE EXCEPTION 'Title is required';
  END IF;
  
  IF v_draft.description IS NULL AND v_draft.rich_content IS NULL THEN
    RAISE EXCEPTION 'Content is required';
  END IF;
  
  -- Create forum post
  INSERT INTO public.forum (
    profile_id, forum_post_name, forum_post_description, rich_content,
    category_id, post_type, forum_post_image, forum_published
  ) VALUES (
    v_user_id, v_draft.title, v_draft.description, v_draft.rich_content,
    v_draft.category_id, v_draft.post_type, v_draft.image_url, true
  )
  RETURNING id INTO v_forum_id;
  
  -- Add tags if any
  IF v_draft.tags IS NOT NULL THEN
    FOREACH v_tag_id IN ARRAY v_draft.tags
    LOOP
      INSERT INTO public.forum_post_tags (forum_id, tag_id)
      VALUES (v_forum_id, v_tag_id)
      ON CONFLICT DO NOTHING;
    END LOOP;
  END IF;
  
  -- Create poll if draft has poll data
  IF v_draft.poll_data IS NOT NULL AND v_draft.poll_data->>'question' IS NOT NULL THEN
    PERFORM public.create_forum_poll(
      v_forum_id,
      v_draft.poll_data->>'question',
      ARRAY(SELECT jsonb_array_elements_text(v_draft.poll_data->'options')),
      COALESCE(v_draft.poll_data->>'poll_type', 'single'),
      (v_draft.poll_data->>'ends_at')::TIMESTAMP WITH TIME ZONE,
      COALESCE((v_draft.poll_data->>'is_anonymous')::BOOLEAN, false),
      COALESCE((v_draft.poll_data->>'show_results_before_vote')::BOOLEAN, false)
    );
  END IF;
  
  -- Delete draft
  DELETE FROM public.forum_drafts WHERE id = p_draft_id;
  
  RETURN jsonb_build_object(
    'forum_id', v_forum_id,
    'published', true
  );
END;
$$;


--
-- Name: publish_forum_series(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.publish_forum_series(p_series_id uuid) RETURNS boolean
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
DECLARE
  v_series_owner UUID;
  v_posts_count INTEGER;
BEGIN
  SELECT profile_id, posts_count INTO v_series_owner, v_posts_count
  FROM forum_series WHERE id = p_series_id;
  
  IF v_series_owner != auth.uid() THEN
    RAISE EXCEPTION 'Only the series owner can publish';
  END IF;
  
  IF v_posts_count < 1 THEN
    RAISE EXCEPTION 'Series must have at least one post';
  END IF;
  
  UPDATE forum_series
  SET 
    is_published = true,
    published_at = now(),
    updated_at = now()
  WHERE id = p_series_id;
  
  RETURN true;
END;
$$;


--
-- Name: queue_email(uuid, text, text, text, jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.queue_email(p_recipient_id uuid, p_recipient_email text, p_email_type text, p_template_name text, p_template_data jsonb DEFAULT '{}'::jsonb) RETURNS uuid
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO ''
    AS $$
DECLARE
  v_queue_id UUID;
BEGIN
  INSERT INTO public.email_queue (
    recipient_id,
    recipient_email,
    email_type,
    template_name,
    template_data,
    status,
    next_retry_at
  )
  VALUES (
    p_recipient_id,
    p_recipient_email,
    p_email_type,
    p_template_name,
    p_template_data,
    'queued',
    now()
  )
  RETURNING id INTO v_queue_id;

  RETURN v_queue_id;
END;
$$;


--
-- Name: queue_location_update(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.queue_location_update() RETURNS trigger
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
BEGIN
    -- Skip location queueing if PostGIS is not available or for view-only updates
    IF TG_OP = 'UPDATE' AND 
       OLD.post_views IS DISTINCT FROM NEW.post_views AND
       OLD.post_address IS NOT DISTINCT FROM NEW.post_address THEN
        -- This is just a view count update, skip location processing
        RETURN NEW;
    END IF;
    
    -- Only process location updates when address actually changed
    IF TG_OP = 'INSERT' OR 
       (TG_OP = 'UPDATE' AND OLD.post_address IS DISTINCT FROM NEW.post_address) THEN
        -- Queue for location update (handled by separate process)
        INSERT INTO location_update_queue (post_id, address, created_at)
        VALUES (NEW.id, NEW.post_address, NOW())
        ON CONFLICT (post_id) DO UPDATE SET address = EXCLUDED.address, created_at = NOW();
    END IF;
    
    RETURN NEW;
EXCEPTION WHEN OTHERS THEN
    -- Log error but don't fail the transaction
    RAISE WARNING 'queue_location_update error: %', SQLERRM;
    RETURN NEW;
END;
$$;


--
-- Name: FUNCTION queue_location_update(); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.queue_location_update() IS 'Trigger function to automatically queue posts for geocoding when created or address updated';


--
-- Name: queue_location_update(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.queue_location_update(post_id integer) RETURNS void
    LANGUAGE plpgsql
    SET search_path TO 'public'
    AS $$
BEGIN
  INSERT INTO public.location_update_queue (post_id)
  VALUES (post_id)
  ON CONFLICT DO NOTHING;
END;
$$;


--
-- Name: queue_nearby_notifications(uuid, uuid, double precision, double precision, text, text, double precision, text, boolean); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.queue_nearby_notifications(p_food_item_id uuid, p_sender_id uuid, p_latitude double precision, p_longitude double precision, p_title text, p_notification_type text DEFAULT 'nearby_post'::text, p_radius_km double precision DEFAULT 10, p_consolidation_key text DEFAULT NULL::text, p_bypass_quiet_hours boolean DEFAULT false) RETURNS jsonb
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public', 'extensions'
    AS $$
DECLARE
  v_point extensions.geography;
  v_user record;
  v_queued integer := 0;
  v_deferred integer := 0;
  v_immediate integer := 0;
  v_skipped integer := 0;
  v_config record;
  v_is_quiet boolean;
  v_scheduled_for timestamptz;
  v_consolidation text;
  v_priority integer;
  v_payload jsonb;
BEGIN
  -- Create point from coordinates
  v_point := extensions.ST_SetSRID(extensions.ST_MakePoint(p_longitude, p_latitude), 4326)::extensions.geography;
  
  -- Get notification priority config
  SELECT * INTO v_config
  FROM notification_priority_config
  WHERE notification_type = p_notification_type;
  
  v_priority := COALESCE(v_config.base_priority, 5);
  
  -- Set consolidation key (group by rough area)
  v_consolidation := COALESCE(
    p_consolidation_key,
    p_notification_type || ':' || ROUND(p_latitude::numeric, 2)::text || ':' || ROUND(p_longitude::numeric, 2)::text
  );
  
  -- Find nearby users
  FOR v_user IN
    SELECT 
      p.id as user_id,
      p.notification_preferences,
      extensions.ST_Distance(p.location, v_point) / 1000.0 as distance_km
    FROM profiles p
    WHERE p.location IS NOT NULL
      AND p.id != p_sender_id
      AND p.is_active = true
      AND extensions.ST_DWithin(p.location, v_point, p_radius_km * 1000)
    ORDER BY extensions.ST_Distance(p.location, v_point)
    LIMIT 500
  LOOP
    -- Check if user wants new listing notifications
    IF v_user.notification_preferences IS NULL OR 
       NOT COALESCE((v_user.notification_preferences->>'new_listings')::boolean, true) THEN
      v_skipped := v_skipped + 1;
      CONTINUE;
    END IF;
    
    -- Build payload
    v_payload := jsonb_build_object(
      'food_item_id', p_food_item_id,
      'sender_id', p_sender_id,
      'distance_km', ROUND(v_user.distance_km::numeric, 1),
      'title', p_title
    );
    
    -- Check quiet hours
    v_is_quiet := false;
    IF NOT p_bypass_quiet_hours AND NOT COALESCE(v_config.bypass_quiet_hours, false) THEN
      v_is_quiet := check_quiet_hours(v_user.user_id);
    END IF;
    
    IF v_is_quiet THEN
      v_scheduled_for := get_quiet_hours_end(v_user.user_id);
      v_deferred := v_deferred + 1;
    ELSE
      v_scheduled_for := NOW();
      v_immediate := v_immediate + 1;
    END IF;
    
    -- Insert into queue
    INSERT INTO notification_queue (
      user_id,
      notification_type,
      consolidation_key,
      title,
      body,
      payload,
      priority,
      scheduled_for,
      status
    ) VALUES (
      v_user.user_id,
      p_notification_type,
      v_consolidation || ':' || v_user.user_id::text || ':' || to_char(NOW(), 'YYYY-MM-DD-HH24'),
      p_title,
      'New food available near you!',
      v_payload,
      v_priority,
      v_scheduled_for,
      'pending'
    );
    
    v_queued := v_queued + 1;
  END LOOP;
  
  RETURN jsonb_build_object(
    'success', true,
    'queued', v_queued,
    'immediate', v_immediate,
    'deferred', v_deferred,
    'skipped', v_skipped,
    'consolidationKey', v_consolidation
  );
  
EXCEPTION WHEN OTHERS THEN
  RETURN jsonb_build_object(
    'success', false,
    'error', SQLERRM,
    'queued', v_queued
  );
END;
$$;


--
-- Name: FUNCTION queue_nearby_notifications(p_food_item_id uuid, p_sender_id uuid, p_latitude double precision, p_longitude double precision, p_title text, p_notification_type text, p_radius_km double precision, p_consolidation_key text, p_bypass_quiet_hours boolean); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.queue_nearby_notifications(p_food_item_id uuid, p_sender_id uuid, p_latitude double precision, p_longitude double precision, p_title text, p_notification_type text, p_radius_km double precision, p_consolidation_key text, p_bypass_quiet_hours boolean) IS 'Queue notifications for users near a location with consolidation support';


--
-- Name: queue_newsletter_fair(uuid, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.queue_newsletter_fair(p_campaign_id uuid, p_batch_size integer DEFAULT 100) RETURNS jsonb
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
DECLARE
  v_queued integer := 0;
  v_user record;
  v_campaign_template text;
BEGIN
  -- Get campaign template
  SELECT template_slug INTO v_campaign_template
  FROM newsletter_campaigns
  WHERE id = p_campaign_id;

  -- Queue emails for underserved users
  FOR v_user IN
    SELECT * FROM get_underserved_users(p_campaign_id, p_batch_size)
  LOOP
    INSERT INTO email_delivery_log (
      user_id,
      campaign_id,
      email_type,
      template_slug,
      status
    ) VALUES (
      v_user.user_id,
      p_campaign_id,
      'newsletter',
      v_campaign_template,
      'queued'
    );

    v_queued := v_queued + 1;
  END LOOP;

  RETURN jsonb_build_object(
    'success', true,
    'queued', v_queued,
    'campaignId', p_campaign_id
  );
END;
$$;


--
-- Name: FUNCTION queue_newsletter_fair(p_campaign_id uuid, p_batch_size integer); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.queue_newsletter_fair(p_campaign_id uuid, p_batch_size integer) IS 'Queues newsletter emails with fairness algorithm';


--
-- Name: queue_notification(uuid, text, text, jsonb, integer, text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.queue_notification(p_user_id uuid, p_type text, p_title text, p_payload jsonb DEFAULT '{}'::jsonb, p_priority integer DEFAULT NULL::integer, p_consolidation_key text DEFAULT NULL::text) RETURNS jsonb
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
DECLARE
  v_config record;
  v_priority integer;
  v_consolidation_key text;
  v_scheduled_for timestamptz := NOW();
  v_hour_count integer;
  v_queue_id uuid;
BEGIN
  -- Get priority configuration
  SELECT * INTO v_config
  FROM notification_priority_config
  WHERE notification_type = p_type;

  -- Set priority
  v_priority := COALESCE(p_priority, v_config.base_priority, 5);

  -- Set consolidation key
  v_consolidation_key := COALESCE(
    p_consolidation_key,
    p_type || ':' || p_user_id::text || ':' || to_char(NOW(), 'YYYY-MM-DD-HH24')
  );

  -- Check rate limit
  IF v_config.max_per_hour IS NOT NULL THEN
    SELECT COUNT(*) INTO v_hour_count
    FROM notification_queue
    WHERE user_id = p_user_id
      AND notification_type = p_type
      AND created_at > NOW() - INTERVAL '1 hour'
      AND status IN ('pending', 'sent');

    IF v_hour_count >= v_config.max_per_hour THEN
      RETURN jsonb_build_object(
        'success', false,
        'error', 'RATE_LIMITED',
        'message', 'Maximum notifications per hour exceeded'
      );
    END IF;
  END IF;

  -- Check quiet hours (unless bypassed)
  IF NOT COALESCE(v_config.bypass_quiet_hours, false) THEN
    IF check_quiet_hours(p_user_id) THEN
      v_scheduled_for := get_quiet_hours_end(p_user_id);
    END IF;
  END IF;

  -- Insert into queue
  INSERT INTO notification_queue (
    user_id, notification_type, consolidation_key,
    title, body, payload, priority, scheduled_for
  ) VALUES (
    p_user_id, p_type, v_consolidation_key,
    p_title, p_payload->>'body', p_payload, v_priority, v_scheduled_for
  )
  RETURNING id INTO v_queue_id;

  RETURN jsonb_build_object(
    'success', true,
    'queueId', v_queue_id,
    'scheduledFor', v_scheduled_for,
    'priority', v_priority,
    'willConsolidate', NOT COALESCE(v_config.bypass_consolidation, false)
  );
END;
$$;


--
-- Name: FUNCTION queue_notification(p_user_id uuid, p_type text, p_title text, p_payload jsonb, p_priority integer, p_consolidation_key text); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.queue_notification(p_user_id uuid, p_type text, p_title text, p_payload jsonb, p_priority integer, p_consolidation_key text) IS 'Queues notification with priority and consolidation';


--
-- Name: record_activity(text, integer, integer, uuid, integer, uuid, jsonb, boolean); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.record_activity(p_activity_type text, p_target_forum_id integer DEFAULT NULL::integer, p_target_comment_id integer DEFAULT NULL::integer, p_target_profile_id uuid DEFAULT NULL::uuid, p_target_badge_id integer DEFAULT NULL::integer, p_target_series_id uuid DEFAULT NULL::uuid, p_metadata jsonb DEFAULT '{}'::jsonb, p_is_public boolean DEFAULT true) RETURNS uuid
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO ''
    AS $$
DECLARE
  v_activity_id UUID;
BEGIN
  INSERT INTO forum_activities (
    profile_id,
    activity_type,
    target_forum_id,
    target_comment_id,
    target_profile_id,
    target_badge_id,
    target_series_id,
    metadata,
    is_public
  ) VALUES (
    auth.uid(),
    p_activity_type,
    p_target_forum_id,
    p_target_comment_id,
    p_target_profile_id,
    p_target_badge_id,
    p_target_series_id,
    p_metadata,
    p_is_public
  )
  RETURNING id INTO v_activity_id;
  
  RETURN v_activity_id;
END;
$$;


--
-- Name: record_activity(bigint, text, text, text, date, integer, integer, integer, integer, jsonb, jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.record_activity(p_user_id bigint, p_username text, p_first_name text, p_last_name text, p_date date, p_message_count integer, p_characters integer, p_media_count integer, p_reply_count integer, p_emoji_usage jsonb, p_word_usage jsonb) RETURNS void
    LANGUAGE plpgsql
    SET search_path TO ''
    AS $$
BEGIN
  INSERT INTO telegram_user_activity (
    user_id,
    username,
    first_name,
    last_name,
    message_count,
    first_message_date,
    last_message_date,
    total_characters,
    media_count,
    reply_count,
    active_days,
    emoji_usage,
    most_used_words,
    updated_at
  )
  VALUES (
    p_user_id,
    p_username,
    p_first_name,
    p_last_name,
    p_message_count,
    p_date,
    p_date,
    p_characters,
    p_media_count,
    p_reply_count,
    ARRAY[p_date::TEXT],
    p_emoji_usage,
    p_word_usage,
    NOW()
  )
  ON CONFLICT (user_id) DO UPDATE SET
    username = COALESCE(p_username, telegram_user_activity.username),
    first_name = COALESCE(p_first_name, telegram_user_activity.first_name),
    last_name = COALESCE(p_last_name, telegram_user_activity.last_name),
    message_count = telegram_user_activity.message_count + p_message_count,
    last_message_date = p_date,
    total_characters = telegram_user_activity.total_characters + p_characters,
    media_count = telegram_user_activity.media_count + p_media_count,
    reply_count = telegram_user_activity.reply_count + p_reply_count,
    active_days = CASE
      WHEN p_date::TEXT = ANY(telegram_user_activity.active_days) THEN telegram_user_activity.active_days
      ELSE array_append(telegram_user_activity.active_days, p_date::TEXT)
    END,
    emoji_usage = telegram_user_activity.emoji_usage || p_emoji_usage,
    most_used_words = telegram_user_activity.most_used_words || p_word_usage,
    updated_at = NOW();
END;
$$;


--
-- Name: record_announcement_event(uuid, text, text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.record_announcement_event(p_announcement_id uuid, p_event_type text, p_page_url text DEFAULT NULL::text) RETURNS void
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
BEGIN
  INSERT INTO forum_announcement_analytics (announcement_id, profile_id, event_type, page_url)
  VALUES (p_announcement_id, auth.uid(), p_event_type, p_page_url);
  
  IF p_event_type = 'view' THEN
    UPDATE forum_announcements SET views_count = views_count + 1 WHERE id = p_announcement_id;
  ELSIF p_event_type = 'click' THEN
    UPDATE forum_announcements SET clicks_count = clicks_count + 1 WHERE id = p_announcement_id;
  END IF;
END;
$$;


--
-- Name: record_circuit_event(text, text, text, integer, integer, integer, text, text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.record_circuit_event(p_circuit_name text, p_state text, p_previous_state text DEFAULT NULL::text, p_failure_count integer DEFAULT 0, p_success_count integer DEFAULT 0, p_consecutive_failures integer DEFAULT 0, p_trigger_reason text DEFAULT NULL::text, p_app_platform text DEFAULT NULL::text) RETURNS void
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public', 'pg_temp'
    AS $$
BEGIN
    INSERT INTO metrics.circuit_breaker_events (
        circuit_name, state, previous_state, failure_count, success_count,
        consecutive_failures, trigger_reason, app_platform
    ) VALUES (
        p_circuit_name, p_state, p_previous_state, p_failure_count, p_success_count,
        p_consecutive_failures, p_trigger_reason, p_app_platform
    );
END;
$$;


--
-- Name: FUNCTION record_circuit_event(p_circuit_name text, p_state text, p_previous_state text, p_failure_count integer, p_success_count integer, p_consecutive_failures integer, p_trigger_reason text, p_app_platform text); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.record_circuit_event(p_circuit_name text, p_state text, p_previous_state text, p_failure_count integer, p_success_count integer, p_consecutive_failures integer, p_trigger_reason text, p_app_platform text) IS 'Records a circuit breaker state change event';


--
-- Name: record_compressed_image(text, text, bigint, bigint); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.record_compressed_image(p_bucket text, p_path text, p_original_size bigint, p_compressed_size bigint) RETURNS void
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO ''
    AS $$
BEGIN
  INSERT INTO public.compressed_images (bucket_id, object_path, original_size, compressed_size, savings_percent)
  VALUES (
    p_bucket, 
    p_path, 
    p_original_size, 
    p_compressed_size,
    ROUND((1 - p_compressed_size::decimal / p_original_size) * 100, 2)
  )
  ON CONFLICT (bucket_id, object_path) 
  DO UPDATE SET 
    original_size = EXCLUDED.original_size,
    compressed_size = EXCLUDED.compressed_size,
    savings_percent = EXCLUDED.savings_percent,
    compressed_at = NOW();
END;
$$;


--
-- Name: record_compression_result(text, text, text, bigint, bigint, integer, integer, integer, integer, text, text, text, integer, integer, text, text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.record_compression_result(p_bucket text, p_original_path text, p_compressed_path text DEFAULT NULL::text, p_original_size bigint DEFAULT NULL::bigint, p_compressed_size bigint DEFAULT NULL::bigint, p_original_width integer DEFAULT NULL::integer, p_original_height integer DEFAULT NULL::integer, p_compressed_width integer DEFAULT NULL::integer, p_compressed_height integer DEFAULT NULL::integer, p_original_format text DEFAULT NULL::text, p_compressed_format text DEFAULT NULL::text, p_compression_method text DEFAULT NULL::text, p_quality_setting integer DEFAULT NULL::integer, p_processing_time_ms integer DEFAULT NULL::integer, p_status text DEFAULT 'pending'::text, p_error_message text DEFAULT NULL::text) RETURNS uuid
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
DECLARE
  v_id UUID;
BEGIN
  INSERT INTO public.image_compressions (
    bucket, original_path, compressed_path,
    original_size, compressed_size,
    original_width, original_height, compressed_width, compressed_height,
    original_format, compressed_format,
    compression_method, quality_setting, processing_time_ms,
    status, error_message, completed_at
  ) VALUES (
    p_bucket, p_original_path, p_compressed_path,
    p_original_size, p_compressed_size,
    p_original_width, p_original_height, p_compressed_width, p_compressed_height,
    p_original_format, p_compressed_format,
    p_compression_method, p_quality_setting, p_processing_time_ms,
    p_status, p_error_message, 
    CASE WHEN p_status IN ('completed', 'failed', 'skipped') THEN NOW() ELSE NULL END
  )
  ON CONFLICT (bucket, original_path) 
  DO UPDATE SET
    compressed_path = EXCLUDED.compressed_path,
    compressed_size = EXCLUDED.compressed_size,
    compressed_width = EXCLUDED.compressed_width,
    compressed_height = EXCLUDED.compressed_height,
    compressed_format = EXCLUDED.compressed_format,
    compression_method = EXCLUDED.compression_method,
    quality_setting = EXCLUDED.quality_setting,
    processing_time_ms = EXCLUDED.processing_time_ms,
    status = EXCLUDED.status,
    error_message = EXCLUDED.error_message,
    completed_at = CASE WHEN EXCLUDED.status IN ('completed', 'failed', 'skipped') THEN NOW() ELSE public.image_compressions.completed_at END
  RETURNING id INTO v_id;
  
  RETURN v_id;
END;
$$;


--
-- Name: record_email_metrics(text, boolean, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.record_email_metrics(p_provider text, p_success boolean, p_latency_ms integer) RETURNS void
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO ''
    AS $$
BEGIN
  INSERT INTO email_provider_metrics (
    provider,
    date,
    total_requests,
    success_count,
    failure_count,
    total_latency_ms
  ) VALUES (
    p_provider,
    CURRENT_DATE,
    1,
    CASE WHEN p_success THEN 1 ELSE 0 END,
    CASE WHEN p_success THEN 0 ELSE 1 END,
    p_latency_ms
  )
  ON CONFLICT (provider, date) DO UPDATE SET
    total_requests = email_provider_metrics.total_requests + 1,
    success_count = email_provider_metrics.success_count + CASE WHEN p_success THEN 1 ELSE 0 END,
    failure_count = email_provider_metrics.failure_count + CASE WHEN p_success THEN 0 ELSE 1 END,
    total_latency_ms = email_provider_metrics.total_latency_ms + p_latency_ms,
    updated_at = NOW();
END;
$$;


--
-- Name: record_email_send(text, boolean, integer, text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.record_email_send(p_provider text, p_success boolean, p_latency_ms integer DEFAULT 0, p_message_id text DEFAULT NULL::text) RETURNS void
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
BEGIN
  -- Update health metrics
  INSERT INTO email_provider_health_metrics (
    provider,
    total_requests,
    successful_requests,
    failed_requests,
    average_latency_ms,
    daily_quota_used,
    consecutive_failures,
    last_success_at,
    last_failure_at,
    last_updated
  )
  VALUES (
    p_provider,
    1,
    CASE WHEN p_success THEN 1 ELSE 0 END,
    CASE WHEN p_success THEN 0 ELSE 1 END,
    p_latency_ms,
    CASE WHEN p_success THEN 1 ELSE 0 END,
    CASE WHEN p_success THEN 0 ELSE 1 END,
    CASE WHEN p_success THEN now() ELSE NULL END,
    CASE WHEN NOT p_success THEN now() ELSE NULL END,
    now()
  )
  ON CONFLICT (provider) DO UPDATE SET
    total_requests = email_provider_health_metrics.total_requests + 1,
    successful_requests = email_provider_health_metrics.successful_requests + CASE WHEN p_success THEN 1 ELSE 0 END,
    failed_requests = email_provider_health_metrics.failed_requests + CASE WHEN p_success THEN 0 ELSE 1 END,
    average_latency_ms = CASE
      WHEN email_provider_health_metrics.total_requests > 0
      THEN ((email_provider_health_metrics.average_latency_ms * email_provider_health_metrics.total_requests + p_latency_ms) / (email_provider_health_metrics.total_requests + 1))::integer
      ELSE p_latency_ms
    END,
    daily_quota_used = email_provider_health_metrics.daily_quota_used + CASE WHEN p_success THEN 1 ELSE 0 END,
    consecutive_failures = CASE
      WHEN p_success THEN 0
      ELSE email_provider_health_metrics.consecutive_failures + 1
    END,
    health_score = CASE
      WHEN p_success THEN LEAST(100, email_provider_health_metrics.health_score + 5)
      ELSE GREATEST(0, email_provider_health_metrics.health_score - 10)
    END,
    last_success_at = CASE WHEN p_success THEN now() ELSE email_provider_health_metrics.last_success_at END,
    last_failure_at = CASE WHEN NOT p_success THEN now() ELSE email_provider_health_metrics.last_failure_at END,
    last_updated = now();

  -- Also update email_provider_stats for historical tracking
  PERFORM increment_email_provider_stats(p_provider, p_success, p_latency_ms);
END;
$$;


--
-- Name: FUNCTION record_email_send(p_provider text, p_success boolean, p_latency_ms integer, p_message_id text); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.record_email_send(p_provider text, p_success boolean, p_latency_ms integer, p_message_id text) IS 'Records an email send attempt and updates provider health metrics';


--
-- Name: record_forum_search(text, jsonb, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.record_forum_search(p_query text, p_filters jsonb DEFAULT '{}'::jsonb, p_results_count integer DEFAULT 0) RETURNS jsonb
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
DECLARE
  v_normalized_query TEXT;
BEGIN
  -- Normalize query (lowercase, trim)
  v_normalized_query := lower(trim(p_query));
  
  -- Skip if query is too short
  IF char_length(v_normalized_query) < 2 THEN
    RETURN jsonb_build_object('recorded', false, 'reason', 'query_too_short');
  END IF;
  
  -- Add to user's search history (if authenticated)
  IF auth.uid() IS NOT NULL THEN
    INSERT INTO forum_search_history (profile_id, query, filters, results_count)
    VALUES (auth.uid(), v_normalized_query, p_filters, p_results_count);
    
    -- Keep only last 100 searches per user
    DELETE FROM forum_search_history
    WHERE id IN (
      SELECT id FROM forum_search_history
      WHERE profile_id = auth.uid()
      ORDER BY searched_at DESC
      OFFSET 100
    );
  END IF;
  
  -- Update popular searches (aggregate stats)
  INSERT INTO forum_popular_searches (query, search_count, last_searched_at, first_searched_at)
  VALUES (v_normalized_query, 1, now(), now())
  ON CONFLICT (query) DO UPDATE SET
    search_count = forum_popular_searches.search_count + 1,
    last_searched_at = now();
  
  RETURN jsonb_build_object('recorded', true, 'query', v_normalized_query);
END;
$$;


--
-- Name: record_post_view_analytics(integer, text, text, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.record_post_view_analytics(p_forum_id integer, p_referrer text DEFAULT NULL::text, p_device_type text DEFAULT 'desktop'::text, p_time_spent_seconds integer DEFAULT 0) RETURNS void
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
DECLARE
  v_today DATE := CURRENT_DATE;
  v_referrer_key TEXT;
BEGIN
  -- Normalize referrer
  v_referrer_key := COALESCE(
    CASE 
      WHEN p_referrer ILIKE '%google%' THEN 'google'
      WHEN p_referrer ILIKE '%facebook%' THEN 'facebook'
      WHEN p_referrer ILIKE '%twitter%' OR p_referrer ILIKE '%x.com%' THEN 'twitter'
      WHEN p_referrer ILIKE '%linkedin%' THEN 'linkedin'
      WHEN p_referrer ILIKE '%reddit%' THEN 'reddit'
      WHEN p_referrer IS NULL OR p_referrer = '' THEN 'direct'
      ELSE 'other'
    END,
    'direct'
  );
  
  -- Upsert daily analytics
  INSERT INTO forum_post_analytics (forum_id, date, views_count, referrer_sources, device_breakdown)
  VALUES (
    p_forum_id, 
    v_today, 
    1,
    jsonb_build_object(v_referrer_key, 1),
    jsonb_build_object(p_device_type, 1)
  )
  ON CONFLICT (forum_id, date) DO UPDATE SET
    views_count = forum_post_analytics.views_count + 1,
    referrer_sources = forum_post_analytics.referrer_sources || 
      jsonb_build_object(
        v_referrer_key, 
        COALESCE((forum_post_analytics.referrer_sources->>v_referrer_key)::INTEGER, 0) + 1
      ),
    device_breakdown = forum_post_analytics.device_breakdown ||
      jsonb_build_object(
        p_device_type,
        COALESCE((forum_post_analytics.device_breakdown->>p_device_type)::INTEGER, 0) + 1
      ),
    avg_read_time_seconds = (
      forum_post_analytics.avg_read_time_seconds * forum_post_analytics.views_count + p_time_spent_seconds
    ) / (forum_post_analytics.views_count + 1);
  
  -- Update post views count
  UPDATE forum
  SET views_count = COALESCE(views_count, 0) + 1
  WHERE id = p_forum_id;
END;
$$;


--
-- Name: record_provider_failure(text, text, jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.record_provider_failure(p_provider text, p_error_message text, p_metadata jsonb DEFAULT NULL::jsonb) RETURNS void
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO ''
    AS $$
DECLARE
  v_current_state TEXT;
  v_failures INTEGER;
BEGIN
  SELECT state, failures INTO v_current_state, v_failures
  FROM email_circuit_breaker_state
  WHERE provider = p_provider;

  UPDATE email_circuit_breaker_state
  SET
    failures = failures + 1,
    last_failure_time = NOW(),
    consecutive_successes = 0,
    updated_at = NOW()
  WHERE provider = p_provider;

  PERFORM record_circuit_event(
    p_provider,
    'provider_failure',
    p_error_message,
    'warning',
    p_metadata
  );

  IF v_failures + 1 >= 5 AND v_current_state = 'closed' THEN
    PERFORM update_circuit_breaker_state(
      p_provider,
      'open',
      NULL,
      0,
      NOW(),
      NOW() + INTERVAL '1 minute'
    );

    PERFORM record_circuit_event(
      p_provider,
      'circuit_opened',
      format('Circuit breaker opened for %s after %s failures', p_provider, v_failures + 1),
      'error',
      jsonb_build_object('failures', v_failures + 1)
    );
  END IF;
END;
$$;


--
-- Name: record_provider_metrics(text, boolean, numeric, text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.record_provider_metrics(p_provider text, p_success boolean, p_latency_ms numeric, p_error text DEFAULT NULL::text) RETURNS void
    LANGUAGE plpgsql
    SET search_path TO ''
    AS $$
DECLARE
  v_current_metrics RECORD;
  v_new_total INTEGER;
  v_new_success INTEGER;
  v_new_failed INTEGER;
  v_new_avg_latency DECIMAL;
  v_success_rate DECIMAL;
  v_new_consecutive_failures INTEGER;
  v_new_health_score INTEGER;
BEGIN
  -- Get or create current metrics
  SELECT * INTO v_current_metrics
  FROM email_provider_health_metrics
  WHERE provider = p_provider;
  
  IF NOT FOUND THEN
    -- Initialize new provider metrics
    INSERT INTO email_provider_health_metrics (
      provider,
      total_requests,
      successful_requests,
      failed_requests,
      average_latency_ms,
      health_score,
      consecutive_failures,
      last_error,
      last_error_at
    ) VALUES (
      p_provider,
      1,
      CASE WHEN p_success THEN 1 ELSE 0 END,
      CASE WHEN p_success THEN 0 ELSE 1 END,
      p_latency_ms,
      CASE WHEN p_success THEN 100 ELSE 90 END,
      CASE WHEN p_success THEN 0 ELSE 1 END,
      p_error,
      CASE WHEN NOT p_success THEN NOW() ELSE NULL END
    );
    RETURN;
  END IF;
  
  -- Calculate new metrics
  v_new_total := v_current_metrics.total_requests + 1;
  v_new_success := v_current_metrics.successful_requests + (CASE WHEN p_success THEN 1 ELSE 0 END);
  v_new_failed := v_current_metrics.failed_requests + (CASE WHEN p_success THEN 0 ELSE 1 END);
  
  -- Rolling average latency
  v_new_avg_latency := (
    (v_current_metrics.average_latency_ms * v_current_metrics.total_requests) + p_latency_ms
  ) / v_new_total;
  
  -- Success rate
  v_success_rate := (v_new_success::DECIMAL / v_new_total) * 100;
  
  -- Consecutive failures
  IF p_success THEN
    v_new_consecutive_failures := 0;
  ELSE
    v_new_consecutive_failures := v_current_metrics.consecutive_failures + 1;
  END IF;
  
  -- Calculate new health score
  v_new_health_score := calculate_provider_health_score(
    v_success_rate,
    v_new_avg_latency,
    v_new_consecutive_failures
  );
  
  -- Update metrics
  UPDATE email_provider_health_metrics
  SET
    total_requests = v_new_total,
    successful_requests = v_new_success,
    failed_requests = v_new_failed,
    average_latency_ms = v_new_avg_latency,
    health_score = v_new_health_score,
    consecutive_failures = v_new_consecutive_failures,
    last_error = CASE WHEN NOT p_success THEN p_error ELSE last_error END,
    last_error_at = CASE WHEN NOT p_success THEN NOW() ELSE last_error_at END,
    last_updated = NOW()
  WHERE provider = p_provider;
END;
$$;


--
-- Name: FUNCTION record_provider_metrics(p_provider text, p_success boolean, p_latency_ms numeric, p_error text); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.record_provider_metrics(p_provider text, p_success boolean, p_latency_ms numeric, p_error text) IS 'Records email send metrics and updates health score';


--
-- Name: record_provider_success(text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.record_provider_success(p_provider text) RETURNS void
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO ''
    AS $$
DECLARE
  v_current_state TEXT;
  v_consecutive_successes INTEGER;
BEGIN
  SELECT state, consecutive_successes INTO v_current_state, v_consecutive_successes
  FROM email_circuit_breaker_state
  WHERE provider = p_provider;

  UPDATE email_circuit_breaker_state
  SET
    failures = 0,
    consecutive_successes = consecutive_successes + 1,
    updated_at = NOW()
  WHERE provider = p_provider;

  IF v_current_state = 'half-open' AND v_consecutive_successes + 1 >= 3 THEN
    PERFORM update_circuit_breaker_state(
      p_provider,
      'closed',
      0,
      0,
      NULL,
      NULL
    );

    PERFORM record_circuit_event(
      p_provider,
      'circuit_closed',
      format('Circuit breaker closed for %s after successful recovery', p_provider),
      'info',
      jsonb_build_object('consecutive_successes', v_consecutive_successes + 1)
    );
  END IF;
END;
$$;


--
-- Name: record_request(text, text, integer, text, text, boolean, integer, text, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.record_request(p_endpoint text, p_method text, p_response_time_ms integer, p_app_platform text, p_app_version text, p_cache_hit boolean DEFAULT false, p_status_code integer DEFAULT NULL::integer, p_error_type text DEFAULT NULL::text, p_request_size integer DEFAULT NULL::integer, p_response_size integer DEFAULT NULL::integer) RETURNS void
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public', 'pg_temp'
    AS $$
BEGIN
    INSERT INTO metrics.api_requests (
        endpoint, method, response_time_ms, app_platform, app_version,
        cache_hit, status_code, error_type, request_size_bytes, response_size_bytes
    ) VALUES (
        p_endpoint, p_method, p_response_time_ms, p_app_platform, p_app_version,
        p_cache_hit, p_status_code, p_error_type, p_request_size, p_response_size
    );
END;
$$;


--
-- Name: FUNCTION record_request(p_endpoint text, p_method text, p_response_time_ms integer, p_app_platform text, p_app_version text, p_cache_hit boolean, p_status_code integer, p_error_type text, p_request_size integer, p_response_size integer); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.record_request(p_endpoint text, p_method text, p_response_time_ms integer, p_app_platform text, p_app_version text, p_cache_hit boolean, p_status_code integer, p_error_type text, p_request_size integer, p_response_size integer) IS 'Records an API request metric from client apps';


--
-- Name: refresh_analytics_staging(); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.refresh_analytics_staging()
    LANGUAGE plpgsql
    AS $$
BEGIN
    -- Refresh users staging
    INSERT INTO analytics_staging_users 
    SELECT id, nickname, email, avatar_url, bio, is_active, is_verified, 
           last_seen_at, created_at, updated_at, false
    FROM analytics_full_users
    ON CONFLICT (id) DO UPDATE SET
        nickname = EXCLUDED.nickname,
        email = EXCLUDED.email,
        is_active = EXCLUDED.is_active,
        last_seen_at = EXCLUDED.last_seen_at,
        updated_at = EXCLUDED.updated_at,
        synced_to_motherduck = false;
    
    -- Refresh listings staging
    INSERT INTO analytics_staging_listings
    SELECT id, profile_id, post_name, post_description, post_type, post_address,
           latitude, longitude, is_active, is_arranged, post_arranged_to, 
           post_arranged_at, post_views, post_like_counter, created_at, updated_at, false
    FROM analytics_full_listings
    ON CONFLICT (id) DO UPDATE SET
        post_name = EXCLUDED.post_name,
        is_active = EXCLUDED.is_active,
        is_arranged = EXCLUDED.is_arranged,
        post_views = EXCLUDED.post_views,
        updated_at = EXCLUDED.updated_at,
        synced_to_motherduck = false;
    
    -- Refresh rooms staging
    INSERT INTO analytics_staging_rooms
    SELECT id, post_id, sharer_id, requester_id, 
           last_message_at, created_at, updated_at, false
    FROM analytics_full_rooms
    ON CONFLICT (id) DO UPDATE SET
        last_message_at = EXCLUDED.last_message_at,
        updated_at = EXCLUDED.updated_at,
        synced_to_motherduck = false;
    
    -- Refresh reviews staging
    INSERT INTO analytics_staging_reviews
    SELECT id, reviewer_id, post_id, rating, review_type,
           created_at, updated_at, false
    FROM analytics_full_reviews
    ON CONFLICT (id) DO UPDATE SET
        rating = EXCLUDED.rating,
        updated_at = EXCLUDED.updated_at,
        synced_to_motherduck = false;
    
    -- Refresh favorites staging
    INSERT INTO analytics_staging_favorites
    SELECT id, user_id, post_id, created_at, false
    FROM analytics_full_favorites
    ON CONFLICT (id) DO UPDATE SET
        synced_to_motherduck = false;
    
    RAISE NOTICE 'Analytics staging tables refreshed successfully';
END;
$$;


--
-- Name: refresh_user_email_health(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.refresh_user_email_health() RETURNS void
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
BEGIN
  REFRESH MATERIALIZED VIEW CONCURRENTLY user_email_health;
END;
$$;


--
-- Name: FUNCTION refresh_user_email_health(); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.refresh_user_email_health() IS 'Refreshes user email health stats (call daily via cron)';


--
-- Name: refresh_user_stats_mv(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.refresh_user_stats_mv() RETURNS void
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
BEGIN
  REFRESH MATERIALIZED VIEW CONCURRENTLY public.mv_user_stats;
END;
$$;


--
-- Name: FUNCTION refresh_user_stats_mv(); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.refresh_user_stats_mv() IS 'Refreshes mv_user_stats concurrently without blocking reads';


--
-- Name: reorder_series_posts(uuid, jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.reorder_series_posts(p_series_id uuid, p_post_orders jsonb) RETURNS boolean
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
DECLARE
  v_series_owner UUID;
  v_item JSONB;
BEGIN
  -- Verify ownership
  SELECT profile_id INTO v_series_owner FROM forum_series WHERE id = p_series_id;
  
  IF v_series_owner != auth.uid() THEN
    RAISE EXCEPTION 'Only the series owner can reorder posts';
  END IF;
  
  -- Update each post's order
  FOR v_item IN SELECT * FROM jsonb_array_elements(p_post_orders)
  LOOP
    UPDATE forum_series_posts
    SET sort_order = (v_item->>'sort_order')::INTEGER
    WHERE series_id = p_series_id
    AND forum_id = (v_item->>'forum_id')::BIGINT;
    
    UPDATE forum
    SET series_order = (v_item->>'sort_order')::INTEGER
    WHERE id = (v_item->>'forum_id')::BIGINT;
  END LOOP;
  
  UPDATE forum_series SET updated_at = now() WHERE id = p_series_id;
  
  RETURN true;
END;
$$;


--
-- Name: request_item(bigint, uuid, text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.request_item(p_post_id bigint, p_requester_id uuid, p_message text DEFAULT NULL::text) RETURNS jsonb
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
DECLARE
  v_room_id UUID;
  v_sharer_id UUID;
  v_post_name TEXT;
  v_requester_name TEXT;
  v_existing_room_id UUID;
BEGIN
  -- Get post info
  SELECT profile_id, post_name INTO v_sharer_id, v_post_name
  FROM posts
  WHERE id = p_post_id AND is_active = TRUE AND is_arranged = FALSE;

  IF v_sharer_id IS NULL THEN
    RETURN jsonb_build_object('success', FALSE, 'error', 'Post not available');
  END IF;

  -- Can't request own item
  IF v_sharer_id = p_requester_id THEN
    RETURN jsonb_build_object('success', FALSE, 'error', 'Cannot request your own item');
  END IF;

  -- Check for existing room
  SELECT id INTO v_existing_room_id
  FROM rooms
  WHERE post_id = p_post_id AND requester = p_requester_id;

  IF v_existing_room_id IS NOT NULL THEN
    RETURN jsonb_build_object(
      'success', TRUE,
      'room_id', v_existing_room_id,
      'is_new', FALSE
    );
  END IF;

  -- Create new room
  v_room_id := gen_random_uuid();
  INSERT INTO rooms (id, post_id, sharer, requester)
  VALUES (v_room_id, p_post_id, v_sharer_id, p_requester_id);

  -- Get requester name
  SELECT nickname INTO v_requester_name FROM profiles WHERE id = p_requester_id;

  -- Send initial message if provided
  IF p_message IS NOT NULL AND p_message != '' THEN
    INSERT INTO room_participants (id, room_id, profile_id, text, timestamp)
    VALUES (gen_random_uuid(), v_room_id, p_requester_id, p_message, NOW());

    UPDATE rooms SET 
      last_message = p_message,
      last_message_time = NOW(),
      last_message_sent_by = p_requester_id
    WHERE id = v_room_id;
  END IF;

  -- Notification is handled by trigger (notify_new_interest)

  RETURN jsonb_build_object(
    'success', TRUE,
    'room_id', v_room_id,
    'is_new', TRUE,
    'sharer_id', v_sharer_id
  );
END;
$$;


--
-- Name: requires_mfa(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.requires_mfa(p_profile_id uuid) RETURNS boolean
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO ''
    AS $$
DECLARE
  v_is_admin BOOLEAN;
  v_mfa_enabled BOOLEAN;
BEGIN
  -- Check if user has admin role via user_roles table
  SELECT EXISTS (
    SELECT 1 
    FROM public.user_roles ur
    JOIN public.roles r ON ur.role_id = r.id
    WHERE ur.profile_id = p_profile_id
    AND r.name IN ('admin', 'superadmin', 'super_admin')
  ) INTO v_is_admin;
  
  SELECT is_mfa_enabled INTO v_mfa_enabled 
  FROM public.mfa_configuration 
  WHERE profile_id = p_profile_id;
  
  -- Admins always require MFA
  IF v_is_admin THEN
    RETURN TRUE;
  END IF;
  
  RETURN COALESCE(v_mfa_enabled, FALSE);
END;
$$;


--
-- Name: reset_circuit_breaker(text, uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.reset_circuit_breaker(p_provider text, p_organization_id uuid DEFAULT NULL::uuid) RETURNS void
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO ''
    AS $$
DECLARE 
  v_admin_id UUID; 
  v_user_role TEXT;
BEGIN
  v_admin_id := auth.uid();
  
  -- Get user's role from user_roles table
  SELECT r.name INTO v_user_role
  FROM public.user_roles ur
  JOIN public.roles r ON ur.role_id = r.id
  WHERE ur.profile_id = v_admin_id
  AND r.name IN ('admin', 'superadmin', 'super_admin')
  LIMIT 1;
  
  IF v_user_role IS NULL THEN 
    RAISE EXCEPTION 'Unauthorized: Admin access required'; 
  END IF;
  
  UPDATE public.email_circuit_breaker_state 
  SET state = 'closed', 
      failures = 0, 
      consecutive_successes = 0, 
      last_failure_time = NULL, 
      next_retry_time = NULL, 
      updated_at = NOW() 
  WHERE provider = p_provider 
    AND (p_organization_id IS NULL OR organization_id = p_organization_id);
  
  INSERT INTO public.admin_audit_log (admin_id, action, resource_type, resource_id, metadata, success) 
  VALUES (v_admin_id, 'circuit_breaker_reset', 'email_provider', p_provider, 
          jsonb_build_object('provider', p_provider, 'organization_id', p_organization_id), TRUE);
  
  PERFORM public.record_circuit_event(p_provider, 'manual_reset', 
          format('Circuit breaker manually reset for %s by admin %s', p_provider, v_admin_id), 
          'info', jsonb_build_object('admin_id', v_admin_id));
END;
$$;


--
-- Name: reset_daily_email_quotas(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.reset_daily_email_quotas() RETURNS void
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
BEGIN
  UPDATE email_provider_health_metrics
  SET
    daily_quota_used = 0,
    last_updated = now();

  UPDATE email_provider_stats
  SET
    emails_sent = 0,
    requests_total = 0,
    requests_success = 0,
    requests_failed = 0,
    updated_at = now()
  WHERE date < CURRENT_DATE;
END;
$$;


--
-- Name: FUNCTION reset_daily_email_quotas(); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.reset_daily_email_quotas() IS 'Resets daily quota counters, should be called at midnight via cron';


--
-- Name: reset_forum_user_rate_limit(uuid, text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.reset_forum_user_rate_limit(p_profile_id uuid, p_action_type text DEFAULT NULL::text) RETURNS boolean
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
BEGIN
  IF p_action_type IS NOT NULL THEN
    DELETE FROM forum_rate_limits
    WHERE profile_id = p_profile_id
      AND action_type = p_action_type;
  ELSE
    DELETE FROM forum_rate_limits
    WHERE profile_id = p_profile_id;
  END IF;
  
  RETURN TRUE;
END;
$$;


--
-- Name: resolve_forum_report(uuid, text, text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.resolve_forum_report(p_report_id uuid, p_status text, p_notes text DEFAULT NULL::text) RETURNS boolean
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
DECLARE
  v_moderator_id UUID := auth.uid();
BEGIN
  -- Update the report
  UPDATE public.forum_reports
  SET 
    status = p_status,
    moderator_id = v_moderator_id,
    moderator_notes = p_notes,
    resolved_at = CASE WHEN p_status LIKE 'resolved_%' OR p_status = 'dismissed' THEN now() ELSE NULL END
  WHERE id = p_report_id;
  
  RETURN FOUND;
END;
$$;


--
-- Name: resolve_queue_item(uuid, text, text, boolean, text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.resolve_queue_item(p_queue_id uuid, p_resolution text, p_notes text DEFAULT NULL::text, p_issue_warning boolean DEFAULT false, p_warning_type text DEFAULT NULL::text) RETURNS boolean
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
DECLARE
  v_queue forum_moderation_queue%ROWTYPE;
  v_target_profile_id UUID;
BEGIN
  SELECT * INTO v_queue FROM forum_moderation_queue WHERE id = p_queue_id;
  IF NOT FOUND THEN RETURN false; END IF;
  
  -- Determine target profile
  IF v_queue.forum_id IS NOT NULL THEN
    SELECT profile_id INTO v_target_profile_id FROM forum WHERE id = v_queue.forum_id;
  ELSIF v_queue.comment_id IS NOT NULL THEN
    SELECT user_id INTO v_target_profile_id FROM comments WHERE id = v_queue.comment_id;
  ELSIF v_queue.message_id IS NOT NULL THEN
    SELECT sender_id INTO v_target_profile_id FROM forum_messages WHERE id = v_queue.message_id;
  ELSE
    v_target_profile_id := v_queue.profile_id;
  END IF;
  
  -- Take action based on resolution
  IF p_resolution = 'removed' THEN
    IF v_queue.forum_id IS NOT NULL THEN
      UPDATE forum SET forum_published = false WHERE id = v_queue.forum_id;
    ELSIF v_queue.comment_id IS NOT NULL THEN
      UPDATE comments SET comment = '[Removed by moderator]' WHERE id = v_queue.comment_id;
    ELSIF v_queue.message_id IS NOT NULL THEN
      UPDATE forum_messages SET is_deleted = true, deleted_at = now() WHERE id = v_queue.message_id;
    END IF;
  END IF;
  
  -- Issue warning if requested
  IF p_issue_warning AND v_target_profile_id IS NOT NULL AND p_warning_type IS NOT NULL THEN
    INSERT INTO forum_user_warnings (profile_id, moderator_id, queue_id, warning_type, reason)
    VALUES (v_target_profile_id, auth.uid(), p_queue_id, p_warning_type, COALESCE(p_notes, 'Content violation'));
    
    PERFORM award_reputation(v_target_profile_id, 'warning_received', auth.uid(), v_queue.forum_id, v_queue.comment_id);
  END IF;
  
  -- Update queue item
  UPDATE forum_moderation_queue
  SET status = 'resolved', resolved_by = auth.uid(), resolved_at = now(),
      resolution = p_resolution, resolution_notes = p_notes, updated_at = now()
  WHERE id = p_queue_id;
  
  -- Update moderator stats
  INSERT INTO forum_moderation_stats (moderator_id, date, items_reviewed, items_approved, items_removed, warnings_issued)
  VALUES (auth.uid(), CURRENT_DATE, 1, 
    CASE WHEN p_resolution = 'approved' THEN 1 ELSE 0 END,
    CASE WHEN p_resolution = 'removed' THEN 1 ELSE 0 END,
    CASE WHEN p_issue_warning THEN 1 ELSE 0 END
  )
  ON CONFLICT (moderator_id, date) DO UPDATE SET
    items_reviewed = forum_moderation_stats.items_reviewed + 1,
    items_approved = forum_moderation_stats.items_approved + CASE WHEN p_resolution = 'approved' THEN 1 ELSE 0 END,
    items_removed = forum_moderation_stats.items_removed + CASE WHEN p_resolution = 'removed' THEN 1 ELSE 0 END,
    warnings_issued = forum_moderation_stats.warnings_issued + CASE WHEN p_issue_warning THEN 1 ELSE 0 END;
  
  -- Update original report if exists
  IF v_queue.report_id IS NOT NULL THEN
    UPDATE forum_reports SET status = 'resolved', resolved_at = now(), moderator_id = auth.uid() WHERE id = v_queue.report_id;
  END IF;
  
  RETURN true;
END;
$$;


--
-- Name: retry_dlq_email(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.retry_dlq_email(p_dlq_id uuid) RETURNS uuid
    LANGUAGE plpgsql
    SET search_path TO ''
    AS $$
DECLARE
  v_new_queue_id UUID;
  v_dlq_record RECORD;
BEGIN
  -- Get DLQ record
  SELECT * INTO v_dlq_record
  FROM email_dead_letter_queue
  WHERE id = p_dlq_id;
  
  IF NOT FOUND THEN
    RAISE EXCEPTION 'DLQ record not found: %', p_dlq_id;
  END IF;
  
  -- Insert back into queue with reset attempts
  INSERT INTO email_queue (
    recipient_id,
    recipient_email,
    email_type,
    template_name,
    template_data,
    attempts,
    max_attempts,
    status,
    next_retry_at
  ) VALUES (
    v_dlq_record.recipient_id,
    v_dlq_record.recipient_email,
    v_dlq_record.email_type,
    v_dlq_record.template_name,
    v_dlq_record.template_data,
    0,
    3,
    'queued',
    NOW()
  )
  RETURNING id INTO v_new_queue_id;
  
  -- Mark DLQ record as retried (don't delete to maintain audit trail)
  UPDATE email_dead_letter_queue 
  SET metadata = jsonb_set(
    COALESCE(metadata, '{}'::jsonb),
    '{retried_at}',
    to_jsonb(NOW())
  )
  WHERE id = p_dlq_id;
  
  RETURN v_new_queue_id;
END;
$$;


--
-- Name: FUNCTION retry_dlq_email(p_dlq_id uuid); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.retry_dlq_email(p_dlq_id uuid) IS 'Requeues an email from dead letter queue for retry';


--
-- Name: retry_queued_email(uuid, text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.retry_queued_email(p_queue_id uuid, p_error_message text) RETURNS boolean
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO ''
    AS $$
DECLARE
  v_attempts INTEGER;
  v_max_attempts INTEGER;
  v_next_retry TIMESTAMP WITH TIME ZONE;
BEGIN
  SELECT attempts, max_attempts
  INTO v_attempts, v_max_attempts
  FROM public.email_queue
  WHERE id = p_queue_id;

  IF NOT FOUND THEN
    RETURN false;
  END IF;

  v_attempts := v_attempts + 1;

  IF v_attempts = 1 THEN
    v_next_retry := now() + INTERVAL '15 minutes';
  ELSIF v_attempts = 2 THEN
    v_next_retry := now() + INTERVAL '30 minutes';
  ELSE
    v_next_retry := now() + INTERVAL '1 hour';
  END IF;

  IF v_attempts >= v_max_attempts THEN
    UPDATE public.email_queue
    SET
      attempts = v_attempts,
      status = 'failed',
      last_error = p_error_message,
      next_retry_at = NULL,
      updated_at = now()
    WHERE id = p_queue_id;
  ELSE
    UPDATE public.email_queue
    SET
      attempts = v_attempts,
      status = 'queued',
      last_error = p_error_message,
      next_retry_at = v_next_retry,
      updated_at = now()
    WHERE id = p_queue_id;
  END IF;

  RETURN true;
END;
$$;


--
-- Name: rollup_hourly_stats(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.rollup_hourly_stats() RETURNS void
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public', 'pg_temp'
    AS $$
DECLARE
    v_hour TIMESTAMPTZ;
BEGIN
    v_hour := date_trunc('hour', now() - interval '1 hour');

    INSERT INTO metrics.api_hourly_stats (
        hour, endpoint, platform, request_count, error_count, p50_ms, p95_ms, p99_ms
    )
    SELECT
        v_hour, endpoint, COALESCE(app_platform, 'unknown') as platform,
        COUNT(*) as request_count,
        COUNT(*) FILTER (WHERE status_code >= 400 OR status_code IS NULL) as error_count,
        PERCENTILE_CONT(0.50) WITHIN GROUP (ORDER BY response_time_ms)::INT as p50_ms,
        PERCENTILE_CONT(0.95) WITHIN GROUP (ORDER BY response_time_ms)::INT as p95_ms,
        PERCENTILE_CONT(0.99) WITHIN GROUP (ORDER BY response_time_ms)::INT as p99_ms
    FROM metrics.api_requests
    WHERE created_at >= v_hour AND created_at < v_hour + interval '1 hour'
    GROUP BY endpoint, COALESCE(app_platform, 'unknown')
    ON CONFLICT (hour, endpoint, platform)
    DO UPDATE SET
        request_count = EXCLUDED.request_count, error_count = EXCLUDED.error_count,
        p50_ms = EXCLUDED.p50_ms, p95_ms = EXCLUDED.p95_ms, p99_ms = EXCLUDED.p99_ms;
END;
$$;


--
-- Name: FUNCTION rollup_hourly_stats(); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.rollup_hourly_stats() IS 'Aggregates raw API metrics into hourly stats';


--
-- Name: save_forum_draft(uuid, text, text, jsonb, integer, text, integer[], text, jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.save_forum_draft(p_draft_id uuid DEFAULT NULL::uuid, p_title text DEFAULT NULL::text, p_description text DEFAULT NULL::text, p_rich_content jsonb DEFAULT NULL::jsonb, p_category_id integer DEFAULT NULL::integer, p_post_type text DEFAULT 'discussion'::text, p_tags integer[] DEFAULT NULL::integer[], p_image_url text DEFAULT NULL::text, p_poll_data jsonb DEFAULT NULL::jsonb) RETURNS jsonb
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
DECLARE
  v_user_id UUID := auth.uid();
  v_draft_id UUID;
BEGIN
  IF v_user_id IS NULL THEN
    RAISE EXCEPTION 'Not authenticated';
  END IF;
  
  IF p_draft_id IS NOT NULL THEN
    -- Update existing draft
    UPDATE public.forum_drafts
    SET 
      title = COALESCE(p_title, title),
      description = COALESCE(p_description, description),
      rich_content = COALESCE(p_rich_content, rich_content),
      category_id = COALESCE(p_category_id, category_id),
      post_type = COALESCE(p_post_type, post_type),
      tags = COALESCE(p_tags, tags),
      image_url = COALESCE(p_image_url, image_url),
      poll_data = COALESCE(p_poll_data, poll_data),
      last_saved_at = now()
    WHERE id = p_draft_id AND profile_id = v_user_id
    RETURNING id INTO v_draft_id;
    
    IF v_draft_id IS NULL THEN
      RAISE EXCEPTION 'Draft not found or access denied';
    END IF;
  ELSE
    -- Create new draft
    INSERT INTO public.forum_drafts (
      profile_id, title, description, rich_content, category_id, 
      post_type, tags, image_url, poll_data
    ) VALUES (
      v_user_id, p_title, p_description, p_rich_content, p_category_id,
      p_post_type, p_tags, p_image_url, p_poll_data
    )
    RETURNING id INTO v_draft_id;
  END IF;
  
  RETURN jsonb_build_object(
    'draft_id', v_draft_id,
    'saved_at', now()
  );
END;
$$;


--
-- Name: save_forum_search(text, text, jsonb, boolean); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.save_forum_search(p_name text, p_query text, p_filters jsonb DEFAULT '{}'::jsonb, p_notify_on_new boolean DEFAULT false) RETURNS uuid
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
DECLARE
  v_search_id UUID;
  v_count INTEGER;
BEGIN
  -- Limit to 20 saved searches per user
  SELECT COUNT(*) INTO v_count FROM forum_saved_searches WHERE profile_id = auth.uid();
  
  IF v_count >= 20 THEN
    RAISE EXCEPTION 'Maximum of 20 saved searches allowed';
  END IF;
  
  INSERT INTO forum_saved_searches (profile_id, name, query, filters, notify_on_new)
  VALUES (auth.uid(), p_name, lower(trim(p_query)), p_filters, p_notify_on_new)
  RETURNING id INTO v_search_id;
  
  RETURN v_search_id;
END;
$$;


--
-- Name: schedule_post(text, text, timestamp with time zone, integer, text, integer[], jsonb, text, jsonb, uuid, boolean, text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.schedule_post(p_title text, p_description text, p_scheduled_for timestamp with time zone, p_category_id integer DEFAULT NULL::integer, p_post_type text DEFAULT 'discussion'::text, p_tags integer[] DEFAULT NULL::integer[], p_rich_content jsonb DEFAULT NULL::jsonb, p_image_url text DEFAULT NULL::text, p_poll_data jsonb DEFAULT NULL::jsonb, p_series_id uuid DEFAULT NULL::uuid, p_notify_followers boolean DEFAULT true, p_timezone text DEFAULT 'UTC'::text) RETURNS uuid
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
DECLARE
  v_scheduled_id UUID;
  v_queue_id UUID;
BEGIN
  -- Validate scheduled time is in the future
  IF p_scheduled_for <= now() THEN
    RAISE EXCEPTION 'Scheduled time must be in the future';
  END IF;
  
  -- Create scheduled post
  INSERT INTO forum_scheduled_posts (
    profile_id, title, description, scheduled_for, category_id, 
    post_type, tags, rich_content, image_url, poll_data,
    series_id, notify_followers, timezone
  ) VALUES (
    auth.uid(), p_title, p_description, p_scheduled_for, p_category_id,
    p_post_type, p_tags, p_rich_content, p_image_url, p_poll_data,
    p_series_id, p_notify_followers, p_timezone
  )
  RETURNING id INTO v_scheduled_id;
  
  -- Add to publication queue
  INSERT INTO forum_publication_queue (scheduled_post_id, scheduled_for)
  VALUES (v_scheduled_id, p_scheduled_for)
  RETURNING id INTO v_queue_id;
  
  RETURN v_scheduled_id;
END;
$$;


--
-- Name: scheduled_update_locations(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.scheduled_update_locations() RETURNS void
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
BEGIN
  PERFORM public.process_location_update_queue();
END;
$$;


--
-- Name: search_all_functions(text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.search_all_functions(search_string text) RETURNS TABLE(proname text, prosrc text, is_trigger boolean)
    LANGUAGE plpgsql STABLE
    SET search_path TO 'public', 'pg_catalog'
    AS $$
BEGIN
  RETURN QUERY
  SELECT 
    p.proname::text,
    p.prosrc::text,
    (p.prorettype = 'trigger'::regtype)::boolean as is_trigger
  FROM pg_proc p
  JOIN pg_namespace n ON p.pronamespace = n.oid
  WHERE (p.proname::text ILIKE '%' || search_string || '%'
    OR p.prosrc::text ILIKE '%' || search_string || '%');
END;
$$;


--
-- Name: search_food_items(double precision, double precision, double precision, text, integer, text, boolean, boolean, text, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.search_food_items(p_latitude double precision, p_longitude double precision, p_radius_km double precision DEFAULT 25, p_search_query text DEFAULT NULL::text, p_category_id integer DEFAULT NULL::integer, p_post_type text DEFAULT NULL::text, p_available_only boolean DEFAULT false, p_arranged_only boolean DEFAULT false, p_sort_by text DEFAULT 'distance'::text, p_limit integer DEFAULT 20, p_offset integer DEFAULT 0) RETURNS jsonb
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
DECLARE
  v_user_location extensions.geography;
  v_result JSONB;
  v_items JSONB;
  v_total_count INTEGER;
  v_category_breakdown JSONB;
BEGIN
  -- Build user location point
  v_user_location := extensions.ST_SetSRID(extensions.ST_MakePoint(p_longitude, p_latitude), 4326)::extensions.geography;

  -- Get filtered and sorted items
  WITH filtered_posts AS (
    SELECT
      p.id,
      p.profile_id,
      p.post_name,
      p.post_description,
      p.post_type,
      p.images,
      p.is_active,
      p.is_arranged,
      p.post_views,
      p.post_like_counter,
      p.latitude,
      p.longitude,
      p.post_address,
      p.post_stripped_address,
      p.pickup_time,
      p.created_at,
      p.category_id,
      extensions.ST_Distance(
        v_user_location,
        extensions.ST_SetSRID(extensions.ST_MakePoint(p.longitude, p.latitude), 4326)::extensions.geography
      ) / 1000.0 AS distance_km
    FROM posts p
    WHERE
      -- Active filter
      p.is_active = TRUE
      -- Radius filter
      AND extensions.ST_DWithin(
        v_user_location,
        extensions.ST_SetSRID(extensions.ST_MakePoint(p.longitude, p.latitude), 4326)::extensions.geography,
        p_radius_km * 1000
      )
      -- Text search (case-insensitive)
      AND (
        p_search_query IS NULL
        OR p_search_query = ''
        OR p.post_name ILIKE '%' || p_search_query || '%'
        OR p.post_description ILIKE '%' || p_search_query || '%'
        OR p.post_address ILIKE '%' || p_search_query || '%'
      )
      -- Category filter
      AND (p_category_id IS NULL OR p.category_id = p_category_id)
      -- Post type filter
      AND (p_post_type IS NULL OR p.post_type = p_post_type)
      -- Available only filter
      AND (NOT p_available_only OR p.is_arranged = FALSE)
      -- Arranged only filter
      AND (NOT p_arranged_only OR p.is_arranged = TRUE)
  ),
  sorted_posts AS (
    SELECT *
    FROM filtered_posts
    ORDER BY
      CASE WHEN p_sort_by = 'distance' THEN distance_km END ASC NULLS LAST,
      CASE WHEN p_sort_by = 'newest' THEN created_at END DESC NULLS LAST,
      CASE WHEN p_sort_by = 'oldest' THEN created_at END ASC NULLS LAST,
      CASE WHEN p_sort_by = 'expiring_soon' THEN created_at END ASC NULLS LAST,
      CASE WHEN p_sort_by = 'popular' THEN post_views END DESC NULLS LAST
  ),
  paginated_posts AS (
    SELECT *
    FROM sorted_posts
    LIMIT p_limit
    OFFSET p_offset
  )
  SELECT
    COALESCE(jsonb_agg(
      jsonb_build_object(
        'id', pp.id,
        'profile_id', pp.profile_id,
        'post_name', pp.post_name,
        'post_description', pp.post_description,
        'post_type', pp.post_type,
        'images', pp.images,
        'is_active', pp.is_active,
        'is_arranged', pp.is_arranged,
        'post_views', pp.post_views,
        'post_like_counter', pp.post_like_counter,
        'latitude', pp.latitude,
        'longitude', pp.longitude,
        'post_address', pp.post_address,
        'post_stripped_address', pp.post_stripped_address,
        'pickup_time', pp.pickup_time,
        'created_at', pp.created_at,
        'category_id', pp.category_id,
        'distance_km', ROUND(pp.distance_km::numeric, 2)
      )
    ), '[]'::jsonb)
  INTO v_items
  FROM paginated_posts pp;

  -- Get total count (for pagination)
  WITH filtered_posts AS (
    SELECT p.id, p.post_type
    FROM posts p
    WHERE
      p.is_active = TRUE
      AND extensions.ST_DWithin(
        v_user_location,
        extensions.ST_SetSRID(extensions.ST_MakePoint(p.longitude, p.latitude), 4326)::extensions.geography,
        p_radius_km * 1000
      )
      AND (
        p_search_query IS NULL
        OR p_search_query = ''
        OR p.post_name ILIKE '%' || p_search_query || '%'
        OR p.post_description ILIKE '%' || p_search_query || '%'
        OR p.post_address ILIKE '%' || p_search_query || '%'
      )
      AND (p_category_id IS NULL OR p.category_id = p_category_id)
      AND (p_post_type IS NULL OR p.post_type = p_post_type)
      AND (NOT p_available_only OR p.is_arranged = FALSE)
      AND (NOT p_arranged_only OR p.is_arranged = TRUE)
  )
  SELECT COUNT(*)::INTEGER INTO v_total_count FROM filtered_posts;

  -- Get category breakdown
  WITH filtered_posts AS (
    SELECT p.post_type
    FROM posts p
    WHERE
      p.is_active = TRUE
      AND extensions.ST_DWithin(
        v_user_location,
        extensions.ST_SetSRID(extensions.ST_MakePoint(p.longitude, p.latitude), 4326)::extensions.geography,
        p_radius_km * 1000
      )
      AND (
        p_search_query IS NULL
        OR p_search_query = ''
        OR p.post_name ILIKE '%' || p_search_query || '%'
        OR p.post_description ILIKE '%' || p_search_query || '%'
        OR p.post_address ILIKE '%' || p_search_query || '%'
      )
      AND (p_category_id IS NULL OR p.category_id = p_category_id)
      AND (NOT p_available_only OR p.is_arranged = FALSE)
      AND (NOT p_arranged_only OR p.is_arranged = TRUE)
  )
  SELECT COALESCE(
    jsonb_object_agg(post_type, count),
    '{}'::jsonb
  )
  INTO v_category_breakdown
  FROM (
    SELECT post_type, COUNT(*)::INTEGER as count
    FROM filtered_posts
    GROUP BY post_type
  ) breakdown;

  -- Build result
  v_result := jsonb_build_object(
    'items', v_items,
    'totalCount', v_total_count,
    'categoryBreakdown', v_category_breakdown,
    'hasMore', (p_offset + p_limit) < v_total_count
  );

  RETURN v_result;
END;
$$;


--
-- Name: search_forum(text, integer, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.search_forum(p_query text, p_category_id integer DEFAULT NULL::integer, p_limit integer DEFAULT 20, p_offset integer DEFAULT 0) RETURNS TABLE(id bigint, forum_post_name text, forum_post_description text, forum_post_image text, profile_id uuid, category_id integer, slug text, forum_likes_counter integer, forum_comments_counter numeric, views_count integer, forum_post_created_at timestamp with time zone, last_activity_at timestamp with time zone, rank real)
    LANGUAGE plpgsql STABLE
    SET search_path TO 'public'
    AS $$
BEGIN
  RETURN QUERY
  SELECT 
    f.id,
    f.forum_post_name,
    f.forum_post_description,
    f.forum_post_image,
    f.profile_id,
    f.category_id,
    f.slug,
    f.forum_likes_counter,
    f.forum_comments_counter,
    f.views_count,
    f.forum_post_created_at,
    f.last_activity_at,
    ts_rank(f.search_vector, websearch_to_tsquery('english', p_query)) AS rank
  FROM public.forum f
  WHERE 
    f.forum_published = true
    AND f.search_vector @@ websearch_to_tsquery('english', p_query)
    AND (p_category_id IS NULL OR f.category_id = p_category_id)
  ORDER BY rank DESC, f.last_activity_at DESC
  LIMIT p_limit
  OFFSET p_offset;
END;
$$;


--
-- Name: FUNCTION search_forum(p_query text, p_category_id integer, p_limit integer, p_offset integer); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.search_forum(p_query text, p_category_id integer, p_limit integer, p_offset integer) IS 'Full-text search for forum posts';


--
-- Name: search_forum(text, integer, integer[], uuid, timestamp with time zone, timestamp with time zone, text, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.search_forum(p_query text, p_category_id integer DEFAULT NULL::integer, p_tags integer[] DEFAULT NULL::integer[], p_author_id uuid DEFAULT NULL::uuid, p_date_from timestamp with time zone DEFAULT NULL::timestamp with time zone, p_date_to timestamp with time zone DEFAULT NULL::timestamp with time zone, p_sort_by text DEFAULT 'relevance'::text, p_limit integer DEFAULT 20, p_offset integer DEFAULT 0) RETURNS TABLE(forum_id bigint, title text, description text, slug text, category_id integer, category_name text, author_id uuid, author_nickname text, author_avatar text, likes_count integer, comments_count numeric, views_count integer, created_at timestamp with time zone, rank real)
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
DECLARE
  v_tsquery tsquery;
BEGIN
  -- Convert query to tsquery
  v_tsquery := plainto_tsquery('english', p_query);
  
  -- Record the search
  PERFORM record_forum_search(p_query, jsonb_build_object(
    'category_id', p_category_id,
    'tags', p_tags,
    'author_id', p_author_id,
    'date_from', p_date_from,
    'date_to', p_date_to
  ));
  
  RETURN QUERY
  SELECT 
    f.id as forum_id,
    f.forum_post_name as title,
    f.forum_post_description as description,
    f.slug,
    f.category_id,
    fc.name as category_name,
    f.profile_id as author_id,
    p.nickname as author_nickname,
    p.avatar_url as author_avatar,
    f.forum_likes_counter as likes_count,
    f.forum_comments_counter as comments_count,
    f.views_count,
    f.forum_post_created_at as created_at,
    ts_rank(f.search_vector, v_tsquery) as rank
  FROM forum f
  LEFT JOIN forum_categories fc ON f.category_id = fc.id
  LEFT JOIN profiles p ON f.profile_id = p.id
  WHERE f.forum_published = true
    AND (f.search_vector @@ v_tsquery OR f.forum_post_name ILIKE '%' || p_query || '%')
    AND (p_category_id IS NULL OR f.category_id = p_category_id)
    AND (p_author_id IS NULL OR f.profile_id = p_author_id)
    AND (p_date_from IS NULL OR f.forum_post_created_at >= p_date_from)
    AND (p_date_to IS NULL OR f.forum_post_created_at <= p_date_to)
    AND (p_tags IS NULL OR EXISTS (
      SELECT 1 FROM forum_post_tags fpt WHERE fpt.forum_id = f.id AND fpt.tag_id = ANY(p_tags)
    ))
  ORDER BY
    CASE WHEN p_sort_by = 'relevance' THEN ts_rank(f.search_vector, v_tsquery) END DESC NULLS LAST,
    CASE WHEN p_sort_by = 'newest' THEN f.forum_post_created_at END DESC,
    CASE WHEN p_sort_by = 'oldest' THEN f.forum_post_created_at END ASC,
    CASE WHEN p_sort_by = 'popular' THEN f.forum_likes_counter + f.views_count END DESC
  LIMIT p_limit
  OFFSET p_offset;
END;
$$;


--
-- Name: search_functions(text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.search_functions(search_string text) RETURNS TABLE(proname text, prosrc text, is_trigger boolean)
    LANGUAGE plpgsql STABLE
    SET search_path TO 'public', 'pg_catalog'
    AS $$
BEGIN
  RETURN QUERY
  SELECT 
    p.proname::text,
    p.prosrc::text,
    (p.prorettype = 'trigger'::regtype)::boolean as is_trigger
  FROM pg_proc p
  JOIN pg_namespace n ON p.pronamespace = n.oid
  WHERE n.nspname = 'public'
    AND (p.proname::text ILIKE '%' || search_string || '%'
      OR p.prosrc::text ILIKE '%' || search_string || '%');
END;
$$;


--
-- Name: search_trigger_functions(text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.search_trigger_functions(search_string text) RETURNS TABLE(proname text, prosrc text)
    LANGUAGE plpgsql STABLE
    SET search_path TO 'public', 'pg_catalog'
    AS $$
BEGIN
  RETURN QUERY
  SELECT 
    p.proname::text,
    p.prosrc::text
  FROM pg_proc p
  JOIN pg_namespace n ON p.pronamespace = n.oid
  WHERE n.nspname = 'public'
    AND p.prorettype = 'trigger'::regtype
    AND (p.proname::text ILIKE '%' || search_string || '%'
      OR p.prosrc::text ILIKE '%' || search_string || '%');
END;
$$;


--
-- Name: send_chat_message(uuid, uuid, text, text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.send_chat_message(p_room_id uuid, p_sender_id uuid, p_text text, p_image text DEFAULT NULL::text) RETURNS jsonb
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
DECLARE
  v_message_id UUID;
  v_is_participant BOOLEAN;
BEGIN
  -- Verify sender is participant
  SELECT EXISTS(
    SELECT 1 FROM rooms WHERE id = p_room_id AND (sharer = p_sender_id OR requester = p_sender_id)
  ) INTO v_is_participant;

  IF NOT v_is_participant THEN
    RETURN jsonb_build_object('success', FALSE, 'error', 'Not a participant');
  END IF;

  -- Create message
  v_message_id := gen_random_uuid();
  INSERT INTO room_participants (id, room_id, profile_id, text, image, timestamp)
  VALUES (v_message_id, p_room_id, p_sender_id, p_text, p_image, NOW());

  -- Update room last message
  UPDATE rooms SET
    last_message = LEFT(p_text, 100),
    last_message_time = NOW(),
    last_message_sent_by = p_sender_id,
    last_message_seen_by = NULL
  WHERE id = p_room_id;

  -- Notification handled by trigger (notify_new_room_message)

  RETURN jsonb_build_object(
    'success', TRUE,
    'message_id', v_message_id,
    'sent_at', NOW()
  );
END;
$$;


--
-- Name: send_food_listing_notification(uuid, uuid, text, numeric); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.send_food_listing_notification(p_recipient_id uuid, p_food_item_id uuid, p_food_name text, p_distance_km numeric) RETURNS boolean
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO ''
    AS $$
DECLARE
  v_recipient_email TEXT;
BEGIN
  IF NOT should_send_email_notification(p_recipient_id, 'food_listing') THEN
    RETURN false;
  END IF;

  SELECT email INTO v_recipient_email
  FROM public.profiles
  WHERE id = p_recipient_id;

  IF v_recipient_email IS NULL THEN
    RETURN false;
  END IF;

  PERFORM queue_email(
    p_recipient_id,
    v_recipient_email,
    'food_listing',
    'food-listing',
    jsonb_build_object(
      'food_item_id', p_food_item_id,
      'food_name', p_food_name,
      'distance_km', p_distance_km
    )
  );

  RETURN true;
END;
$$;


--
-- Name: FUNCTION send_food_listing_notification(p_recipient_id uuid, p_food_item_id uuid, p_food_name text, p_distance_km numeric); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.send_food_listing_notification(p_recipient_id uuid, p_food_item_id uuid, p_food_name text, p_distance_km numeric) IS 'Manually sends food listing notification to nearby users';


--
-- Name: send_message(uuid, text, text, uuid, jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.send_message(p_conversation_id uuid, p_content text, p_message_type text DEFAULT 'text'::text, p_reply_to_id uuid DEFAULT NULL::uuid, p_rich_content jsonb DEFAULT NULL::jsonb) RETURNS uuid
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
DECLARE
  v_message_id UUID;
  v_is_participant BOOLEAN;
BEGIN
  -- Check if user is a participant
  SELECT EXISTS (
    SELECT 1 FROM forum_conversation_participants
    WHERE conversation_id = p_conversation_id
      AND profile_id = auth.uid()
      AND left_at IS NULL
  ) INTO v_is_participant;
  
  IF NOT v_is_participant THEN
    RAISE EXCEPTION 'Not a participant in this conversation';
  END IF;
  
  -- Insert message
  INSERT INTO forum_messages (conversation_id, sender_id, content, message_type, reply_to_id, rich_content)
  VALUES (p_conversation_id, auth.uid(), p_content, p_message_type, p_reply_to_id, p_rich_content)
  RETURNING id INTO v_message_id;
  
  -- Update conversation
  UPDATE forum_conversations
  SET last_message_at = now(),
      last_message_preview = LEFT(p_content, 100),
      updated_at = now()
  WHERE id = p_conversation_id;
  
  -- Create notification for other participants
  INSERT INTO forum_notifications (recipient_id, type, actor_id, data)
  SELECT 
    cp.profile_id,
    'new_message',
    auth.uid(),
    jsonb_build_object(
      'conversation_id', p_conversation_id,
      'message_id', v_message_id,
      'preview', LEFT(p_content, 50)
    )
  FROM forum_conversation_participants cp
  WHERE cp.conversation_id = p_conversation_id
    AND cp.profile_id != auth.uid()
    AND cp.left_at IS NULL
    AND cp.is_muted = FALSE;
  
  RETURN v_message_id;
END;
$$;


--
-- Name: send_review_reminder(uuid, uuid, text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.send_review_reminder(p_recipient_id uuid, p_transaction_id uuid, p_other_user_name text) RETURNS boolean
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO ''
    AS $$
DECLARE
  v_recipient_email TEXT;
BEGIN
  IF NOT should_send_email_notification(p_recipient_id, 'review_reminder') THEN
    RETURN false;
  END IF;

  SELECT email INTO v_recipient_email
  FROM public.profiles
  WHERE id = p_recipient_id;

  IF v_recipient_email IS NULL THEN
    RETURN false;
  END IF;

  PERFORM queue_email(
    p_recipient_id,
    v_recipient_email,
    'review_reminder',
    'review-reminder',
    jsonb_build_object(
      'transaction_id', p_transaction_id,
      'other_user_name', p_other_user_name
    )
  );

  RETURN true;
END;
$$;


--
-- Name: FUNCTION send_review_reminder(p_recipient_id uuid, p_transaction_id uuid, p_other_user_name text); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.send_review_reminder(p_recipient_id uuid, p_transaction_id uuid, p_other_user_name text) IS 'Manually sends review reminder email to user';


--
-- Name: should_send_notification(uuid, text, text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.should_send_notification(p_user_id uuid, p_category text, p_channel text) RETURNS jsonb
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
DECLARE
  v_settings notification_settings%ROWTYPE;
  v_pref notification_preferences%ROWTYPE;
  v_result jsonb;
  v_now timestamptz := now();
  v_current_time time := v_now::time;
  v_in_quiet_hours boolean := false;
  v_quiet_end timestamptz;
BEGIN
  -- Get global settings
  SELECT * INTO v_settings
  FROM notification_settings
  WHERE user_id = p_user_id;

  -- If no settings, initialize defaults
  IF v_settings IS NULL THEN
    PERFORM init_notification_preferences(p_user_id);
    SELECT * INTO v_settings FROM notification_settings WHERE user_id = p_user_id;
  END IF;

  -- Check DND mode
  IF v_settings.dnd_enabled AND v_settings.dnd_until > v_now THEN
    RETURN jsonb_build_object(
      'send', false,
      'reason', 'dnd_active',
      'resume_at', v_settings.dnd_until
    );
  END IF;

  -- Check master channel switch
  IF p_channel = 'push' AND NOT v_settings.push_enabled THEN
    RETURN jsonb_build_object('send', false, 'reason', 'push_disabled');
  END IF;
  IF p_channel = 'email' AND NOT v_settings.email_enabled THEN
    RETURN jsonb_build_object('send', false, 'reason', 'email_disabled');
  END IF;
  IF p_channel = 'sms' AND NOT v_settings.sms_enabled THEN
    RETURN jsonb_build_object('send', false, 'reason', 'sms_disabled');
  END IF;

  -- Get category preference
  SELECT * INTO v_pref
  FROM notification_preferences
  WHERE user_id = p_user_id
    AND category = p_category::notification_category
    AND channel = p_channel::notification_channel;

  -- If no preference, allow by default (except marketing)
  IF v_pref IS NULL THEN
    IF p_category = 'marketing' THEN
      RETURN jsonb_build_object('send', false, 'reason', 'marketing_not_opted_in');
    END IF;
    RETURN jsonb_build_object('send', true, 'frequency', 'instant');
  END IF;

  -- Check if category is enabled
  IF NOT v_pref.enabled THEN
    RETURN jsonb_build_object('send', false, 'reason', 'category_disabled');
  END IF;

  -- Check frequency
  IF v_pref.frequency = 'never' THEN
    RETURN jsonb_build_object('send', false, 'reason', 'frequency_never');
  END IF;

  -- Check quiet hours (use preference override or global)
  DECLARE
    v_qh_enabled boolean := COALESCE(v_pref.quiet_hours_enabled, v_settings.quiet_hours_enabled);
    v_qh_start time := COALESCE(v_pref.quiet_hours_start, v_settings.quiet_hours_start);
    v_qh_end time := COALESCE(v_pref.quiet_hours_end, v_settings.quiet_hours_end);
  BEGIN
    IF v_qh_enabled THEN
      -- Handle overnight quiet hours (e.g., 22:00 - 08:00)
      IF v_qh_start > v_qh_end THEN
        v_in_quiet_hours := v_current_time >= v_qh_start OR v_current_time < v_qh_end;
      ELSE
        v_in_quiet_hours := v_current_time >= v_qh_start AND v_current_time < v_qh_end;
      END IF;

      IF v_in_quiet_hours AND p_category != 'system' THEN
        -- Calculate when quiet hours end
        IF v_qh_start > v_qh_end AND v_current_time >= v_qh_start THEN
          v_quiet_end := (v_now::date + 1 + v_qh_end)::timestamptz;
        ELSE
          v_quiet_end := (v_now::date + v_qh_end)::timestamptz;
        END IF;

        RETURN jsonb_build_object(
          'send', false,
          'reason', 'quiet_hours',
          'schedule_for', v_quiet_end,
          'frequency', v_pref.frequency
        );
      END IF;
    END IF;
  END;

  -- All checks passed
  RETURN jsonb_build_object(
    'send', true,
    'frequency', v_pref.frequency
  );
END;
$$;


--
-- Name: silence_user(uuid, integer, text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.silence_user(p_profile_id uuid, p_duration_hours integer, p_reason text DEFAULT NULL::text) RETURNS boolean
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
DECLARE
  v_is_moderator BOOLEAN;
BEGIN
  SELECT EXISTS (
    SELECT 1 FROM user_roles ur
    JOIN roles r ON ur.role_id = r.id
    WHERE ur.profile_id = auth.uid()
    AND r.name IN ('admin', 'super_admin', 'moderator')
  ) INTO v_is_moderator;
  
  IF NOT v_is_moderator THEN
    RAISE EXCEPTION 'Only moderators can silence users';
  END IF;
  
  UPDATE forum_user_stats SET
    was_silenced = true,
    silenced_until = now() + (p_duration_hours || ' hours')::INTERVAL,
    updated_at = now()
  WHERE profile_id = p_profile_id;
  
  -- Log the action
  PERFORM log_moderator_action(
    'user_mute',
    'user',
    p_profile_id::TEXT,
    p_profile_id,
    p_reason,
    jsonb_build_object('duration_hours', p_duration_hours)
  );
  
  RETURN true;
END;
$$;


--
-- Name: snapshot_provider_health(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.snapshot_provider_health() RETURNS void
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
BEGIN
  INSERT INTO public.email_provider_health_history (
    provider,
    health_score,
    success_rate,
    average_latency_ms,
    total_requests,
    successful_requests,
    failed_requests
  )
  SELECT
    provider,
    health_score,
    CASE WHEN total_requests > 0 
      THEN (successful_requests::DECIMAL / total_requests) * 100 
      ELSE 100 
    END as success_rate,
    average_latency_ms,
    total_requests,
    successful_requests,
    failed_requests
  FROM public.email_provider_health_metrics;
END;
$$;


--
-- Name: start_conversation(uuid[], text, text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.start_conversation(p_participant_ids uuid[], p_title text DEFAULT NULL::text, p_initial_message text DEFAULT NULL::text) RETURNS uuid
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
DECLARE
  v_conversation_id UUID;
  v_is_group BOOLEAN;
  v_participant_id UUID;
  v_existing_conversation_id UUID;
BEGIN
  -- Check if it's a group chat
  v_is_group := array_length(p_participant_ids, 1) > 1;
  
  -- For 1:1 chats, check if conversation already exists
  IF NOT v_is_group THEN
    SELECT c.id INTO v_existing_conversation_id
    FROM forum_conversations c
    JOIN forum_conversation_participants cp1 ON cp1.conversation_id = c.id AND cp1.profile_id = auth.uid()
    JOIN forum_conversation_participants cp2 ON cp2.conversation_id = c.id AND cp2.profile_id = p_participant_ids[1]
    WHERE c.is_group = FALSE
      AND cp1.left_at IS NULL
      AND cp2.left_at IS NULL
    LIMIT 1;
    
    IF v_existing_conversation_id IS NOT NULL THEN
      RETURN v_existing_conversation_id;
    END IF;
  END IF;
  
  -- Create new conversation
  INSERT INTO forum_conversations (title, is_group, created_by)
  VALUES (p_title, v_is_group, auth.uid())
  RETURNING id INTO v_conversation_id;
  
  -- Add creator as owner
  INSERT INTO forum_conversation_participants (conversation_id, profile_id, role)
  VALUES (v_conversation_id, auth.uid(), 'owner');
  
  -- Add other participants
  FOREACH v_participant_id IN ARRAY p_participant_ids
  LOOP
    IF v_participant_id != auth.uid() THEN
      INSERT INTO forum_conversation_participants (conversation_id, profile_id, role)
      VALUES (v_conversation_id, v_participant_id, 'member');
    END IF;
  END LOOP;
  
  -- Send initial message if provided
  IF p_initial_message IS NOT NULL THEN
    INSERT INTO forum_messages (conversation_id, sender_id, content)
    VALUES (v_conversation_id, auth.uid(), p_initial_message);
    
    UPDATE forum_conversations
    SET last_message_at = now(),
        last_message_preview = LEFT(p_initial_message, 100)
    WHERE id = v_conversation_id;
  END IF;
  
  RETURN v_conversation_id;
END;
$$;


--
-- Name: store_translation(text, text, text, text, numeric); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.store_translation(p_source_text text, p_translated_text text, p_target_locale text, p_content_type text DEFAULT 'general'::text, p_quality_score numeric DEFAULT 0.95) RETURNS uuid
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
    v_hash TEXT;
    v_id UUID;
BEGIN
    v_hash := encode(sha256(p_source_text::bytea), 'hex');

    INSERT INTO dynamic_content_translations (
        content_hash, source_text, translated_text, target_locale,
        content_type, quality_score
    )
    VALUES (
        v_hash, p_source_text, p_translated_text, p_target_locale,
        p_content_type, p_quality_score
    )
    ON CONFLICT (content_hash, target_locale)
    DO UPDATE SET
        translated_text = EXCLUDED.translated_text,
        quality_score = EXCLUDED.quality_score,
        expires_at = NOW() + INTERVAL '90 days'
    RETURNING id INTO v_id;

    RETURN v_id;
END;
$$;


--
-- Name: store_translation(text, text, text, text, text, text, text, double precision); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.store_translation(p_content_type text, p_content_id text, p_field_name text, p_source_locale text, p_target_locale text, p_source_text text, p_translated_text text, p_quality_score double precision DEFAULT 0.95) RETURNS uuid
    LANGUAGE plpgsql
    AS $$
DECLARE
  v_id UUID;
BEGIN
  INSERT INTO content_translations (
    content_type,
    content_id,
    field_name,
    source_locale,
    target_locale,
    source_text,
    translated_text,
    translation_service,
    quality_score,
    character_count
  ) VALUES (
    p_content_type,
    p_content_id,
    p_field_name,
    p_source_locale,
    p_target_locale,
    p_source_text,
    p_translated_text,
    'self-hosted-llm',
    p_quality_score,
    LENGTH(p_source_text)
  )
  ON CONFLICT (content_type, content_id, field_name, source_locale, target_locale, source_text)
  DO UPDATE SET
    translated_text = EXCLUDED.translated_text,
    quality_score = EXCLUDED.quality_score,
    hit_count = content_translations.hit_count + 1,
    last_hit_at = NOW()
  RETURNING id INTO v_id;
  
  RETURN v_id;
END;
$$;


--
-- Name: strip_address(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.strip_address() RETURNS trigger
    LANGUAGE plpgsql
    SET search_path TO ''
    AS $$
DECLARE
    stripped_address TEXT;
BEGIN
    -- Strip house number at the start
    stripped_address := regexp_replace(COALESCE(NEW.post_address, ''), '^\d+\s+', '', 'gi');
    
    -- Strip apartment/unit info but NOT from "United" (use word boundary)
    -- Match "apt", "apartment", "unit" only when followed by optional digits/letters (not "ed")
    stripped_address := regexp_replace(stripped_address, '\s*((?:apt\.?|apartment)\s*[0-9a-zA-Z]*\s*,?\s*)', '', 'gi');
    stripped_address := regexp_replace(stripped_address, '\s*(unit\s+[0-9a-zA-Z]+\s*,?\s*)', '', 'gi');
    stripped_address := regexp_replace(stripped_address, '\s*(#\s*[0-9a-zA-Z]+\s*,?\s*)', '', 'gi');
    
    -- Correct comma spacing: ensure there's exactly one space after each comma
    stripped_address := regexp_replace(stripped_address, ',\s*', ', ', 'g');
    
    -- Remove any leading or trailing commas and spaces
    stripped_address := trim(both ', ' from stripped_address);
    
    -- Assign the stripped and corrected address to the new column
    NEW.post_stripped_address := stripped_address;
    
    RETURN NEW;
END;
$$;


--
-- Name: strip_address(text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.strip_address(full_address text) RETURNS text
    LANGUAGE plpgsql IMMUTABLE
    SET search_path TO ''
    AS $$
BEGIN
  RETURN regexp_replace(full_address, '\d+', '', 'g');
END;
$$;


--
-- Name: submit_forum_report(bigint, bigint, text, text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.submit_forum_report(p_forum_id bigint DEFAULT NULL::bigint, p_comment_id bigint DEFAULT NULL::bigint, p_reason text DEFAULT 'other'::text, p_description text DEFAULT NULL::text) RETURNS uuid
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
DECLARE
  v_user_id UUID := auth.uid();
  v_reported_profile_id UUID;
  v_report_id UUID;
BEGIN
  IF v_user_id IS NULL THEN
    RAISE EXCEPTION 'Not authenticated';
  END IF;
  
  -- Get the profile ID of the content owner
  IF p_forum_id IS NOT NULL THEN
    SELECT profile_id INTO v_reported_profile_id
    FROM public.forum WHERE id = p_forum_id;
  ELSIF p_comment_id IS NOT NULL THEN
    SELECT profile_id INTO v_reported_profile_id
    FROM public.comments WHERE id = p_comment_id;
  ELSE
    RAISE EXCEPTION 'Must specify either forum_id or comment_id';
  END IF;
  
  -- Can't report your own content
  IF v_reported_profile_id = v_user_id THEN
    RAISE EXCEPTION 'Cannot report your own content';
  END IF;
  
  INSERT INTO public.forum_reports (
    reporter_id,
    reported_profile_id,
    forum_id,
    comment_id,
    reason,
    description
  ) VALUES (
    v_user_id,
    v_reported_profile_id,
    p_forum_id,
    p_comment_id,
    p_reason,
    p_description
  )
  RETURNING id INTO v_report_id;
  
  RETURN v_report_id;
END;
$$;


--
-- Name: submit_pending_operation(uuid, text, text, uuid, jsonb, timestamp with time zone); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.submit_pending_operation(p_user_id uuid, p_operation_type text, p_table_name text, p_record_id uuid, p_payload jsonb, p_client_timestamp timestamp with time zone) RETURNS jsonb
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
DECLARE
  v_operation_id uuid;
  v_current_record record;
  v_has_conflict boolean := false;
  v_server_timestamp timestamptz;
BEGIN
  -- Check for potential conflicts on update/delete
  IF p_operation_type IN ('update', 'delete') AND p_record_id IS NOT NULL THEN
    CASE p_table_name
      WHEN 'posts' THEN
        SELECT updated_at INTO v_server_timestamp
        FROM posts
        WHERE id = p_record_id AND profile_id = p_user_id;

      WHEN 'rooms' THEN
        SELECT last_message_time INTO v_server_timestamp
        FROM rooms
        WHERE id = p_record_id
          AND (sharer = p_user_id OR requester = p_user_id);

      ELSE
        v_server_timestamp := NULL;
    END CASE;

    -- Check if server has newer changes
    IF v_server_timestamp IS NOT NULL AND v_server_timestamp > p_client_timestamp THEN
      v_has_conflict := true;
    END IF;
  END IF;

  -- Insert pending operation
  INSERT INTO pending_operations (
    user_id, operation_type, table_name, record_id,
    payload, client_timestamp, status
  ) VALUES (
    p_user_id, p_operation_type, p_table_name, p_record_id,
    p_payload, p_client_timestamp,
    CASE WHEN v_has_conflict THEN 'conflict' ELSE 'pending' END
  )
  RETURNING id INTO v_operation_id;

  IF v_has_conflict THEN
    -- Get current server state for resolution
    UPDATE pending_operations
    SET conflict_resolution = jsonb_build_object(
      'serverTimestamp', v_server_timestamp,
      'clientTimestamp', p_client_timestamp,
      'needsResolution', true
    )
    WHERE id = v_operation_id;

    RETURN jsonb_build_object(
      'success', false,
      'operationId', v_operation_id,
      'conflict', true,
      'serverTimestamp', v_server_timestamp,
      'clientTimestamp', p_client_timestamp,
      'message', 'Server has newer changes. Please resolve conflict.'
    );
  END IF;

  RETURN jsonb_build_object(
    'success', true,
    'operationId', v_operation_id,
    'status', 'pending',
    'message', 'Operation queued for processing'
  );
END;
$$;


--
-- Name: FUNCTION submit_pending_operation(p_user_id uuid, p_operation_type text, p_table_name text, p_record_id uuid, p_payload jsonb, p_client_timestamp timestamp with time zone); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.submit_pending_operation(p_user_id uuid, p_operation_type text, p_table_name text, p_record_id uuid, p_payload jsonb, p_client_timestamp timestamp with time zone) IS 'Submits client operation for conflict detection';


--
-- Name: submit_review(uuid, bigint, smallint, text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.submit_review(p_reviewer_id uuid, p_post_id bigint, p_rating smallint, p_feedback text DEFAULT NULL::text) RETURNS jsonb
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
DECLARE
  v_review_id BIGINT;
  v_post_owner_id UUID;
  v_new_avg NUMERIC;
  v_new_count INTEGER;
BEGIN
  -- Validate rating
  IF p_rating < 1 OR p_rating > 5 THEN
    RETURN jsonb_build_object('success', FALSE, 'error', 'Rating must be 1-5');
  END IF;

  -- Get post owner
  SELECT profile_id INTO v_post_owner_id FROM posts WHERE id = p_post_id;
  
  IF v_post_owner_id IS NULL THEN
    RETURN jsonb_build_object('success', FALSE, 'error', 'Post not found');
  END IF;

  -- Can't review own post
  IF v_post_owner_id = p_reviewer_id THEN
    RETURN jsonb_build_object('success', FALSE, 'error', 'Cannot review your own post');
  END IF;

  -- Create review
  INSERT INTO reviews (profile_id, post_id, reviewed_rating, feedback, created_at)
  VALUES (p_reviewer_id, p_post_id, p_rating, p_feedback, NOW())
  RETURNING id INTO v_review_id;

  -- Update owner's rating stats
  SELECT 
    AVG(r.reviewed_rating)::NUMERIC,
    COUNT(*)::INTEGER
  INTO v_new_avg, v_new_count
  FROM reviews r
  JOIN posts p ON p.id = r.post_id
  WHERE p.profile_id = v_post_owner_id;

  UPDATE profile_stats SET
    rating_average = v_new_avg,
    rating_count = v_new_count,
    updated_at = NOW()
  WHERE profile_id = v_post_owner_id;

  -- Notification handled by trigger (notify_new_review)

  RETURN jsonb_build_object(
    'success', TRUE,
    'review_id', v_review_id,
    'new_average', ROUND(v_new_avg, 2),
    'total_reviews', v_new_count
  );
END;
$$;


--
-- Name: sync_email_provider_stats_internal(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.sync_email_provider_stats_internal() RETURNS void
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
DECLARE
  v_now timestamptz := now();
BEGIN
  -- Only update last_updated timestamp
  -- health_score comes from the hourly API sync (source of truth)
  UPDATE email_provider_health_metrics
  SET last_updated = v_now;

  -- Reset daily quotas if it's a new day (past midnight UTC)
  UPDATE email_provider_health_metrics
  SET
    daily_quota_used = 0,
    last_updated = v_now
  WHERE DATE(last_synced_at) < DATE(v_now)
    AND daily_quota_used > 0;
END;
$$;


--
-- Name: FUNCTION sync_email_provider_stats_internal(); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.sync_email_provider_stats_internal() IS 'Internal function to recalculate health scores and reset daily quotas';


--
-- Name: sync_locale_to_redis(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.sync_locale_to_redis() RETURNS trigger
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public', 'extensions'
    AS $$
DECLARE
  edge_function_url TEXT;
  service_role_key TEXT;
  http_request_id BIGINT;
BEGIN
  -- Only trigger if preferred_locale actually changed
  IF OLD.preferred_locale IS NOT DISTINCT FROM NEW.preferred_locale THEN
    RETURN NEW;
  END IF;

  -- Skip if new locale is NULL (user cleared preference)
  IF NEW.preferred_locale IS NULL THEN
    RETURN NEW;
  END IF;

  -- Get configuration from environment
  edge_function_url := current_setting('app.supabase_url', true) || '/functions/v1/api-v1-localization/sync-to-redis';
  service_role_key := current_setting('app.service_role_key', true);

  -- If settings not configured, use vault (fallback)
  IF edge_function_url IS NULL OR service_role_key IS NULL THEN
    SELECT
      decrypted_secret INTO edge_function_url
    FROM vault.decrypted_secrets
    WHERE name = 'supabase_url';

    SELECT
      decrypted_secret INTO service_role_key
    FROM vault.decrypted_secrets
    WHERE name = 'supabase_service_role_key';

    IF edge_function_url IS NOT NULL THEN
      edge_function_url := edge_function_url || '/functions/v1/api-v1-localization/sync-to-redis';
    END IF;
  END IF;

  -- Skip if configuration not available (graceful degradation)
  IF edge_function_url IS NULL OR service_role_key IS NULL THEN
    RAISE WARNING 'Locale Redis sync: Missing configuration, skipping';
    RETURN NEW;
  END IF;

  -- Make async HTTP request to Edge Function using pg_net
  SELECT net.http_post(
    url := edge_function_url,
    headers := jsonb_build_object(
      'Content-Type', 'application/json',
      'Authorization', 'Bearer ' || service_role_key
    ),
    body := jsonb_build_object(
      'userId', NEW.id::text,
      'locale', NEW.preferred_locale
    ),
    timeout_milliseconds := 5000
  ) INTO http_request_id;

  RAISE NOTICE 'Locale Redis sync: Request % sent for user % -> %',
    http_request_id, NEW.id, NEW.preferred_locale;

  RETURN NEW;
EXCEPTION
  WHEN OTHERS THEN
    RAISE WARNING 'Locale Redis sync failed: %', SQLERRM;
    RETURN NEW;
END;
$$;


--
-- Name: sync_provider_health(text, integer, integer, integer, integer, integer, integer, integer, integer, integer, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.sync_provider_health(p_provider text, p_health_score integer, p_latency_ms integer, p_daily_used integer DEFAULT 0, p_daily_limit integer DEFAULT 500, p_monthly_used integer DEFAULT 0, p_monthly_limit integer DEFAULT 15000, p_delivered integer DEFAULT 0, p_opened integer DEFAULT 0, p_clicked integer DEFAULT 0, p_bounced integer DEFAULT 0, p_complained integer DEFAULT 0) RETURNS void
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
BEGIN
  INSERT INTO email_provider_health_metrics (
    provider,
    health_score,
    average_latency_ms,
    daily_quota_used,
    daily_quota_limit,
    monthly_quota_used,
    monthly_quota_limit,
    emails_delivered,
    emails_opened,
    emails_clicked,
    emails_bounced,
    emails_complained,
    last_synced_at,
    last_updated
  )
  VALUES (
    p_provider,
    p_health_score,
    p_latency_ms,
    p_daily_used,
    p_daily_limit,
    p_monthly_used,
    p_monthly_limit,
    p_delivered,
    p_opened,
    p_clicked,
    p_bounced,
    p_complained,
    now(),
    now()
  )
  ON CONFLICT (provider) DO UPDATE SET
    health_score = p_health_score,
    average_latency_ms = p_latency_ms,
    daily_quota_used = p_daily_used,
    daily_quota_limit = p_daily_limit,
    monthly_quota_used = p_monthly_used,
    monthly_quota_limit = p_monthly_limit,
    emails_delivered = p_delivered,
    emails_opened = p_opened,
    emails_clicked = p_clicked,
    emails_bounced = p_bounced,
    emails_complained = p_complained,
    last_synced_at = now(),
    last_updated = now();
END;
$$;


--
-- Name: FUNCTION sync_provider_health(p_provider text, p_health_score integer, p_latency_ms integer, p_daily_used integer, p_daily_limit integer, p_monthly_used integer, p_monthly_limit integer, p_delivered integer, p_opened integer, p_clicked integer, p_bounced integer, p_complained integer); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.sync_provider_health(p_provider text, p_health_score integer, p_latency_ms integer, p_daily_used integer, p_daily_limit integer, p_monthly_used integer, p_monthly_limit integer, p_delivered integer, p_opened integer, p_clicked integer, p_bounced integer, p_complained integer) IS 'Syncs provider health data from external API calls (used by sync-email-provider-stats)';


--
-- Name: toggle_automation_cron(boolean); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.toggle_automation_cron(p_enabled boolean) RETURNS void
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public', 'cron'
    AS $$
BEGIN
  -- Update the cron job active status
  PERFORM cron.alter_job(
    job_id := (SELECT jobid FROM cron.job WHERE jobname = 'process-automation-queue'),
    active := p_enabled
  );
END;
$$;


--
-- Name: toggle_bookmark(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.toggle_bookmark(p_post_id integer) RETURNS json
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
DECLARE
    v_user_id UUID;
    v_existing_id INTEGER;
    v_is_bookmarked BOOLEAN;
BEGIN
    v_user_id := auth.uid();

    IF v_user_id IS NULL THEN
        RETURN json_build_object('success', false, 'error', json_build_object('code', 'AUTH_REQUIRED', 'message', 'Authentication required'));
    END IF;

    -- Verify post exists
    IF NOT EXISTS (SELECT 1 FROM posts WHERE id = p_post_id) THEN
        RETURN json_build_object('success', false, 'error', json_build_object('code', 'POST_NOT_FOUND', 'message', 'Post not found'));
    END IF;

    -- Check existing bookmark in unified bookmarks table
    SELECT id INTO v_existing_id FROM bookmarks
    WHERE post_id = p_post_id AND profile_id = v_user_id AND forum_id = 0;

    IF v_existing_id IS NOT NULL THEN
        -- Unbookmark: remove the bookmark
        DELETE FROM bookmarks WHERE id = v_existing_id;
        v_is_bookmarked := false;
    ELSE
        -- Bookmark: add a new bookmark
        INSERT INTO bookmarks (post_id, profile_id, forum_id)
        VALUES (p_post_id, v_user_id, 0);
        v_is_bookmarked := true;
    END IF;

    RETURN json_build_object(
        'success', true,
        'is_bookmarked', v_is_bookmarked
    );
END;
$$;


--
-- Name: FUNCTION toggle_bookmark(p_post_id integer); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.toggle_bookmark(p_post_id integer) IS 'Toggle bookmark on a post. Uses unified bookmarks table. Fixed overload 2026-01-31.';


--
-- Name: toggle_challenge_like(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.toggle_challenge_like(p_challenge_id integer) RETURNS json
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
DECLARE
    v_user_id UUID;
    v_existing_id INTEGER;
    v_is_liked BOOLEAN;
    v_like_count INTEGER;
BEGIN
    v_user_id := auth.uid();

    IF v_user_id IS NULL THEN
        RETURN json_build_object('success', false, 'error', json_build_object('code', 'AUTH_REQUIRED', 'message', 'Authentication required'));
    END IF;

    IF NOT EXISTS (SELECT 1 FROM challenges WHERE id = p_challenge_id) THEN
        RETURN json_build_object('success', false, 'error', json_build_object('code', 'CHALLENGE_NOT_FOUND', 'message', 'Challenge not found'));
    END IF;

    SELECT id INTO v_existing_id FROM likes
    WHERE challenge_id = p_challenge_id AND profile_id = v_user_id
      AND post_id = 0 AND forum_id = 0 AND comment_id = 0;

    IF v_existing_id IS NOT NULL THEN
        DELETE FROM likes WHERE id = v_existing_id;
        v_is_liked := false;
    ELSE
        INSERT INTO likes (profile_id, post_id, forum_id, challenge_id, comment_id, created_at)
        VALUES (v_user_id, 0, 0, p_challenge_id, 0, NOW());
        v_is_liked := true;
    END IF;

    SELECT COUNT(*) INTO v_like_count FROM likes
    WHERE challenge_id = p_challenge_id AND post_id = 0 AND forum_id = 0 AND comment_id = 0;

    UPDATE challenges SET challenge_likes = v_like_count WHERE id = p_challenge_id;

    RETURN json_build_object('success', true, 'is_liked', v_is_liked, 'like_count', v_like_count);
END;
$$;


--
-- Name: FUNCTION toggle_challenge_like(p_challenge_id integer); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.toggle_challenge_like(p_challenge_id integer) IS 'Toggle like on a challenge. Returns {success, is_liked, like_count}';


--
-- Name: toggle_comment_like(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.toggle_comment_like(p_comment_id integer) RETURNS json
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
DECLARE
    v_user_id UUID;
    v_existing_id INTEGER;
    v_is_liked BOOLEAN;
    v_like_count INTEGER;
    v_comment_owner_id UUID;
BEGIN
    v_user_id := auth.uid();

    IF v_user_id IS NULL THEN
        RETURN json_build_object('success', false, 'error', json_build_object('code', 'AUTH_REQUIRED', 'message', 'Authentication required'));
    END IF;

    -- Get comment owner for notification
    SELECT profile_id INTO v_comment_owner_id FROM forum_comments WHERE id = p_comment_id;

    IF v_comment_owner_id IS NULL THEN
        RETURN json_build_object('success', false, 'error', json_build_object('code', 'COMMENT_NOT_FOUND', 'message', 'Comment not found'));
    END IF;

    -- Check existing like in unified likes table
    SELECT id INTO v_existing_id FROM likes
    WHERE comment_id = p_comment_id AND profile_id = v_user_id
      AND post_id = 0 AND forum_id = 0 AND challenge_id = 0;

    IF v_existing_id IS NOT NULL THEN
        -- Unlike
        DELETE FROM likes WHERE id = v_existing_id;
        v_is_liked := false;

        -- Decrement counter
        UPDATE forum_comments SET likes_count = GREATEST(COALESCE(likes_count, 0) - 1, 0)
        WHERE id = p_comment_id;
    ELSE
        -- Like
        INSERT INTO likes (comment_id, profile_id, post_id, forum_id, challenge_id)
        VALUES (p_comment_id, v_user_id, 0, 0, 0);
        v_is_liked := true;

        -- Increment counter
        UPDATE forum_comments SET likes_count = COALESCE(likes_count, 0) + 1
        WHERE id = p_comment_id;

        -- Notification for comment owner (if not self-like)
        IF v_comment_owner_id != v_user_id THEN
            INSERT INTO notifications (profile_id, type, data)
            VALUES (v_comment_owner_id, 'comment_liked', jsonb_build_object(
                'comment_id', p_comment_id,
                'liker_id', v_user_id
            ))
            ON CONFLICT DO NOTHING;
        END IF;
    END IF;

    -- Get final like count
    SELECT COALESCE(likes_count, 0) INTO v_like_count FROM forum_comments WHERE id = p_comment_id;

    RETURN json_build_object(
        'success', true,
        'is_liked', v_is_liked,
        'like_count', v_like_count
    );
END;
$$;


--
-- Name: FUNCTION toggle_comment_like(p_comment_id integer); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.toggle_comment_like(p_comment_id integer) IS 'Toggle like on a comment. Uses unified likes table. Fixed overload 2026-01-31.';


--
-- Name: toggle_comment_reaction(integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.toggle_comment_reaction(p_comment_id integer, p_reaction_type_id integer) RETURNS TABLE(action text, reaction_counts jsonb)
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
DECLARE
  v_existing_id UUID;
  v_action TEXT;
  v_counts JSONB;
BEGIN
  -- Check if reaction exists
  SELECT id INTO v_existing_id
  FROM forum_comment_reactions
  WHERE comment_id = p_comment_id
    AND profile_id = auth.uid()
    AND reaction_type_id = p_reaction_type_id;
  
  IF v_existing_id IS NOT NULL THEN
    -- Remove reaction
    DELETE FROM forum_comment_reactions WHERE id = v_existing_id;
    v_action := 'removed';
  ELSE
    -- Add reaction
    INSERT INTO forum_comment_reactions (comment_id, profile_id, reaction_type_id)
    VALUES (p_comment_id, auth.uid(), p_reaction_type_id);
    v_action := 'added';
    
    -- Create notification for comment author
    INSERT INTO forum_notifications (recipient_id, type, actor_id, comment_id, data)
    SELECT 
      c.user_id,
      'comment_reaction',
      auth.uid(),
      p_comment_id,
      jsonb_build_object('reaction_type_id', p_reaction_type_id)
    FROM comments c
    WHERE c.id = p_comment_id
      AND c.user_id != auth.uid();
  END IF;
  
  -- Update reaction counts on comment
  SELECT jsonb_object_agg(
    rt.name,
    COALESCE(counts.cnt, 0)
  ) INTO v_counts
  FROM reaction_types rt
  LEFT JOIN (
    SELECT reaction_type_id, COUNT(*)::INTEGER AS cnt
    FROM forum_comment_reactions
    WHERE comment_id = p_comment_id
    GROUP BY reaction_type_id
  ) counts ON counts.reaction_type_id = rt.id;
  
  UPDATE comments
  SET reactions_count = v_counts
  WHERE id = p_comment_id;
  
  RETURN QUERY SELECT v_action, v_counts;
END;
$$;


--
-- Name: FUNCTION toggle_comment_reaction(p_comment_id integer, p_reaction_type_id integer); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.toggle_comment_reaction(p_comment_id integer, p_reaction_type_id integer) IS 'Add or remove a reaction on a comment';


--
-- Name: toggle_featured_badge(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.toggle_featured_badge(p_badge_id integer) RETURNS jsonb
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
DECLARE
  v_user_id UUID := auth.uid();
  v_current_state BOOLEAN;
  v_featured_count INT;
BEGIN
  IF v_user_id IS NULL THEN
    RAISE EXCEPTION 'Not authenticated';
  END IF;
  
  -- Get current state
  SELECT is_featured INTO v_current_state
  FROM public.forum_user_badges
  WHERE profile_id = v_user_id AND badge_id = p_badge_id;
  
  IF v_current_state IS NULL THEN
    RAISE EXCEPTION 'Badge not found or not earned';
  END IF;
  
  IF v_current_state THEN
    -- Unfeature
    UPDATE public.forum_user_badges
    SET is_featured = false
    WHERE profile_id = v_user_id AND badge_id = p_badge_id;
    
    RETURN jsonb_build_object('is_featured', false);
  ELSE
    -- Check featured count (max 3)
    SELECT COUNT(*) INTO v_featured_count
    FROM public.forum_user_badges
    WHERE profile_id = v_user_id AND is_featured = true;
    
    IF v_featured_count >= 3 THEN
      RAISE EXCEPTION 'Maximum 3 featured badges allowed';
    END IF;
    
    UPDATE public.forum_user_badges
    SET is_featured = true
    WHERE profile_id = v_user_id AND badge_id = p_badge_id;
    
    RETURN jsonb_build_object('is_featured', true);
  END IF;
END;
$$;


--
-- Name: toggle_forum_bookmark(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.toggle_forum_bookmark(p_forum_id integer) RETURNS json
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
DECLARE
    v_user_id UUID;
    v_existing_id INTEGER;
    v_is_bookmarked BOOLEAN;
BEGIN
    v_user_id := auth.uid();

    IF v_user_id IS NULL THEN
        RETURN json_build_object('success', false, 'error', json_build_object('code', 'AUTH_REQUIRED', 'message', 'Authentication required'));
    END IF;

    -- Verify forum post exists
    IF NOT EXISTS (SELECT 1 FROM forum WHERE id = p_forum_id) THEN
        RETURN json_build_object('success', false, 'error', json_build_object('code', 'FORUM_NOT_FOUND', 'message', 'Forum post not found'));
    END IF;

    -- Check existing bookmark in unified bookmarks table
    SELECT id INTO v_existing_id FROM bookmarks
    WHERE forum_id = p_forum_id AND profile_id = v_user_id AND post_id = 0;

    IF v_existing_id IS NOT NULL THEN
        -- Unbookmark
        DELETE FROM bookmarks WHERE id = v_existing_id;
        v_is_bookmarked := false;
    ELSE
        -- Bookmark
        INSERT INTO bookmarks (forum_id, profile_id, post_id)
        VALUES (p_forum_id, v_user_id, 0);
        v_is_bookmarked := true;
    END IF;

    RETURN json_build_object(
        'success', true,
        'is_bookmarked', v_is_bookmarked
    );
END;
$$;


--
-- Name: FUNCTION toggle_forum_bookmark(p_forum_id integer); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.toggle_forum_bookmark(p_forum_id integer) IS 'Toggle bookmark on a forum post. Uses unified bookmarks table. Fixed overload 2026-01-31.';


--
-- Name: toggle_forum_like(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.toggle_forum_like(p_forum_id integer) RETURNS json
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
DECLARE
    v_user_id UUID;
    v_existing_id INTEGER;
    v_is_liked BOOLEAN;
    v_like_count INTEGER;
BEGIN
    v_user_id := auth.uid();

    IF v_user_id IS NULL THEN
        RETURN json_build_object('success', false, 'error', json_build_object('code', 'AUTH_REQUIRED', 'message', 'Authentication required'));
    END IF;

    IF NOT EXISTS (SELECT 1 FROM forum WHERE id = p_forum_id AND deleted_at IS NULL) THEN
        RETURN json_build_object('success', false, 'error', json_build_object('code', 'FORUM_NOT_FOUND', 'message', 'Forum post not found'));
    END IF;

    SELECT id INTO v_existing_id FROM likes
    WHERE forum_id = p_forum_id AND profile_id = v_user_id
      AND post_id = 0 AND challenge_id = 0 AND comment_id = 0;

    IF v_existing_id IS NOT NULL THEN
        DELETE FROM likes WHERE id = v_existing_id;
        v_is_liked := false;
    ELSE
        INSERT INTO likes (profile_id, post_id, forum_id, challenge_id, comment_id, created_at)
        VALUES (v_user_id, 0, p_forum_id, 0, 0, NOW());
        v_is_liked := true;
    END IF;

    SELECT COUNT(*) INTO v_like_count FROM likes
    WHERE forum_id = p_forum_id AND post_id = 0 AND challenge_id = 0 AND comment_id = 0;

    UPDATE forum SET likes_count = v_like_count WHERE id = p_forum_id;

    RETURN json_build_object('success', true, 'is_liked', v_is_liked, 'like_count', v_like_count);
END;
$$;


--
-- Name: FUNCTION toggle_forum_like(p_forum_id integer); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.toggle_forum_like(p_forum_id integer) IS 'Toggle like on a forum post. Returns {success, is_liked, like_count}';


--
-- Name: toggle_forum_reaction(bigint, text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.toggle_forum_reaction(p_forum_id bigint, p_reaction_type text) RETURNS jsonb
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
DECLARE
  v_user_id UUID := auth.uid();
  v_reaction_type_id INT;
  v_existing_id UUID;
  v_result JSONB;
BEGIN
  IF v_user_id IS NULL THEN
    RAISE EXCEPTION 'Not authenticated';
  END IF;
  
  -- Get reaction type id
  SELECT id INTO v_reaction_type_id
  FROM public.reaction_types
  WHERE name = p_reaction_type;
  
  IF v_reaction_type_id IS NULL THEN
    RAISE EXCEPTION 'Invalid reaction type: %', p_reaction_type;
  END IF;
  
  -- Check if reaction exists
  SELECT id INTO v_existing_id
  FROM public.forum_reactions
  WHERE forum_id = p_forum_id
    AND profile_id = v_user_id
    AND reaction_type_id = v_reaction_type_id;
  
  IF v_existing_id IS NOT NULL THEN
    -- Remove reaction
    DELETE FROM public.forum_reactions WHERE id = v_existing_id;
    v_result := jsonb_build_object('action', 'removed', 'reaction', p_reaction_type);
  ELSE
    -- Add reaction
    INSERT INTO public.forum_reactions (forum_id, profile_id, reaction_type_id)
    VALUES (p_forum_id, v_user_id, v_reaction_type_id);
    v_result := jsonb_build_object('action', 'added', 'reaction', p_reaction_type);
  END IF;
  
  -- Return result with updated counts
  SELECT v_result || jsonb_build_object('reactions_count', reactions_count)
  INTO v_result
  FROM public.forum
  WHERE id = p_forum_id;
  
  RETURN v_result;
END;
$$;


--
-- Name: toggle_forum_subscription(bigint, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.toggle_forum_subscription(p_forum_id bigint DEFAULT NULL::bigint, p_category_id integer DEFAULT NULL::integer) RETURNS jsonb
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
DECLARE
  v_user_id UUID := auth.uid();
  v_existing_id UUID;
BEGIN
  IF v_user_id IS NULL THEN
    RAISE EXCEPTION 'Not authenticated';
  END IF;
  
  IF p_forum_id IS NULL AND p_category_id IS NULL THEN
    RAISE EXCEPTION 'Must specify forum_id or category_id';
  END IF;
  
  -- Check for existing subscription
  IF p_forum_id IS NOT NULL THEN
    SELECT id INTO v_existing_id FROM public.forum_subscriptions
    WHERE profile_id = v_user_id AND forum_id = p_forum_id;
  ELSE
    SELECT id INTO v_existing_id FROM public.forum_subscriptions
    WHERE profile_id = v_user_id AND category_id = p_category_id;
  END IF;
  
  IF v_existing_id IS NOT NULL THEN
    DELETE FROM public.forum_subscriptions WHERE id = v_existing_id;
    RETURN jsonb_build_object('action', 'unsubscribed', 'subscribed', false);
  ELSE
    INSERT INTO public.forum_subscriptions (profile_id, forum_id, category_id)
    VALUES (v_user_id, p_forum_id, p_category_id);
    RETURN jsonb_build_object('action', 'subscribed', 'subscribed', true);
  END IF;
END;
$$;


--
-- Name: toggle_like(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.toggle_like(p_post_id integer) RETURNS json
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
DECLARE
    v_user_id UUID;
    v_existing_id INTEGER;
    v_is_liked BOOLEAN;
    v_like_count INTEGER;
    v_post_owner_id UUID;
BEGIN
    v_user_id := auth.uid();

    IF v_user_id IS NULL THEN
        RETURN json_build_object('success', false, 'error', json_build_object('code', 'AUTH_REQUIRED', 'message', 'Authentication required'));
    END IF;

    -- Get post owner for notification
    SELECT profile_id INTO v_post_owner_id FROM posts WHERE id = p_post_id;

    IF v_post_owner_id IS NULL THEN
        RETURN json_build_object('success', false, 'error', json_build_object('code', 'POST_NOT_FOUND', 'message', 'Post not found'));
    END IF;

    -- Check existing like in unified likes table
    SELECT id INTO v_existing_id FROM likes
    WHERE post_id = p_post_id AND profile_id = v_user_id
      AND forum_id = 0 AND challenge_id = 0 AND comment_id = 0;

    IF v_existing_id IS NOT NULL THEN
        -- Unlike: remove the like
        DELETE FROM likes WHERE id = v_existing_id;
        v_is_liked := false;

        -- Decrement counter atomically
        UPDATE posts SET post_like_counter = GREATEST(COALESCE(post_like_counter, 0) - 1, 0)
        WHERE id = p_post_id;
    ELSE
        -- Like: add a new like
        INSERT INTO likes (post_id, profile_id, forum_id, challenge_id, comment_id)
        VALUES (p_post_id, v_user_id, 0, 0, 0);
        v_is_liked := true;

        -- Increment counter atomically
        UPDATE posts SET post_like_counter = COALESCE(post_like_counter, 0) + 1
        WHERE id = p_post_id;

        -- Create notification for post owner (if not self-like)
        IF v_post_owner_id != v_user_id THEN
            INSERT INTO notifications (profile_id, type, data)
            VALUES (v_post_owner_id, 'post_liked', jsonb_build_object(
                'post_id', p_post_id,
                'liker_id', v_user_id
            ))
            ON CONFLICT DO NOTHING;
        END IF;
    END IF;

    -- Get final like count
    SELECT COALESCE(post_like_counter, 0) INTO v_like_count FROM posts WHERE id = p_post_id;

    RETURN json_build_object(
        'success', true,
        'is_liked', v_is_liked,
        'like_count', v_like_count
    );
END;
$$;


--
-- Name: FUNCTION toggle_like(p_post_id integer); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.toggle_like(p_post_id integer) IS 'Toggle like on a post. Uses unified likes table. Returns is_liked and like_count.';


--
-- Name: toggle_pinned_comment(bigint); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.toggle_pinned_comment(p_comment_id bigint) RETURNS jsonb
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
DECLARE
  v_user_id UUID := auth.uid();
  v_comment RECORD;
  v_forum RECORD;
BEGIN
  IF v_user_id IS NULL THEN
    RAISE EXCEPTION 'Not authenticated';
  END IF;
  
  SELECT * INTO v_comment FROM public.comments WHERE id = p_comment_id;
  IF v_comment IS NULL THEN
    RAISE EXCEPTION 'Comment not found';
  END IF;
  
  SELECT * INTO v_forum FROM public.forum WHERE id = v_comment.forum_id;
  
  -- Only post author can pin comments
  IF v_forum.profile_id != v_user_id THEN
    RAISE EXCEPTION 'Only the post author can pin comments';
  END IF;
  
  UPDATE public.comments
  SET is_pinned = NOT is_pinned
  WHERE id = p_comment_id;
  
  RETURN jsonb_build_object('is_pinned', NOT v_comment.is_pinned);
END;
$$;


--
-- Name: toggle_post_bookmark(bigint, uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.toggle_post_bookmark(p_post_id bigint, p_user_id uuid) RETURNS jsonb
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
DECLARE
  v_is_bookmarked BOOLEAN;
BEGIN
  -- Check if already bookmarked
  SELECT EXISTS(SELECT 1 FROM post_bookmarks WHERE post_id = p_post_id AND profile_id = p_user_id) INTO v_is_bookmarked;

  IF v_is_bookmarked THEN
    DELETE FROM post_bookmarks WHERE post_id = p_post_id AND profile_id = p_user_id;
  ELSE
    INSERT INTO post_bookmarks (post_id, profile_id, created_at) VALUES (p_post_id, p_user_id, NOW())
    ON CONFLICT DO NOTHING;
  END IF;

  RETURN jsonb_build_object(
    'success', TRUE,
    'is_bookmarked', NOT v_is_bookmarked
  );
END;
$$;


--
-- Name: toggle_post_like(bigint, uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.toggle_post_like(p_post_id bigint, p_user_id uuid) RETURNS jsonb
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
DECLARE
  v_is_liked BOOLEAN;
  v_new_count INTEGER;
  v_post_owner_id UUID;
  v_user_name TEXT;
BEGIN
  -- Check if already liked
  SELECT EXISTS(SELECT 1 FROM post_likes WHERE post_id = p_post_id AND profile_id = p_user_id) INTO v_is_liked;

  IF v_is_liked THEN
    -- Unlike
    DELETE FROM post_likes WHERE post_id = p_post_id AND profile_id = p_user_id;
    UPDATE posts SET post_like_counter = GREATEST(COALESCE(post_like_counter, 0) - 1, 0) WHERE id = p_post_id;
  ELSE
    -- Like
    INSERT INTO post_likes (post_id, profile_id, created_at) VALUES (p_post_id, p_user_id, NOW())
    ON CONFLICT DO NOTHING;
    UPDATE posts SET post_like_counter = COALESCE(post_like_counter, 0) + 1 WHERE id = p_post_id;

    -- Create notification for post owner
    SELECT profile_id INTO v_post_owner_id FROM posts WHERE id = p_post_id;
    SELECT nickname INTO v_user_name FROM profiles WHERE id = p_user_id;

    IF v_post_owner_id IS NOT NULL AND v_post_owner_id != p_user_id THEN
      INSERT INTO user_notifications (id, recipient_id, actor_id, type, title, body, post_id, is_read, created_at)
      VALUES (
        gen_random_uuid(),
        v_post_owner_id,
        p_user_id,
        'like',
        COALESCE(v_user_name, 'Someone') || ' liked your post',
        'Your listing received a new like',
        p_post_id,
        FALSE,
        NOW()
      )
      ON CONFLICT DO NOTHING;
    END IF;
  END IF;

  -- Get new count
  SELECT COALESCE(post_like_counter, 0) INTO v_new_count FROM posts WHERE id = p_post_id;

  RETURN jsonb_build_object(
    'success', TRUE,
    'is_liked', NOT v_is_liked,
    'like_count', v_new_count
  );
END;
$$;


--
-- Name: toggle_user_follow(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.toggle_user_follow(p_user_id uuid) RETURNS jsonb
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
DECLARE
  v_user_id UUID := auth.uid();
  v_existing_id UUID;
BEGIN
  IF v_user_id IS NULL THEN
    RAISE EXCEPTION 'Not authenticated';
  END IF;
  
  IF v_user_id = p_user_id THEN
    RAISE EXCEPTION 'Cannot follow yourself';
  END IF;
  
  SELECT id INTO v_existing_id FROM public.forum_user_follows
  WHERE follower_id = v_user_id AND following_id = p_user_id;
  
  IF v_existing_id IS NOT NULL THEN
    DELETE FROM public.forum_user_follows WHERE id = v_existing_id;
    RETURN jsonb_build_object('action', 'unfollowed', 'following', false);
  ELSE
    INSERT INTO public.forum_user_follows (follower_id, following_id)
    VALUES (v_user_id, p_user_id);
    RETURN jsonb_build_object('action', 'followed', 'following', true);
  END IF;
END;
$$;


--
-- Name: track_comment_edit(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.track_comment_edit() RETURNS trigger
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
BEGIN
  IF OLD.comment IS DISTINCT FROM NEW.comment THEN
    INSERT INTO public.forum_comment_history (
      comment_id, editor_id, previous_content
    ) VALUES (
      OLD.id, (SELECT auth.uid()), OLD.comment
    );
    
    NEW.is_edited := true;
    NEW.updated_at := now();
  END IF;
  
  RETURN NEW;
END;
$$;


--
-- Name: track_forum_edit(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.track_forum_edit() RETURNS trigger
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
BEGIN
  -- Only track if content actually changed
  IF OLD.forum_post_name IS DISTINCT FROM NEW.forum_post_name OR
     OLD.forum_post_description IS DISTINCT FROM NEW.forum_post_description OR
     OLD.forum_post_image IS DISTINCT FROM NEW.forum_post_image THEN
     
    INSERT INTO public.forum_post_history (
      forum_id, editor_id, previous_title, previous_description, previous_image
    ) VALUES (
      OLD.id, (SELECT auth.uid()), OLD.forum_post_name, OLD.forum_post_description, OLD.forum_post_image
    );
    
    -- Mark as edited
    NEW.is_edited := true;
  END IF;
  
  RETURN NEW;
END;
$$;


--
-- Name: track_reading_progress(bigint, bigint, integer, integer, boolean); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.track_reading_progress(p_forum_id bigint, p_last_comment_id bigint DEFAULT NULL::bigint, p_scroll_position integer DEFAULT NULL::integer, p_time_spent integer DEFAULT NULL::integer, p_is_fully_read boolean DEFAULT NULL::boolean) RETURNS jsonb
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
DECLARE
  v_result JSONB;
  v_total_comments INTEGER;
BEGIN
  -- Get total comments for the post
  SELECT forum_comments_counter::INTEGER INTO v_total_comments
  FROM forum WHERE id = p_forum_id;
  
  -- Upsert reading progress
  INSERT INTO forum_reading_progress (
    profile_id,
    forum_id,
    last_read_comment_id,
    scroll_position,
    time_spent_seconds,
    is_fully_read,
    last_read_at,
    read_count
  ) VALUES (
    auth.uid(),
    p_forum_id,
    p_last_comment_id,
    COALESCE(p_scroll_position, 0),
    COALESCE(p_time_spent, 0),
    COALESCE(p_is_fully_read, false),
    now(),
    1
  )
  ON CONFLICT (profile_id, forum_id) DO UPDATE SET
    last_read_comment_id = COALESCE(p_last_comment_id, forum_reading_progress.last_read_comment_id),
    scroll_position = COALESCE(p_scroll_position, forum_reading_progress.scroll_position),
    time_spent_seconds = forum_reading_progress.time_spent_seconds + COALESCE(p_time_spent, 0),
    is_fully_read = COALESCE(p_is_fully_read, forum_reading_progress.is_fully_read),
    last_read_at = now(),
    read_count = forum_reading_progress.read_count + 1
  RETURNING jsonb_build_object(
    'forum_id', forum_id,
    'read_count', read_count,
    'time_spent_seconds', time_spent_seconds,
    'is_fully_read', is_fully_read
  ) INTO v_result;
  
  -- Also add to history (for timeline view)
  INSERT INTO forum_reading_history (profile_id, forum_id, viewed_at)
  VALUES (auth.uid(), p_forum_id, now());
  
  -- Cleanup old history (keep last 500 per user)
  DELETE FROM forum_reading_history
  WHERE id IN (
    SELECT id FROM forum_reading_history
    WHERE profile_id = auth.uid()
    ORDER BY viewed_at DESC
    OFFSET 500
  );
  
  RETURN v_result;
END;
$$;


--
-- Name: track_translation_changes(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.track_translation_changes() RETURNS trigger
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
DECLARE
  v_old_messages JSONB;
  v_new_messages JSONB;
  v_changes JSONB := '{}';
  v_key TEXT;
  v_old_value TEXT;
  v_new_value TEXT;
BEGIN
  v_old_messages := COALESCE(OLD.messages, '{}'::JSONB);
  v_new_messages := COALESCE(NEW.messages, '{}'::JSONB);

  -- Find changed and new keys
  FOR v_key, v_new_value IN SELECT * FROM jsonb_each_text(v_new_messages)
  LOOP
    v_old_value := v_old_messages ->> v_key;
    IF v_old_value IS NULL OR v_old_value != v_new_value THEN
      v_changes := v_changes || jsonb_build_object(v_key, v_new_value);
    END IF;
  END LOOP;

  -- Find deleted keys (mark as null)
  FOR v_key IN SELECT * FROM jsonb_object_keys(v_old_messages)
  LOOP
    IF NOT v_new_messages ? v_key THEN
      v_changes := v_changes || jsonb_build_object(v_key, null);
    END IF;
  END LOOP;

  -- Only insert if there are actual changes
  IF v_changes != '{}'::JSONB THEN
    INSERT INTO translation_versions (locale, version, changes, previous_version)
    VALUES (NEW.locale, NEW.version, v_changes, OLD.version);
  END IF;

  RETURN NEW;
END;
$$;


--
-- Name: track_user_activity(uuid, text, jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.track_user_activity(p_user_id uuid, p_activity_type text, p_data jsonb DEFAULT '{}'::jsonb) RETURNS void
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
DECLARE
  v_current_hour integer := EXTRACT(HOUR FROM NOW())::integer;
  v_category_id text;
  v_search_term text;
BEGIN
  -- Ensure user exists in activity summary
  INSERT INTO user_activity_summary (user_id, first_activity_at, last_activity_at)
  VALUES (p_user_id, NOW(), NOW())
  ON CONFLICT (user_id) DO UPDATE SET
    last_activity_at = NOW(),
    updated_at = NOW();

  -- Process based on activity type
  CASE p_activity_type
    WHEN 'view' THEN
      -- Increment listings viewed
      UPDATE user_activity_summary SET
        listings_viewed = listings_viewed + 1
      WHERE user_id = p_user_id;

      -- Track category if provided
      v_category_id := p_data->>'category_id';
      IF v_category_id IS NOT NULL THEN
        UPDATE user_activity_summary SET
          categories_viewed = jsonb_set(
            categories_viewed,
            ARRAY[v_category_id],
            to_jsonb(COALESCE((categories_viewed->>v_category_id)::integer, 0) + 1)
          )
        WHERE user_id = p_user_id;
      END IF;

    WHEN 'search' THEN
      v_search_term := p_data->>'term';
      IF v_search_term IS NOT NULL AND v_search_term != '' THEN
        UPDATE user_activity_summary SET
          search_count = search_count + 1,
          -- Keep only last 20 search terms
          search_terms = (
            SELECT array_agg(term)
            FROM (
              SELECT unnest(ARRAY[v_search_term] || search_terms) AS term
              LIMIT 20
            ) sub
          )
        WHERE user_id = p_user_id;
      END IF;

      -- Track searched location if provided
      IF p_data ? 'lat' AND p_data ? 'lng' THEN
        UPDATE user_activity_summary SET
          locations_searched = (
            SELECT jsonb_agg(loc)
            FROM (
              SELECT jsonb_build_object(
                'lat', p_data->>'lat',
                'lng', p_data->>'lng',
                'count', 1
              ) AS loc
              UNION ALL
              SELECT value AS loc
              FROM jsonb_array_elements(locations_searched)
              LIMIT 10
            ) sub
          )
        WHERE user_id = p_user_id;
      END IF;

    WHEN 'save' THEN
      UPDATE user_activity_summary SET
        listings_saved = listings_saved + 1
      WHERE user_id = p_user_id;

    WHEN 'message' THEN
      UPDATE user_activity_summary SET
        messages_initiated = messages_initiated + 1
      WHERE user_id = p_user_id;

    WHEN 'share_complete' THEN
      UPDATE user_activity_summary SET
        shares_completed = shares_completed + 1
      WHERE user_id = p_user_id;

    ELSE
      -- Unknown activity type - just update timestamp
      NULL;
  END CASE;

  -- Update peak activity hours
  UPDATE user_activity_summary SET
    peak_activity_hours = jsonb_set(
      peak_activity_hours,
      ARRAY[v_current_hour::text],
      to_jsonb(COALESCE((peak_activity_hours->>v_current_hour::text)::integer, 0) + 1)
    )
  WHERE user_id = p_user_id;

END;
$$;


--
-- Name: FUNCTION track_user_activity(p_user_id uuid, p_activity_type text, p_data jsonb); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.track_user_activity(p_user_id uuid, p_activity_type text, p_data jsonb) IS 'Records user activity for personalization';


--
-- Name: track_user_event(uuid, text, jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.track_user_event(p_user_id uuid, p_event_type text, p_data jsonb DEFAULT '{}'::jsonb) RETURNS jsonb
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
DECLARE
  v_event_id uuid;
  v_category_id text;
BEGIN
  -- Insert event
  INSERT INTO user_events (user_id, event_type, event_data)
  VALUES (p_user_id, p_event_type, p_data)
  RETURNING id INTO v_event_id;

  -- Update user_activity_summary (created in aggregation_tables migration)
  -- This is a fire-and-forget update, errors are ignored
  BEGIN
    -- Ensure user exists in activity summary
    INSERT INTO user_activity_summary (user_id, first_activity_at, last_activity_at)
    VALUES (p_user_id, NOW(), NOW())
    ON CONFLICT (user_id) DO UPDATE SET
      last_activity_at = NOW(),
      updated_at = NOW();

    -- Update specific metrics based on event type
    CASE p_event_type
      WHEN 'listing_view' THEN
        UPDATE user_activity_summary SET
          listings_viewed = listings_viewed + 1
        WHERE user_id = p_user_id;

        -- Track category preference
        v_category_id := p_data->>'category_id';
        IF v_category_id IS NOT NULL THEN
          UPDATE user_activity_summary SET
            categories_viewed = jsonb_set(
              COALESCE(categories_viewed, '{}'::jsonb),
              ARRAY[v_category_id],
              to_jsonb(COALESCE((categories_viewed->>v_category_id)::integer, 0) + 1)
            )
          WHERE user_id = p_user_id;
        END IF;

      WHEN 'listing_save' THEN
        UPDATE user_activity_summary SET
          listings_saved = listings_saved + 1
        WHERE user_id = p_user_id;

      WHEN 'search' THEN
        UPDATE user_activity_summary SET
          search_count = search_count + 1,
          search_terms = (
            SELECT array_agg(term)
            FROM (
              SELECT unnest(ARRAY[p_data->>'term'] || COALESCE(search_terms, '{}')) AS term
              LIMIT 20
            ) sub
            WHERE term IS NOT NULL AND term != ''
          )
        WHERE user_id = p_user_id;

      WHEN 'message_sent' THEN
        UPDATE user_activity_summary SET
          messages_initiated = messages_initiated + 1
        WHERE user_id = p_user_id;

      WHEN 'share_complete' THEN
        UPDATE user_activity_summary SET
          shares_completed = shares_completed + 1
        WHERE user_id = p_user_id;

      ELSE
        NULL; -- Unknown event type, just log it
    END CASE;

    -- Update peak activity hours
    UPDATE user_activity_summary SET
      peak_activity_hours = jsonb_set(
        COALESCE(peak_activity_hours, '{}'::jsonb),
        ARRAY[EXTRACT(HOUR FROM NOW())::text],
        to_jsonb(COALESCE((peak_activity_hours->>EXTRACT(HOUR FROM NOW())::text)::integer, 0) + 1)
      )
    WHERE user_id = p_user_id;

  EXCEPTION WHEN OTHERS THEN
    -- Ignore errors in activity summary update
    NULL;
  END;

  RETURN jsonb_build_object(
    'success', true,
    'eventId', v_event_id,
    'eventType', p_event_type
  );
END;
$$;


--
-- Name: FUNCTION track_user_event(p_user_id uuid, p_event_type text, p_data jsonb); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.track_user_event(p_user_id uuid, p_event_type text, p_data jsonb) IS 'Records user events for analytics and personalization';


--
-- Name: track_view(integer, text, uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.track_view(p_post_id integer, p_session_id text DEFAULT NULL::text, p_viewer_id uuid DEFAULT NULL::uuid) RETURNS jsonb
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
DECLARE v_session TEXT; v_viewer UUID; v_existing_view UUID; v_view_count INT; v_debounce_minutes INT := 30;
BEGIN
    v_viewer := COALESCE(p_viewer_id, auth.uid());
    v_session := COALESCE(p_session_id, COALESCE(v_viewer::TEXT, 'anon-' || gen_random_uuid()::TEXT));
    IF NOT EXISTS (SELECT 1 FROM posts WHERE id = p_post_id AND is_active = true) THEN RETURN jsonb_build_object('success', false, 'error', jsonb_build_object('code', 'POST_NOT_FOUND', 'message', 'Post not found or inactive')); END IF;
    SELECT id INTO v_existing_view FROM post_views WHERE post_id = p_post_id AND session_id = v_session AND created_at > NOW() - (v_debounce_minutes || ' minutes')::INTERVAL;
    IF v_existing_view IS NOT NULL THEN SELECT COALESCE(post_views, 0) INTO v_view_count FROM posts WHERE id = p_post_id; RETURN jsonb_build_object('success', true, 'counted', false, 'view_count', v_view_count, 'message', 'View already counted'); END IF;
    INSERT INTO post_views (post_id, viewer_id, session_id) VALUES (p_post_id, v_viewer, v_session) ON CONFLICT (post_id, session_id) DO NOTHING;
    UPDATE posts SET post_views = COALESCE(post_views, 0) + 1 WHERE id = p_post_id RETURNING post_views INTO v_view_count;
    RETURN jsonb_build_object('success', true, 'counted', true, 'view_count', v_view_count);
EXCEPTION WHEN OTHERS THEN RETURN jsonb_build_object('success', false, 'error', jsonb_build_object('code', 'SERVER_ERROR', 'message', SQLERRM));
END;
$$;


--
-- Name: trending_items(integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.trending_items(hours_lookback integer DEFAULT 24, limit_count integer DEFAULT 20) RETURNS TABLE(id bigint, title text, description text, primary_image_url text, user_id uuid, category_id bigint, view_count integer, reservation_count integer, created_at timestamp with time zone, trending_score double precision)
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO ''
    AS $$
BEGIN
    RETURN QUERY
    SELECT 
        fi.id,
        fi.title,
        fi.description,
        fi.primary_image_url,
        fi.user_id,
        fi.category_id,
        fi.view_count,
        fi.reservation_count,
        fi.created_at,
        -- Trending score: weighted combination of views, reservations, and recency
        (
            (fi.view_count * 1.0) + 
            (fi.reservation_count * 5.0) + 
            (EXTRACT(EPOCH FROM (NOW() - fi.created_at)) / 3600.0 * -0.5)
        )::DOUBLE PRECISION AS trending_score
    FROM public.food_items fi
    WHERE 
        fi.is_active = true
        AND fi.status = 'available'
        AND fi.created_at >= NOW() - (hours_lookback || ' hours')::INTERVAL
    ORDER BY trending_score DESC
    LIMIT limit_count;
END;
$$;


--
-- Name: FUNCTION trending_items(hours_lookback integer, limit_count integer); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.trending_items(hours_lookback integer, limit_count integer) IS 'Get trending food items based on engagement metrics';


--
-- Name: trg_add_report_to_queue(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.trg_add_report_to_queue() RETURNS trigger
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
DECLARE
  v_report_count INTEGER;
  v_priority INTEGER := 0;
BEGIN
  -- Count existing reports for same content
  SELECT COUNT(*) INTO v_report_count FROM forum_reports
  WHERE (forum_id = NEW.forum_id OR comment_id = NEW.comment_id)
    AND status = 'pending';
  
  -- Increase priority based on report count
  IF v_report_count >= 3 THEN v_priority := 2;
  ELSIF v_report_count >= 1 THEN v_priority := 1;
  END IF;
  
  -- Add to queue (avoid duplicates)
  INSERT INTO forum_moderation_queue (
    queue_type, content_type, forum_id, comment_id, profile_id,
    report_id, reporter_id, flag_reason, priority
  )
  SELECT 'report',
    CASE WHEN NEW.forum_id IS NOT NULL THEN 'post' ELSE 'comment' END,
    NEW.forum_id, NEW.comment_id, NEW.reported_profile_id,
    NEW.id, NEW.reporter_id, NEW.reason, v_priority
  WHERE NOT EXISTS (
    SELECT 1 FROM forum_moderation_queue
    WHERE status = 'pending'
      AND ((forum_id = NEW.forum_id AND NEW.forum_id IS NOT NULL) OR (comment_id = NEW.comment_id AND NEW.comment_id IS NOT NULL))
  );
  
  RETURN NEW;
END;
$$;


--
-- Name: trg_award_comment_reputation(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.trg_award_comment_reputation() RETURNS trigger
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
BEGIN
  IF TG_OP = 'INSERT' THEN
    PERFORM award_reputation(NEW.user_id, 'comment_created', NULL, NEW.forum_id, NEW.id);
  END IF;
  RETURN NEW;
END;
$$;


--
-- Name: trg_award_like_reputation(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.trg_award_like_reputation() RETURNS trigger
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
DECLARE
  v_post_author UUID;
BEGIN
  IF TG_OP = 'INSERT' AND NEW.forum_id IS NOT NULL THEN
    SELECT profile_id INTO v_post_author FROM forum WHERE id = NEW.forum_id;
    IF v_post_author IS NOT NULL AND v_post_author != NEW.profile_id THEN
      PERFORM award_reputation(v_post_author, 'post_liked', NEW.profile_id, NEW.forum_id, NULL);
    END IF;
  END IF;
  RETURN NEW;
END;
$$;


--
-- Name: trg_award_post_reputation(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.trg_award_post_reputation() RETURNS trigger
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
BEGIN
  IF TG_OP = 'INSERT' AND NEW.forum_published = true THEN
    PERFORM award_reputation(NEW.profile_id, 'post_created', NULL, NEW.id, NULL);
  END IF;
  RETURN NEW;
END;
$$;


--
-- Name: trg_record_badge_activity(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.trg_record_badge_activity() RETURNS trigger
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
DECLARE
  v_badge_name TEXT;
BEGIN
  IF TG_OP = 'INSERT' THEN
    SELECT name INTO v_badge_name FROM forum_badges WHERE id = NEW.badge_id;
    
    INSERT INTO forum_activities (profile_id, activity_type, target_badge_id, metadata)
    VALUES (NEW.profile_id, 'badge_earned', NEW.badge_id, jsonb_build_object(
      'badge_name', v_badge_name
    ));
  END IF;
  RETURN NEW;
END;
$$;


--
-- Name: trg_record_comment_activity(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.trg_record_comment_activity() RETURNS trigger
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
DECLARE
  v_post_author UUID;
BEGIN
  IF TG_OP = 'INSERT' THEN
    -- Get post author
    SELECT profile_id INTO v_post_author FROM forum WHERE id = NEW.forum_id;
    
    -- Record comment activity
    INSERT INTO forum_activities (profile_id, activity_type, target_forum_id, target_comment_id, target_profile_id, metadata)
    VALUES (NEW.user_id, 'post_commented', NEW.forum_id, NEW.id, v_post_author, jsonb_build_object(
      'preview', LEFT(NEW.comment, 100)
    ));
    
    -- If replying to another comment
    IF NEW.parent_id IS NOT NULL THEN
      DECLARE
        v_parent_author UUID;
      BEGIN
        SELECT user_id INTO v_parent_author FROM comments WHERE id = NEW.parent_id;
        IF v_parent_author != NEW.user_id THEN
          INSERT INTO forum_activities (profile_id, activity_type, target_forum_id, target_comment_id, target_profile_id)
          VALUES (NEW.user_id, 'comment_replied', NEW.forum_id, NEW.id, v_parent_author);
        END IF;
      END;
    END IF;
  END IF;
  RETURN NEW;
END;
$$;


--
-- Name: trg_record_follow_activity(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.trg_record_follow_activity() RETURNS trigger
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
BEGIN
  IF TG_OP = 'INSERT' THEN
    INSERT INTO forum_activities (profile_id, activity_type, target_profile_id)
    VALUES (NEW.follower_id, 'user_followed', NEW.following_id);
  END IF;
  RETURN NEW;
END;
$$;


--
-- Name: trg_record_post_activity(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.trg_record_post_activity() RETURNS trigger
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
BEGIN
  IF TG_OP = 'INSERT' AND NEW.forum_published = true THEN
    INSERT INTO forum_activities (profile_id, activity_type, target_forum_id, metadata)
    VALUES (NEW.profile_id, 'post_created', NEW.id, jsonb_build_object(
      'title', NEW.forum_post_name,
      'category_id', NEW.category_id
    ));
  END IF;
  RETURN NEW;
END;
$$;


--
-- Name: trigger_check_badges(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.trigger_check_badges() RETURNS trigger
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
BEGIN
  PERFORM public.check_and_award_badges(NEW.profile_id);
  RETURN NEW;
END;
$$;


--
-- Name: trigger_digest_edge_function(text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.trigger_digest_edge_function(p_frequency text) RETURNS bigint
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
DECLARE
  v_request_id bigint;
BEGIN
  -- Make HTTP POST request to the Edge Function using pg_net
  -- Note: verify_jwt = false is set in config.toml, so no auth needed
  SELECT net.http_post(
    url := 'https://***REMOVED***/functions/v1/send-digest-notifications',
    body := jsonb_build_object(
      'frequency', p_frequency,
      'limit', 100
    ),
    headers := jsonb_build_object(
      'Content-Type', 'application/json'
    )
  ) INTO v_request_id;

  RETURN v_request_id;
END;
$$;


--
-- Name: FUNCTION trigger_digest_edge_function(p_frequency text); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.trigger_digest_edge_function(p_frequency text) IS 'Triggers the send-digest-notifications Edge Function for a specific frequency. Called by pg_cron jobs.';


--
-- Name: trigger_email_provider_sync(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.trigger_email_provider_sync() RETURNS bigint
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public', 'net', 'vault'
    AS $$
DECLARE
  v_internal_secret text;
  v_request_id bigint;
BEGIN
  -- Get internal service secret from vault
  SELECT decrypted_secret INTO v_internal_secret
  FROM vault.decrypted_secrets
  WHERE name = 'INTERNAL_SERVICE_SECRET';

  IF v_internal_secret IS NULL THEN
    RAISE WARNING 'INTERNAL_SERVICE_SECRET not found in vault';
    RETURN NULL;
  END IF;

  -- Call the Edge Function with internal secret
  SELECT net.http_post(
    url := 'https://***REMOVED***/functions/v1/api-v1-notifications/admin/providers/sync',
    headers := jsonb_build_object(
      'Content-Type', 'application/json',
      'Authorization', 'Bearer ' || v_internal_secret
    ),
    body := '{"source": "cron"}'::jsonb
  ) INTO v_request_id;

  RETURN v_request_id;
END;
$$;


--
-- Name: trigger_email_queue_processing(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.trigger_email_queue_processing() RETURNS void
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
  v_url text;
  v_service_key text;
BEGIN
  -- Get the Supabase URL and service role key from vault
  v_url := 'https://***REMOVED***/functions/v1/email';
  
  SELECT decrypted_secret INTO v_service_key
  FROM vault.decrypted_secrets
  WHERE name = 'SUPABASE_SERVICE_ROLE_KEY'
  LIMIT 1;
  
  -- If no key in vault, try to use edge function invoke (internal)
  IF v_service_key IS NULL THEN
    -- Use internal service role from environment
    v_service_key := current_setting('app.settings.service_role_key', true);
  END IF;
  
  -- Make HTTP POST request to process queue
  PERFORM net.http_post(
    url := v_url,
    headers := jsonb_build_object(
      'Content-Type', 'application/json',
      'Authorization', 'Bearer ' || COALESCE(v_service_key, '')
    ),
    body := '{"action": "process-queue", "batchSize": 50}'::jsonb
  );
END;
$$;


--
-- Name: trigger_log_post_changes(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.trigger_log_post_changes() RETURNS trigger
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
DECLARE
  v_activity_type TEXT;
  v_previous_state JSONB;
  v_new_state JSONB;
  v_changes JSONB;
BEGIN
  -- Determine activity type based on operation
  CASE TG_OP
    WHEN 'INSERT' THEN
      v_activity_type := 'created';
      v_previous_state := '{}'::JSONB;
      v_new_state := to_jsonb(NEW);
      v_changes := to_jsonb(NEW);
    WHEN 'UPDATE' THEN
      -- Detect specific types of updates
      IF OLD.is_active = true AND NEW.is_active = false THEN
        v_activity_type := 'deactivated';
      ELSIF OLD.is_active = false AND NEW.is_active = true THEN
        v_activity_type := 'activated';
      ELSE
        v_activity_type := 'updated';
      END IF;
      v_previous_state := to_jsonb(OLD);
      v_new_state := to_jsonb(NEW);
      -- Calculate changes (fields that differ)
      SELECT jsonb_object_agg(key, value) INTO v_changes
      FROM (
        SELECT key, to_jsonb(NEW) -> key as value
        FROM jsonb_object_keys(to_jsonb(NEW)) AS key
        WHERE to_jsonb(OLD) -> key IS DISTINCT FROM to_jsonb(NEW) -> key
      ) AS diff;
    WHEN 'DELETE' THEN
      v_activity_type := 'deleted';
      v_previous_state := to_jsonb(OLD);
      v_new_state := '{}'::JSONB;
      v_changes := '{}'::JSONB;
  END CASE;

  -- Insert the activity log
  -- For DELETE, set post_id to NULL since the post is being removed
  INSERT INTO post_activity_logs (
    post_id,
    actor_id,
    activity_type,
    previous_state,
    new_state,
    changes,
    metadata
  ) VALUES (
    CASE TG_OP
      WHEN 'DELETE' THEN NULL  -- Set NULL for deletions
      ELSE COALESCE(NEW.id, OLD.id)
    END,
    CASE TG_OP
      WHEN 'DELETE' THEN OLD.profile_id
      ELSE COALESCE(NEW.profile_id, OLD.profile_id)
    END,
    v_activity_type::post_activity_type,
    v_previous_state,
    v_new_state,
    COALESCE(v_changes, '{}'::JSONB),
    jsonb_build_object(
      'trigger', TG_NAME,
      'operation', TG_OP,
      'table', TG_TABLE_NAME,
      'deleted_post_id', CASE WHEN TG_OP = 'DELETE' THEN OLD.id ELSE NULL END,
      'logged_at', NOW()
    )
  );

  -- Return appropriate value based on operation
  IF TG_OP = 'DELETE' THEN
    RETURN OLD;
  ELSE
    RETURN NEW;
  END IF;
END;
$$;


--
-- Name: trigger_notify_new_post(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.trigger_notify_new_post() RETURNS trigger
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
BEGIN
  -- Call the Edge Function asynchronously via pg_net (fire-and-forget)
  -- No auth needed since verify_jwt = false in config.toml
  PERFORM net.http_post(
    url := 'https://***REMOVED***/functions/v1/notify-new-post',
    headers := jsonb_build_object(
      'Content-Type', 'application/json'
    ),
    body := jsonb_build_object(
      'record', jsonb_build_object(
        'id', NEW.id,
        'post_name', NEW.post_name,
        'post_type', NEW.post_type,
        'post_address', NEW.post_address,
        'post_description', NEW.post_description,
        'profile_id', NEW.profile_id
      )
    )
  );

  RETURN NEW;
EXCEPTION WHEN OTHERS THEN
  -- Log error but don't block the INSERT
  RAISE WARNING 'notify_new_post error: %', SQLERRM;
  RETURN NEW;
END;
$$;


--
-- Name: FUNCTION trigger_notify_new_post(); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.trigger_notify_new_post() IS 'Sends Telegram notification to admin when new posts are created (including volunteer applications)';


--
-- Name: trigger_post_translation(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.trigger_post_translation() RETURNS trigger
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
  v_post_name TEXT;
  v_post_description TEXT;
BEGIN
  IF NEW.is_active = TRUE THEN
    v_post_name := COALESCE(NEW.post_name, '');
    v_post_description := COALESCE(NEW.post_description, '');

    IF LENGTH(v_post_name) > 0 OR LENGTH(v_post_description) > 0 THEN
      PERFORM net.http_post(
        url := current_setting('app.supabase_url') || '/functions/v1/api-v1-localization/translate-batch',
        headers := jsonb_build_object(
          'Content-Type', 'application/json',
          'Authorization', 'Bearer ' || current_setting('app.service_role_key')
        ),
        body := jsonb_build_object(
          'content_type', 'post',
          'content_id', NEW.id::text,
          'fields', jsonb_build_array(
            jsonb_build_object('name', 'title', 'text', v_post_name),
            jsonb_build_object('name', 'description', 'text', v_post_description)
          )
        )
      );

      RAISE LOG 'Triggered translation for post %', NEW.id;
    END IF;
  END IF;

  RETURN NEW;
END;
$$;


--
-- Name: trigger_recalculate_trust_level(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.trigger_recalculate_trust_level() RETURNS trigger
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
BEGIN
  PERFORM calculate_trust_level(NEW.profile_id);
  RETURN NEW;
END;
$$;


--
-- Name: trigger_signup_automation(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.trigger_signup_automation() RETURNS trigger
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
DECLARE
  v_flow record;
BEGIN
  -- Find active signup automation flows
  FOR v_flow IN 
    SELECT id FROM public.email_automation_flows 
    WHERE trigger_type = 'user_signup' AND status = 'active'
  LOOP
    PERFORM public.enroll_user_in_automation(v_flow.id, NEW.id);
  END LOOP;
  
  RETURN NEW;
END;
$$;


--
-- Name: trigger_sync_post_like_counter(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.trigger_sync_post_like_counter() RETURNS trigger
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
DECLARE
    v_post_id INTEGER;
    v_new_count INTEGER;
BEGIN
    IF TG_OP = 'DELETE' THEN
        v_post_id := OLD.post_id;
    ELSE
        v_post_id := NEW.post_id;
    END IF;

    SELECT COUNT(*) INTO v_new_count
    FROM post_likes
    WHERE post_id = v_post_id;

    UPDATE posts
    SET post_like_counter = v_new_count,
        updated_at = NOW()
    WHERE id = v_post_id;

    RETURN COALESCE(NEW, OLD);
END;
$$;


--
-- Name: trigger_translate_challenge(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.trigger_translate_challenge() RETURNS trigger
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
  service_role_key TEXT;
  request_id BIGINT;
BEGIN
  -- Get service role key from vault
  SELECT decrypted_secret INTO service_role_key
  FROM vault.decrypted_secrets
  WHERE name = 'service_role_key'
  LIMIT 1;

  IF service_role_key IS NULL THEN
    service_role_key := current_setting('app.settings.service_role_key', true);
  END IF;

  SELECT net.http_post(
    url := get_edge_function_url() || '/localization/translate-batch',
    headers := jsonb_build_object(
      'Content-Type', 'application/json',
      'Authorization', 'Bearer ' || COALESCE(service_role_key, '')
    ),
    body := jsonb_build_object(
      'content_type', 'challenge',
      'content_id', NEW.id::text,
      'fields', jsonb_build_array(
        jsonb_build_object('name', 'title', 'text', COALESCE(NEW.challenge_title, '')),
        jsonb_build_object('name', 'description', 'text', COALESCE(NEW.challenge_description, ''))
      )
    )
  ) INTO request_id;

  RAISE LOG 'Translation triggered for challenge % (request_id: %)', NEW.id, request_id;
  RETURN NEW;
EXCEPTION WHEN OTHERS THEN
  RAISE WARNING 'Translation trigger failed for challenge %: %', NEW.id, SQLERRM;
  RETURN NEW;
END;
$$;


--
-- Name: FUNCTION trigger_translate_challenge(); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.trigger_translate_challenge() IS 'Triggers async translation of challenge content to all supported locales';


--
-- Name: trigger_translate_forum_post(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.trigger_translate_forum_post() RETURNS trigger
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
  service_role_key TEXT;
  request_id BIGINT;
BEGIN
  -- Get service role key from vault
  SELECT decrypted_secret INTO service_role_key
  FROM vault.decrypted_secrets
  WHERE name = 'service_role_key'
  LIMIT 1;

  IF service_role_key IS NULL THEN
    service_role_key := current_setting('app.settings.service_role_key', true);
  END IF;

  SELECT net.http_post(
    url := get_edge_function_url() || '/localization/translate-batch',
    headers := jsonb_build_object(
      'Content-Type', 'application/json',
      'Authorization', 'Bearer ' || COALESCE(service_role_key, '')
    ),
    body := jsonb_build_object(
      'content_type', 'forum_post',
      'content_id', NEW.id::text,
      'fields', jsonb_build_array(
        jsonb_build_object('name', 'title', 'text', COALESCE(NEW.forum_post_name, '')),
        jsonb_build_object('name', 'description', 'text', COALESCE(NEW.forum_post_description, ''))
      )
    )
  ) INTO request_id;

  RAISE LOG 'Translation triggered for forum post % (request_id: %)', NEW.id, request_id;
  RETURN NEW;
EXCEPTION WHEN OTHERS THEN
  RAISE WARNING 'Translation trigger failed for forum post %: %', NEW.id, SQLERRM;
  RETURN NEW;
END;
$$;


--
-- Name: FUNCTION trigger_translate_forum_post(); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.trigger_translate_forum_post() IS 'Triggers async translation of forum post content to all supported locales';


--
-- Name: trigger_translate_post(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.trigger_translate_post() RETURNS trigger
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
  service_role_key TEXT;
  request_id BIGINT;
BEGIN
  -- Get service role key from vault
  SELECT decrypted_secret INTO service_role_key
  FROM vault.decrypted_secrets
  WHERE name = 'service_role_key'
  LIMIT 1;

  -- Skip if no key found (fallback to env)
  IF service_role_key IS NULL THEN
    service_role_key := current_setting('app.settings.service_role_key', true);
  END IF;

  -- Call translate-batch edge function (fire-and-forget)
  SELECT net.http_post(
    url := get_edge_function_url() || '/localization/translate-batch',
    headers := jsonb_build_object(
      'Content-Type', 'application/json',
      'Authorization', 'Bearer ' || COALESCE(service_role_key, '')
    ),
    body := jsonb_build_object(
      'content_type', 'post',
      'content_id', NEW.id::text,
      'fields', jsonb_build_array(
        jsonb_build_object('name', 'title', 'text', COALESCE(NEW.post_name, '')),
        jsonb_build_object('name', 'description', 'text', COALESCE(NEW.post_description, ''))
      )
    )
  ) INTO request_id;

  RAISE LOG 'Translation triggered for post % (request_id: %)', NEW.id, request_id;
  RETURN NEW;
EXCEPTION WHEN OTHERS THEN
  -- Log error but don't fail the transaction
  RAISE WARNING 'Translation trigger failed for post %: %', NEW.id, SQLERRM;
  RETURN NEW;
END;
$$;


--
-- Name: FUNCTION trigger_translate_post(); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.trigger_translate_post() IS 'Triggers async translation of post content to all supported locales';


--
-- Name: trigger_update_coordinates(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.trigger_update_coordinates() RETURNS trigger
    LANGUAGE plpgsql
    SET search_path TO 'public'
    AS $$
BEGIN
  IF NEW.post_address IS DISTINCT FROM OLD.post_address THEN
    PERFORM public.queue_location_update(NEW.id);
  END IF;
  RETURN NEW;
END;
$$;


--
-- Name: trigger_update_user_rating(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.trigger_update_user_rating() RETURNS trigger
    LANGUAGE plpgsql
    SET search_path TO 'public'
    AS $$
BEGIN
  PERFORM public.update_user_rating(COALESCE(NEW.profile_id, OLD.profile_id));
  RETURN COALESCE(NEW, OLD);
END;
$$;


--
-- Name: unblock_user(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.unblock_user(p_blocked_id uuid) RETURNS boolean
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
BEGIN
  DELETE FROM forum_user_blocks
  WHERE blocker_id = auth.uid()
    AND blocked_id = p_blocked_id;
  
  RETURN FOUND;
END;
$$;


--
-- Name: update_all_hot_scores(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_all_hot_scores() RETURNS integer
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
DECLARE
  v_updated_count INTEGER;
BEGIN
  WITH updated AS (
    UPDATE forum f
    SET hot_score = calculate_hot_score(
      f.forum_likes_counter,
      f.forum_comments_counter::INTEGER,
      COALESCE((f.reactions_count->>'total')::INTEGER, 0),
      f.views_count,
      f.forum_post_created_at
    )
    WHERE f.forum_published = true
    RETURNING 1
  )
  SELECT COUNT(*) INTO v_updated_count FROM updated;
  
  RETURN v_updated_count;
END;
$$;


--
-- Name: update_app_config_updated_at(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_app_config_updated_at() RETURNS trigger
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
BEGIN
  NEW.updated_at = now();
  RETURN NEW;
END;
$$;


--
-- Name: update_avatar_url_on_storage_upload(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_avatar_url_on_storage_upload() RETURNS trigger
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO ''
    AS $$
DECLARE
  profile_id uuid;
  public_url text;
BEGIN
  -- Only process uploads to 'profiles' bucket
  IF NEW.bucket_id = 'profiles' THEN
    -- Extract profile_id from path (format: {profile_id}/avatar.ext)
    BEGIN
      profile_id := (split_part(NEW.name, '/', 1))::uuid;
    EXCEPTION WHEN OTHERS THEN
      -- If path doesn't start with valid UUID, skip
      RETURN NEW;
    END;
    
    -- Construct the full public URL
    -- Format: https://{project}.supabase.co/storage/v1/object/public/{bucket}/{path}
    public_url := 'https://***REMOVED***/storage/v1/object/public/profiles/' || NEW.name;
    
    -- Update the profile's avatar_url with the full public URL
    UPDATE public.profiles
    SET 
      avatar_url = public_url,
      updated_at = NOW()
    WHERE id = profile_id;
  END IF;
  
  RETURN NEW;
END;
$$;


--
-- Name: FUNCTION update_avatar_url_on_storage_upload(); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.update_avatar_url_on_storage_upload() IS 'Automatically updates profiles.avatar_url with full public URL when a file is uploaded to the profiles storage bucket. 
Expects file path format: {profile_id}/filename';


--
-- Name: update_bookmark_collection_count(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_bookmark_collection_count() RETURNS trigger
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
BEGIN
  IF TG_OP = 'INSERT' AND NEW.collection_id IS NOT NULL THEN
    UPDATE forum_bookmark_collections
    SET bookmarks_count = bookmarks_count + 1, updated_at = now()
    WHERE id = NEW.collection_id;
  ELSIF TG_OP = 'DELETE' AND OLD.collection_id IS NOT NULL THEN
    UPDATE forum_bookmark_collections
    SET bookmarks_count = GREATEST(bookmarks_count - 1, 0), updated_at = now()
    WHERE id = OLD.collection_id;
  ELSIF TG_OP = 'UPDATE' AND OLD.collection_id IS DISTINCT FROM NEW.collection_id THEN
    IF OLD.collection_id IS NOT NULL THEN
      UPDATE forum_bookmark_collections
      SET bookmarks_count = GREATEST(bookmarks_count - 1, 0), updated_at = now()
      WHERE id = OLD.collection_id;
    END IF;
    IF NEW.collection_id IS NOT NULL THEN
      UPDATE forum_bookmark_collections
      SET bookmarks_count = bookmarks_count + 1, updated_at = now()
      WHERE id = NEW.collection_id;
    END IF;
  END IF;
  
  RETURN COALESCE(NEW, OLD);
END;
$$;


--
-- Name: update_category_posts_count(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_category_posts_count() RETURNS trigger
    LANGUAGE plpgsql
    SET search_path TO 'public'
    AS $$
BEGIN
  IF TG_OP = 'INSERT' THEN
    UPDATE public.forum_categories
    SET posts_count = posts_count + 1
    WHERE id = NEW.category_id;
    RETURN NEW;
  ELSIF TG_OP = 'DELETE' THEN
    UPDATE public.forum_categories
    SET posts_count = GREATEST(posts_count - 1, 0)
    WHERE id = OLD.category_id;
    RETURN OLD;
  ELSIF TG_OP = 'UPDATE' AND OLD.category_id IS DISTINCT FROM NEW.category_id THEN
    -- Decrement old category
    IF OLD.category_id IS NOT NULL THEN
      UPDATE public.forum_categories
      SET posts_count = GREATEST(posts_count - 1, 0)
      WHERE id = OLD.category_id;
    END IF;
    -- Increment new category
    IF NEW.category_id IS NOT NULL THEN
      UPDATE public.forum_categories
      SET posts_count = posts_count + 1
      WHERE id = NEW.category_id;
    END IF;
    RETURN NEW;
  END IF;
  RETURN NULL;
END;
$$;


--
-- Name: update_circuit_breaker_state(text, text, integer, integer, timestamp with time zone, timestamp with time zone); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_circuit_breaker_state(p_provider text, p_state text, p_failures integer DEFAULT NULL::integer, p_consecutive_successes integer DEFAULT NULL::integer, p_last_failure_time timestamp with time zone DEFAULT NULL::timestamp with time zone, p_next_retry_time timestamp with time zone DEFAULT NULL::timestamp with time zone) RETURNS void
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO ''
    AS $$
BEGIN
  UPDATE email_circuit_breaker_state
  SET
    state = p_state,
    failures = COALESCE(p_failures, failures),
    consecutive_successes = COALESCE(p_consecutive_successes, consecutive_successes),
    last_failure_time = COALESCE(p_last_failure_time, last_failure_time),
    next_retry_time = COALESCE(p_next_retry_time, next_retry_time),
    updated_at = NOW()
  WHERE provider = p_provider;
END;
$$;


--
-- Name: update_comment_likes_count(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_comment_likes_count() RETURNS trigger
    LANGUAGE plpgsql
    SET search_path TO ''
    AS $$
BEGIN
  IF TG_OP = 'INSERT' THEN
    UPDATE public.comments
    SET likes_count = likes_count + 1
    WHERE id = NEW.comment_id;
    RETURN NEW;
  ELSIF TG_OP = 'DELETE' THEN
    UPDATE public.comments
    SET likes_count = GREATEST(likes_count - 1, 0)
    WHERE id = OLD.comment_id;
    RETURN OLD;
  END IF;
  RETURN NULL;
END;
$$;


--
-- Name: update_comment_reactions_count(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_comment_reactions_count() RETURNS trigger
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
DECLARE
  v_comment_id INTEGER;
  v_counts JSONB;
BEGIN
  v_comment_id := COALESCE(NEW.comment_id, OLD.comment_id);
  
  -- Calculate new counts
  SELECT jsonb_object_agg(
    rt.name,
    COALESCE(counts.cnt, 0)
  ) INTO v_counts
  FROM reaction_types rt
  LEFT JOIN (
    SELECT reaction_type_id, COUNT(*)::INTEGER AS cnt
    FROM forum_comment_reactions
    WHERE comment_id = v_comment_id
    GROUP BY reaction_type_id
  ) counts ON counts.reaction_type_id = rt.id;
  
  -- Update comment
  UPDATE comments
  SET reactions_count = COALESCE(v_counts, '{}'::jsonb)
  WHERE id = v_comment_id;
  
  -- Update user stats for reactions received
  IF TG_OP = 'INSERT' THEN
    UPDATE forum_user_stats
    SET reactions_received = reactions_received + 1,
        updated_at = now()
    WHERE profile_id = (SELECT user_id FROM comments WHERE id = v_comment_id);
  ELSIF TG_OP = 'DELETE' THEN
    UPDATE forum_user_stats
    SET reactions_received = GREATEST(reactions_received - 1, 0),
        updated_at = now()
    WHERE profile_id = (SELECT user_id FROM comments WHERE id = v_comment_id);
  END IF;
  
  RETURN COALESCE(NEW, OLD);
END;
$$;


--
-- Name: update_daily_stats(date); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_daily_stats(p_date date DEFAULT CURRENT_DATE) RETURNS void
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
DECLARE
  v_new_users integer;
  v_active_users integer;
  v_new_listings integer;
  v_completed_shares integer;
  v_messages_sent integer;
  v_notifications_sent integer;
BEGIN
  -- Count new users (using created_time from profiles)
  SELECT COUNT(*) INTO v_new_users
  FROM profiles
  WHERE DATE(created_time) = p_date
    AND is_active = true;

  -- Count active users (any activity)
  SELECT COUNT(DISTINCT user_id) INTO v_active_users
  FROM user_activity_summary
  WHERE DATE(last_activity_at) = p_date;

  -- Count new listings
  SELECT COUNT(*) INTO v_new_listings
  FROM posts
  WHERE DATE(created_at) = p_date;

  -- Count completed shares (posts marked as inactive with is_arranged = true)
  SELECT COUNT(*) INTO v_completed_shares
  FROM posts
  WHERE DATE(updated_at) = p_date
    AND is_active = false
    AND is_arranged = true;

  -- Count notifications sent (using user_notifications table)
  SELECT COUNT(*) INTO v_notifications_sent
  FROM user_notifications
  WHERE DATE(created_at) = p_date;

  -- Upsert daily stats
  INSERT INTO daily_stats (
    date, new_users, active_users, new_listings,
    completed_shares, notifications_sent, computed_at
  ) VALUES (
    p_date, v_new_users, v_active_users, v_new_listings,
    v_completed_shares, v_notifications_sent, NOW()
  )
  ON CONFLICT (date) DO UPDATE SET
    new_users = EXCLUDED.new_users,
    active_users = EXCLUDED.active_users,
    new_listings = EXCLUDED.new_listings,
    completed_shares = EXCLUDED.completed_shares,
    notifications_sent = EXCLUDED.notifications_sent,
    computed_at = NOW();
END;
$$;


--
-- Name: FUNCTION update_daily_stats(p_date date); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.update_daily_stats(p_date date) IS 'Computes daily platform statistics';


--
-- Name: update_device_attestations_updated_at(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_device_attestations_updated_at() RETURNS trigger
    LANGUAGE plpgsql
    SET search_path TO 'public'
    AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$;


--
-- Name: update_device_tokens_updated_at(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_device_tokens_updated_at() RETURNS trigger
    LANGUAGE plpgsql
    SET search_path TO ''
    AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$;


--
-- Name: update_display_name_override_updated_at(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_display_name_override_updated_at() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
  NEW.updated_at = now();
  RETURN NEW;
END;
$$;


--
-- Name: update_email_delivery_log_updated_at(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_email_delivery_log_updated_at() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
  NEW.updated_at = now();
  RETURN NEW;
END;
$$;


--
-- Name: update_email_delivery_status(text, text, jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_email_delivery_status(p_message_id text, p_status text, p_metadata jsonb DEFAULT '{}'::jsonb) RETURNS boolean
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
DECLARE
  v_updated boolean := false;
BEGIN
  -- Validate status
  IF p_status NOT IN ('sent', 'delivered', 'opened', 'clicked', 'bounced', 'complained', 'failed') THEN
    RAISE EXCEPTION 'Invalid status: %', p_status;
  END IF;

  UPDATE email_delivery_log
  SET
    status = p_status,
    sent_at = CASE WHEN p_status = 'sent' AND sent_at IS NULL THEN now() ELSE sent_at END,
    delivered_at = CASE WHEN p_status = 'delivered' AND delivered_at IS NULL THEN now() ELSE delivered_at END,
    opened_at = CASE WHEN p_status IN ('opened', 'clicked') AND opened_at IS NULL THEN now() ELSE opened_at END,
    clicked_at = CASE WHEN p_status = 'clicked' AND clicked_at IS NULL THEN now() ELSE clicked_at END,
    error_code = CASE WHEN p_status IN ('bounced', 'failed') THEN p_metadata->>'errorCode' ELSE error_code END,
    error_message = CASE WHEN p_status IN ('bounced', 'failed') THEN p_metadata->>'errorMessage' ELSE error_message END,
    metadata = metadata || p_metadata,
    updated_at = now()
  WHERE message_id = p_message_id
  RETURNING true INTO v_updated;

  RETURN COALESCE(v_updated, false);
END;
$$;


--
-- Name: FUNCTION update_email_delivery_status(p_message_id text, p_status text, p_metadata jsonb); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.update_email_delivery_status(p_message_id text, p_status text, p_metadata jsonb) IS 'Updates email status from webhook events';


--
-- Name: update_email_preferences_updated_at(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_email_preferences_updated_at() RETURNS trigger
    LANGUAGE plpgsql
    SET search_path TO ''
    AS $$
BEGIN
  NEW.updated_at = now();
  RETURN NEW;
END;
$$;


--
-- Name: update_email_provider_delivery_stats(text, text, date); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_email_provider_delivery_stats(p_provider text, p_status text, p_date date DEFAULT CURRENT_DATE) RETURNS void
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
BEGIN
  INSERT INTO email_provider_stats (provider, date)
  VALUES (p_provider, p_date)
  ON CONFLICT (provider, date) DO UPDATE SET
    emails_delivered = email_provider_stats.emails_delivered + CASE WHEN p_status = 'delivered' THEN 1 ELSE 0 END,
    emails_opened = email_provider_stats.emails_opened + CASE WHEN p_status = 'opened' THEN 1 ELSE 0 END,
    emails_clicked = email_provider_stats.emails_clicked + CASE WHEN p_status = 'clicked' THEN 1 ELSE 0 END,
    emails_bounced = email_provider_stats.emails_bounced + CASE WHEN p_status = 'bounced' THEN 1 ELSE 0 END,
    emails_complained = email_provider_stats.emails_complained + CASE WHEN p_status = 'complained' THEN 1 ELSE 0 END,
    updated_at = now();
END;
$$;


--
-- Name: FUNCTION update_email_provider_delivery_stats(p_provider text, p_status text, p_date date); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.update_email_provider_delivery_stats(p_provider text, p_status text, p_date date) IS 'Called by webhook handler to track delivery events per provider';


--
-- Name: update_email_provider_quota_updated_at(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_email_provider_quota_updated_at() RETURNS trigger
    LANGUAGE plpgsql
    SET search_path TO ''
    AS $$
BEGIN
  NEW.updated_at = now();
  RETURN NEW;
END;
$$;


--
-- Name: update_email_queue_updated_at(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_email_queue_updated_at() RETURNS trigger
    LANGUAGE plpgsql
    SET search_path TO ''
    AS $$
BEGIN
  NEW.updated_at = now();
  RETURN NEW;
END;
$$;


--
-- Name: update_feature_flags_updated_at(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_feature_flags_updated_at() RETURNS trigger
    LANGUAGE plpgsql
    SET search_path TO 'public'
    AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$;


--
-- Name: update_feedback_updated_at(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_feedback_updated_at() RETURNS trigger
    LANGUAGE plpgsql
    SET search_path TO ''
    AS $$
BEGIN
  NEW.updated_at = now();
  RETURN NEW;
END;
$$;


--
-- Name: update_follow_counts(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_follow_counts() RETURNS trigger
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
BEGIN
  IF TG_OP = 'INSERT' THEN
    -- Update following count for follower
    PERFORM public.ensure_forum_user_stats(NEW.follower_id);
    UPDATE public.forum_user_stats
    SET following_count = following_count + 1, updated_at = now()
    WHERE profile_id = NEW.follower_id;
    
    -- Update followers count for followed user
    PERFORM public.ensure_forum_user_stats(NEW.following_id);
    UPDATE public.forum_user_stats
    SET followers_count = followers_count + 1, updated_at = now()
    WHERE profile_id = NEW.following_id;
    
  ELSIF TG_OP = 'DELETE' THEN
    UPDATE public.forum_user_stats
    SET following_count = GREATEST(0, following_count - 1), updated_at = now()
    WHERE profile_id = OLD.follower_id;
    
    UPDATE public.forum_user_stats
    SET followers_count = GREATEST(0, followers_count - 1), updated_at = now()
    WHERE profile_id = OLD.following_id;
  END IF;
  
  RETURN COALESCE(NEW, OLD);
END;
$$;


--
-- Name: update_forum_last_activity(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_forum_last_activity() RETURNS trigger
    LANGUAGE plpgsql
    SET search_path TO 'public'
    AS $$
BEGIN
  UPDATE public.forum
  SET last_activity_at = now()
  WHERE id = NEW.forum_id;
  RETURN NEW;
END;
$$;


--
-- Name: update_forum_reactions_count(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_forum_reactions_count() RETURNS trigger
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
DECLARE
  v_forum_id BIGINT;
  v_counts JSONB;
BEGIN
  -- Get the forum_id based on operation
  IF TG_OP = 'DELETE' THEN
    v_forum_id := OLD.forum_id;
  ELSE
    v_forum_id := NEW.forum_id;
  END IF;
  
  -- Calculate reaction counts
  SELECT jsonb_object_agg(rt.name, COALESCE(counts.cnt, 0))
  INTO v_counts
  FROM public.reaction_types rt
  LEFT JOIN (
    SELECT reaction_type_id, COUNT(*) as cnt
    FROM public.forum_reactions
    WHERE forum_id = v_forum_id
    GROUP BY reaction_type_id
  ) counts ON rt.id = counts.reaction_type_id;
  
  -- Update the forum post
  UPDATE public.forum
  SET reactions_count = COALESCE(v_counts, '{}'::jsonb)
  WHERE id = v_forum_id;
  
  RETURN COALESCE(NEW, OLD);
END;
$$;


--
-- Name: update_forum_search_vector(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_forum_search_vector() RETURNS trigger
    LANGUAGE plpgsql
    SET search_path TO 'public'
    AS $$
BEGIN
  NEW.search_vector := 
    setweight(to_tsvector('english', COALESCE(NEW.forum_post_name, '')), 'A') ||
    setweight(to_tsvector('english', COALESCE(NEW.forum_post_description, '')), 'B');
  RETURN NEW;
END;
$$;


--
-- Name: update_generated_full_address(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_generated_full_address() RETURNS trigger
    LANGUAGE plpgsql
    SET search_path TO 'public'
    AS $$
BEGIN
  NEW.generated_full_address = CONCAT_WS(', ',
    NULLIF(NEW.address_line_1, ''),
    NULLIF(NEW.address_line_2, ''),
    NULLIF(NEW.address_line_3, ''),
    NULLIF(NEW.city, ''),
    NULLIF(NEW.state_province, ''),
    NULLIF(NEW.postal_code, ''),
    NULLIF(NEW.country, '')
  );
  RETURN NEW;
END;
$$;


--
-- Name: update_last_seen(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_last_seen() RETURNS void
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
BEGIN
  UPDATE public.profiles
  SET last_seen_at = NOW()
  WHERE id = auth.uid();
END;
$$;


--
-- Name: update_lat_lon(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_lat_lon() RETURNS trigger
    LANGUAGE plpgsql
    SET search_path TO 'public'
    AS $$
BEGIN
  IF NEW.latitude IS NOT NULL AND NEW.longitude IS NOT NULL THEN
    NEW.location = ST_SetSRID(ST_MakePoint(NEW.longitude, NEW.latitude), 4326);
  END IF;
  RETURN NEW;
END;
$$;


--
-- Name: update_listing_transactional(integer, text, text, boolean, text, text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_listing_transactional(p_listing_id integer, p_title text DEFAULT NULL::text, p_description text DEFAULT NULL::text, p_is_active boolean DEFAULT NULL::boolean, p_pickup_address text DEFAULT NULL::text, p_pickup_time text DEFAULT NULL::text) RETURNS jsonb
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO ''
    AS $$
DECLARE
    v_validation JSONB;
    v_existing RECORD;
    v_result JSONB;
BEGIN
    SELECT * INTO v_existing FROM public.posts WHERE id = p_listing_id;

    IF v_existing IS NULL THEN
        RETURN jsonb_build_object('success', false, 'error', jsonb_build_object('code', 'RESOURCE_NOT_FOUND', 'message', 'Listing not found'), 'listing', NULL);
    END IF;

    IF v_existing.profile_id != auth.uid() THEN
        RETURN jsonb_build_object('success', false, 'error', jsonb_build_object('code', 'AUTH_FORBIDDEN', 'message', 'You can only update your own listings'), 'listing', NULL);
    END IF;

    v_validation := public.validate_listing_update(p_listing_id, p_title, p_description, p_is_active, NULL);

    IF NOT (v_validation->>'valid')::BOOLEAN THEN
        RETURN jsonb_build_object('success', false, 'error', jsonb_build_object('code', 'VALIDATION_ERROR', 'message', 'Update validation failed', 'details', v_validation->'errors'), 'listing', NULL);
    END IF;

    UPDATE public.posts SET
        post_name = COALESCE(NULLIF(TRIM(p_title), ''), post_name),
        post_description = CASE WHEN p_description IS NOT NULL THEN NULLIF(TRIM(p_description), '') ELSE post_description END,
        is_active = COALESCE(p_is_active, is_active),
        post_address = CASE WHEN p_pickup_address IS NOT NULL THEN NULLIF(TRIM(p_pickup_address), '') ELSE post_address END,
        pickup_time = CASE WHEN p_pickup_time IS NOT NULL THEN NULLIF(TRIM(p_pickup_time), '') ELSE pickup_time END,
        updated_at = now()
    WHERE id = p_listing_id;

    INSERT INTO public.post_activity_logs (post_id, actor_id, activity_type, metadata)
    VALUES (p_listing_id, auth.uid(), 'updated', jsonb_build_object('fields_updated', jsonb_strip_nulls(jsonb_build_object('title', p_title, 'description', p_description, 'is_active', p_is_active))));

    SELECT jsonb_build_object('success', true, 'error', NULL, 'listing', jsonb_build_object('id', p.id, 'profileId', p.profile_id, 'postName', p.post_name, 'postDescription', p.post_description, 'postType', p.post_type, 'images', p.images, 'latitude', p.latitude, 'longitude', p.longitude, 'postAddress', p.post_address, 'pickupTime', p.pickup_time, 'isActive', p.is_active, 'isArranged', p.is_arranged, 'createdAt', p.created_at, 'updatedAt', p.updated_at))
    INTO v_result FROM public.posts p WHERE p.id = p_listing_id;

    RETURN v_result;
END;
$$;


--
-- Name: update_location_queue_updated_at(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_location_queue_updated_at() RETURNS trigger
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO ''
    AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$;


--
-- Name: update_moderation_queue_updated_at(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_moderation_queue_updated_at() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$;


--
-- Name: update_my_profile(uuid, jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_my_profile(p_user_id uuid, p_updates jsonb) RETURNS jsonb
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
DECLARE
  v_profile record;
BEGIN
  -- Update allowed fields only
  UPDATE profiles SET
    username = COALESCE(p_updates->>'username', username),
    bio = COALESCE(p_updates->>'bio', bio),
    avatar_url = COALESCE(p_updates->>'avatarUrl', avatar_url),
    dietary_preferences = COALESCE(p_updates->'dietaryPreferences', dietary_preferences),
    updated_at = NOW()
  WHERE id = p_user_id
    AND deleted_at IS NULL
  RETURNING * INTO v_profile;

  IF v_profile IS NULL THEN
    RETURN jsonb_build_object(
      'success', false,
      'error', jsonb_build_object('code', 'NOT_FOUND', 'message', 'Profile not found')
    );
  END IF;

  RETURN jsonb_build_object(
    'success', true,
    'profile', jsonb_build_object(
      'id', v_profile.id,
      'username', v_profile.username,
      'bio', v_profile.bio,
      'avatarUrl', v_profile.avatar_url,
      'dietaryPreferences', v_profile.dietary_preferences,
      'updatedAt', v_profile.updated_at
    ),
    'meta', jsonb_build_object('timestamp', NOW())
  );
END;
$$;


--
-- Name: FUNCTION update_my_profile(p_user_id uuid, p_updates jsonb); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.update_my_profile(p_user_id uuid, p_updates jsonb) IS 'Updates user profile fields';


--
-- Name: update_notification_preference(uuid, text, text, boolean, text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_notification_preference(p_user_id uuid, p_category text, p_channel text, p_enabled boolean DEFAULT NULL::boolean, p_frequency text DEFAULT NULL::text) RETURNS jsonb
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
BEGIN
  -- Initialize if needed
  PERFORM init_notification_preferences(p_user_id);

  -- Update preference
  UPDATE notification_preferences
  SET
    enabled = COALESCE(p_enabled, enabled),
    frequency = COALESCE(p_frequency, frequency),
    updated_at = now()
  WHERE user_id = p_user_id
    AND category = p_category::notification_category
    AND channel = p_channel::notification_channel;

  IF NOT FOUND THEN
    RETURN jsonb_build_object('success', false, 'error', 'preference_not_found');
  END IF;

  RETURN jsonb_build_object('success', true);
END;
$$;


--
-- Name: update_notification_settings(uuid, jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_notification_settings(p_user_id uuid, p_settings jsonb) RETURNS jsonb
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
BEGIN
  -- Initialize if needed
  PERFORM init_notification_preferences(p_user_id);

  -- Update settings
  UPDATE notification_settings
  SET
    push_enabled = COALESCE((p_settings->>'push_enabled')::boolean, push_enabled),
    email_enabled = COALESCE((p_settings->>'email_enabled')::boolean, email_enabled),
    sms_enabled = COALESCE((p_settings->>'sms_enabled')::boolean, sms_enabled),
    phone_number = COALESCE(p_settings->>'phone_number', phone_number),
    quiet_hours_enabled = COALESCE((p_settings->'quiet_hours'->>'enabled')::boolean, quiet_hours_enabled),
    quiet_hours_start = COALESCE((p_settings->'quiet_hours'->>'start')::time, quiet_hours_start),
    quiet_hours_end = COALESCE((p_settings->'quiet_hours'->>'end')::time, quiet_hours_end),
    timezone = COALESCE(p_settings->'quiet_hours'->>'timezone', timezone),
    daily_digest_enabled = COALESCE((p_settings->'digest'->>'daily_enabled')::boolean, daily_digest_enabled),
    daily_digest_time = COALESCE((p_settings->'digest'->>'daily_time')::time, daily_digest_time),
    weekly_digest_enabled = COALESCE((p_settings->'digest'->>'weekly_enabled')::boolean, weekly_digest_enabled),
    weekly_digest_day = COALESCE((p_settings->'digest'->>'weekly_day')::int, weekly_digest_day),
    dnd_enabled = COALESCE((p_settings->'dnd'->>'enabled')::boolean, dnd_enabled),
    dnd_until = COALESCE((p_settings->'dnd'->>'until')::timestamptz, dnd_until),
    updated_at = now()
  WHERE user_id = p_user_id;

  RETURN jsonb_build_object('success', true);
END;
$$;


--
-- Name: update_post_hot_score(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_post_hot_score() RETURNS trigger
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
BEGIN
  NEW.hot_score := calculate_hot_score(
    NEW.forum_likes_counter,
    NEW.forum_comments_counter::INTEGER,
    COALESCE((NEW.reactions_count->>'total')::INTEGER, 0),
    NEW.views_count,
    NEW.forum_post_created_at
  );
  RETURN NEW;
END;
$$;


--
-- Name: update_post_reports_updated_at(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_post_reports_updated_at() RETURNS trigger
    LANGUAGE plpgsql
    SET search_path TO ''
    AS $$
BEGIN
  NEW.updated_at = now();
  RETURN NEW;
END;
$$;


--
-- Name: update_post_views(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_post_views() RETURNS trigger
    LANGUAGE plpgsql
    SET search_path TO 'public'
    AS $$
BEGIN
  UPDATE public.posts
  SET post_views = post_views + 1
  WHERE id = NEW.post_id;
  RETURN NEW;
END;
$$;


--
-- Name: update_report_counts(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_report_counts() RETURNS trigger
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
BEGIN
  IF TG_OP = 'INSERT' THEN
    IF NEW.forum_id IS NOT NULL THEN
      UPDATE public.forum 
      SET reports_count = reports_count + 1 
      WHERE id = NEW.forum_id;
    ELSIF NEW.comment_id IS NOT NULL THEN
      UPDATE public.comments 
      SET reports_count = reports_count + 1 
      WHERE id = NEW.comment_id;
    END IF;
  END IF;
  
  RETURN NEW;
END;
$$;


--
-- Name: update_report_timestamp(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_report_timestamp() RETURNS trigger
    LANGUAGE plpgsql
    SET search_path TO ''
    AS $$
BEGIN
  NEW.updated_at = now();
  RETURN NEW;
END;
$$;


--
-- Name: update_reputation_level(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_reputation_level(p_profile_id uuid) RETURNS void
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
DECLARE
  v_total_points INTEGER;
  v_new_level INTEGER;
  v_new_title TEXT;
BEGIN
  SELECT total_points INTO v_total_points FROM forum_user_reputation WHERE profile_id = p_profile_id;
  SELECT level, title INTO v_new_level, v_new_title FROM forum_reputation_levels WHERE min_points <= COALESCE(v_total_points, 0) ORDER BY min_points DESC LIMIT 1;
  UPDATE forum_user_reputation SET reputation_level = v_new_level, level_title = v_new_title WHERE profile_id = p_profile_id;
END;
$$;


--
-- Name: update_room_last_message(uuid, text, uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_room_last_message(p_room_id uuid, p_message text, p_sent_by uuid) RETURNS void
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public', 'pg_temp'
    AS $$
BEGIN
    UPDATE rooms
    SET 
        last_message = p_message,
        last_message_time = NOW(),
        last_message_sent_by = p_sent_by
    WHERE id = p_room_id;
END;
$$;


--
-- Name: update_room_on_new_message(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_room_on_new_message() RETURNS trigger
    LANGUAGE plpgsql
    SET search_path TO 'public'
    AS $$
BEGIN
  UPDATE public.rooms
  SET last_message = NEW.text,
      last_message_time = NEW.timestamp,
      last_message_sent_by = NEW.profile_id
  WHERE id = NEW.room_id::uuid;
  
  RETURN NEW;
END;
$$;


--
-- Name: update_scheduled_post(uuid, text, text, timestamp with time zone, integer, integer[]); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_scheduled_post(p_scheduled_id uuid, p_title text DEFAULT NULL::text, p_description text DEFAULT NULL::text, p_scheduled_for timestamp with time zone DEFAULT NULL::timestamp with time zone, p_category_id integer DEFAULT NULL::integer, p_tags integer[] DEFAULT NULL::integer[]) RETURNS boolean
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
BEGIN
  -- Verify ownership and status
  IF NOT EXISTS (
    SELECT 1 FROM forum_scheduled_posts 
    WHERE id = p_scheduled_id 
      AND profile_id = auth.uid() 
      AND status = 'scheduled'
  ) THEN
    RETURN false;
  END IF;
  
  -- Validate new scheduled time if provided
  IF p_scheduled_for IS NOT NULL AND p_scheduled_for <= now() THEN
    RAISE EXCEPTION 'Scheduled time must be in the future';
  END IF;
  
  -- Update the scheduled post
  UPDATE forum_scheduled_posts
  SET 
    title = COALESCE(p_title, title),
    description = COALESCE(p_description, description),
    scheduled_for = COALESCE(p_scheduled_for, scheduled_for),
    category_id = COALESCE(p_category_id, category_id),
    tags = COALESCE(p_tags, tags),
    updated_at = now()
  WHERE id = p_scheduled_id;
  
  -- Update queue if scheduled time changed
  IF p_scheduled_for IS NOT NULL THEN
    UPDATE forum_publication_queue
    SET scheduled_for = p_scheduled_for
    WHERE scheduled_post_id = p_scheduled_id AND status = 'pending';
  END IF;
  
  RETURN true;
END;
$$;


--
-- Name: update_series_stats(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_series_stats() RETURNS trigger
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
BEGIN
  IF TG_OP = 'INSERT' OR TG_OP = 'UPDATE' THEN
    UPDATE forum_series s SET
      total_views = COALESCE((
        SELECT SUM(f.views_count) 
        FROM forum_series_posts sp 
        JOIN forum f ON sp.forum_id = f.id 
        WHERE sp.series_id = NEW.series_id
      ), 0),
      total_likes = COALESCE((
        SELECT SUM(f.forum_likes_counter) 
        FROM forum_series_posts sp 
        JOIN forum f ON sp.forum_id = f.id 
        WHERE sp.series_id = NEW.series_id
      ), 0),
      updated_at = now()
    WHERE s.id = NEW.series_id;
    RETURN NEW;
  ELSIF TG_OP = 'DELETE' THEN
    UPDATE forum_series SET
      posts_count = posts_count - 1,
      updated_at = now()
    WHERE id = OLD.series_id;
    RETURN OLD;
  END IF;
  RETURN NULL;
END;
$$;


--
-- Name: update_sync_version(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_sync_version() RETURNS trigger
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
BEGIN
  NEW.sync_version := nextval('sync_version_seq');
  RETURN NEW;
END;
$$;


--
-- Name: update_tag_usage_count(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_tag_usage_count() RETURNS trigger
    LANGUAGE plpgsql
    SET search_path TO ''
    AS $$
BEGIN
  IF TG_OP = 'INSERT' THEN
    UPDATE public.forum_tags
    SET usage_count = usage_count + 1
    WHERE id = NEW.tag_id;
    RETURN NEW;
  ELSIF TG_OP = 'DELETE' THEN
    UPDATE public.forum_tags
    SET usage_count = GREATEST(usage_count - 1, 0)
    WHERE id = OLD.tag_id;
    RETURN OLD;
  END IF;
  RETURN NULL;
END;
$$;


--
-- Name: update_updated_at_column(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_updated_at_column() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$;


--
-- Name: update_user_location(uuid, double precision, double precision); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_user_location(user_id uuid, lat double precision, lng double precision) RETURNS void
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public', 'extensions'
    AS $$
BEGIN
  UPDATE profiles
  SET 
    location = ST_SetSRID(ST_MakePoint(lng, lat), 4326)::geography,
    updated_at = NOW()
  WHERE id = user_id;
END;
$$;


--
-- Name: FUNCTION update_user_location(user_id uuid, lat double precision, lng double precision); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.update_user_location(user_id uuid, lat double precision, lng double precision) IS 'Updates the authenticated user''s saved location for personalized nearby results.';


--
-- Name: update_user_notifications_updated_at(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_user_notifications_updated_at() RETURNS trigger
    LANGUAGE plpgsql
    SET search_path TO ''
    AS $$
BEGIN
  NEW.updated_at = now();
  RETURN NEW;
END;
$$;


--
-- Name: update_user_preferences(jsonb, uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_user_preferences(p_preferences jsonb, p_profile_id uuid DEFAULT NULL::uuid) RETURNS jsonb
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
DECLARE v_user_id UUID;
BEGIN v_user_id := COALESCE(p_profile_id, auth.uid()); IF v_user_id IS NULL THEN RETURN jsonb_build_object('success', false, 'error', jsonb_build_object('code', 'AUTH_REQUIRED', 'message', 'Authentication required')); END IF;
INSERT INTO user_preferences (profile_id, search_radius_km, feed_view_mode, notifications_enabled, email_notifications, push_notifications, show_distance, preferred_categories, theme, language)
VALUES (v_user_id, COALESCE((p_preferences->>'search_radius_km')::DOUBLE PRECISION, 5.0), COALESCE(p_preferences->>'feed_view_mode', 'grid'), COALESCE((p_preferences->>'notifications_enabled')::BOOLEAN, true), COALESCE((p_preferences->>'email_notifications')::BOOLEAN, true), COALESCE((p_preferences->>'push_notifications')::BOOLEAN, true), COALESCE((p_preferences->>'show_distance')::BOOLEAN, true), COALESCE((SELECT array_agg(x::INT) FROM jsonb_array_elements_text(p_preferences->'preferred_categories') x), '{}'::INT[]), COALESCE(p_preferences->>'theme', 'system'), COALESCE(p_preferences->>'language', 'en'))
ON CONFLICT (profile_id) DO UPDATE SET search_radius_km = COALESCE((p_preferences->>'search_radius_km')::DOUBLE PRECISION, user_preferences.search_radius_km), feed_view_mode = COALESCE(p_preferences->>'feed_view_mode', user_preferences.feed_view_mode), notifications_enabled = COALESCE((p_preferences->>'notifications_enabled')::BOOLEAN, user_preferences.notifications_enabled), email_notifications = COALESCE((p_preferences->>'email_notifications')::BOOLEAN, user_preferences.email_notifications), push_notifications = COALESCE((p_preferences->>'push_notifications')::BOOLEAN, user_preferences.push_notifications), show_distance = COALESCE((p_preferences->>'show_distance')::BOOLEAN, user_preferences.show_distance), preferred_categories = COALESCE((SELECT array_agg(x::INT) FROM jsonb_array_elements_text(p_preferences->'preferred_categories') x), user_preferences.preferred_categories), theme = COALESCE(p_preferences->>'theme', user_preferences.theme), language = COALESCE(p_preferences->>'language', user_preferences.language), updated_at = NOW();
RETURN get_user_preferences(v_user_id);
EXCEPTION WHEN OTHERS THEN RETURN jsonb_build_object('success', false, 'error', jsonb_build_object('code', 'SERVER_ERROR', 'message', SQLERRM));
END;
$$;


--
-- Name: update_user_rating(text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_user_rating(target_user_id text) RETURNS void
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO ''
    AS $$
DECLARE
  avg_rating numeric;
  total_count integer;
BEGIN
  SELECT AVG(reviewed_rating), COUNT(*)
  INTO avg_rating, total_count
  FROM public.reviews
  WHERE profile_id = target_user_id;
  
  UPDATE public.profile_stats
  SET rating_average = COALESCE(avg_rating, 0),
      rating_count = COALESCE(total_count, 0),
      updated_at = NOW()
  WHERE profile_id = target_user_id;
END;
$$;


--
-- Name: update_user_rating(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_user_rating(target_user_id uuid) RETURNS void
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO ''
    AS $$
DECLARE
    avg_rating DECIMAL(3,2);
    total_reviews INTEGER;
BEGIN
    SELECT 
        COALESCE(AVG(rating), 0)::DECIMAL(3,2),
        COUNT(*)
    INTO avg_rating, total_reviews
    FROM public.foodshare_reviews
    WHERE reviewed_user_id = target_user_id AND is_public = true;
    
    UPDATE public.profiles_foodshare
    SET 
        rating_average = avg_rating,
        rating_count = total_reviews,
        updated_at = NOW()
    WHERE id = target_user_id;
END;
$$;


--
-- Name: FUNCTION update_user_rating(target_user_id uuid); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.update_user_rating(target_user_id uuid) IS 'Recalculate and update user average rating';


--
-- Name: update_user_settings(uuid, text, jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_user_settings(p_user_id uuid, p_section text, p_settings jsonb) RETURNS jsonb
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
DECLARE
  v_current_prefs jsonb;
  v_new_prefs jsonb;
  v_key text;
  v_value jsonb;
BEGIN
  -- Get current preferences
  SELECT COALESCE(notification_preferences, '{}'::jsonb)
  INTO v_current_prefs
  FROM profiles
  WHERE id = p_user_id AND deleted_at IS NULL;

  IF v_current_prefs IS NULL THEN
    RETURN jsonb_build_object(
      'success', false,
      'error', jsonb_build_object('code', 'NOT_FOUND', 'message', 'User not found')
    );
  END IF;

  -- Map section keys to storage keys and merge
  CASE p_section
    WHEN 'notifications' THEN
      v_new_prefs := v_current_prefs;
      -- Convert camelCase to snake_case for storage
      FOR v_key, v_value IN SELECT * FROM jsonb_each(p_settings) LOOP
        v_new_prefs := jsonb_set(
          v_new_prefs,
          ARRAY[
            CASE v_key
              WHEN 'pushEnabled' THEN 'push_enabled'
              WHEN 'emailEnabled' THEN 'email_enabled'
              WHEN 'newListings' THEN 'new_listings'
              WHEN 'quietHoursEnabled' THEN 'quiet_hours_enabled'
              WHEN 'quietHoursStart' THEN 'quiet_hours_start'
              WHEN 'quietHoursEnd' THEN 'quiet_hours_end'
              ELSE v_key
            END
          ],
          v_value
        );
      END LOOP;

    WHEN 'privacy' THEN
      v_new_prefs := v_current_prefs;
      FOR v_key, v_value IN SELECT * FROM jsonb_each(p_settings) LOOP
        v_new_prefs := jsonb_set(
          v_new_prefs,
          ARRAY[
            CASE v_key
              WHEN 'showEmail' THEN 'show_email'
              WHEN 'showLocation' THEN 'show_location'
              WHEN 'showOnlineStatus' THEN 'show_online_status'
              WHEN 'allowMessages' THEN 'allow_messages'
              WHEN 'allowRatings' THEN 'allow_ratings'
              ELSE v_key
            END
          ],
          v_value
        );
      END LOOP;

    WHEN 'preferences' THEN
      v_new_prefs := v_current_prefs;
      FOR v_key, v_value IN SELECT * FROM jsonb_each(p_settings) LOOP
        IF v_key = 'dietary' THEN
          -- Dietary preferences stored separately
          UPDATE profiles
          SET dietary_preferences = v_value,
              updated_at = NOW()
          WHERE id = p_user_id;
        ELSE
          v_new_prefs := jsonb_set(
            v_new_prefs,
            ARRAY[
              CASE v_key
                WHEN 'searchRadiusKm' THEN 'search_radius'
                ELSE v_key
              END
            ],
            v_value
          );
        END IF;
      END LOOP;

    ELSE
      RETURN jsonb_build_object(
        'success', false,
        'error', jsonb_build_object('code', 'INVALID_SECTION', 'message', 'Unknown settings section')
      );
  END CASE;

  -- Update notification preferences
  UPDATE profiles
  SET notification_preferences = v_new_prefs,
      updated_at = NOW()
  WHERE id = p_user_id;

  RETURN jsonb_build_object(
    'success', true,
    'section', p_section,
    'updated', p_settings,
    'meta', jsonb_build_object('timestamp', NOW())
  );
END;
$$;


--
-- Name: FUNCTION update_user_settings(p_user_id uuid, p_section text, p_settings jsonb); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.update_user_settings(p_user_id uuid, p_section text, p_settings jsonb) IS 'Atomically updates a settings section';


--
-- Name: update_user_stats_on_comment(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_user_stats_on_comment() RETURNS trigger
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
BEGIN
  IF TG_OP = 'INSERT' THEN
    PERFORM public.ensure_forum_user_stats(NEW.user_id);
    
    UPDATE public.forum_user_stats
    SET 
      comments_count = comments_count + 1,
      last_comment_at = now(),
      reputation_score = reputation_score + 2,
      updated_at = now()
    WHERE profile_id = NEW.user_id;
  ELSIF TG_OP = 'DELETE' THEN
    UPDATE public.forum_user_stats
    SET 
      comments_count = GREATEST(0, comments_count - 1),
      reputation_score = GREATEST(0, reputation_score - 2),
      updated_at = now()
    WHERE profile_id = OLD.user_id;
  END IF;
  
  RETURN COALESCE(NEW, OLD);
END;
$$;


--
-- Name: update_user_stats_on_post(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_user_stats_on_post() RETURNS trigger
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
BEGIN
  IF TG_OP = 'INSERT' THEN
    PERFORM public.ensure_forum_user_stats(NEW.profile_id);
    
    UPDATE public.forum_user_stats
    SET 
      posts_count = posts_count + 1,
      last_post_at = now(),
      reputation_score = reputation_score + 10,
      updated_at = now()
    WHERE profile_id = NEW.profile_id;
  ELSIF TG_OP = 'DELETE' THEN
    UPDATE public.forum_user_stats
    SET 
      posts_count = GREATEST(0, posts_count - 1),
      reputation_score = GREATEST(0, reputation_score - 10),
      updated_at = now()
    WHERE profile_id = OLD.profile_id;
  END IF;
  
  RETURN COALESCE(NEW, OLD);
END;
$$;


--
-- Name: update_user_stats_on_reaction(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_user_stats_on_reaction() RETURNS trigger
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
DECLARE
  v_post_author_id UUID;
  v_reaction_name TEXT;
  v_rep_change INT := 1;
BEGIN
  SELECT profile_id INTO v_post_author_id
  FROM public.forum WHERE id = COALESCE(NEW.forum_id, OLD.forum_id);
  
  IF v_post_author_id IS NULL THEN
    RETURN COALESCE(NEW, OLD);
  END IF;
  
  IF TG_OP = 'INSERT' THEN
    SELECT name INTO v_reaction_name
    FROM public.reaction_types WHERE id = NEW.reaction_type_id;
    
    IF v_reaction_name = 'helpful' THEN
      v_rep_change := 5;
    END IF;
  END IF;
  
  PERFORM public.ensure_forum_user_stats(v_post_author_id);
  
  IF TG_OP = 'INSERT' THEN
    UPDATE public.forum_user_stats
    SET 
      reactions_received = reactions_received + 1,
      helpful_count = helpful_count + CASE WHEN v_reaction_name = 'helpful' THEN 1 ELSE 0 END,
      reputation_score = reputation_score + v_rep_change,
      updated_at = now()
    WHERE profile_id = v_post_author_id;
  ELSIF TG_OP = 'DELETE' THEN
    UPDATE public.forum_user_stats
    SET 
      reactions_received = GREATEST(0, reactions_received - 1),
      reputation_score = GREATEST(0, reputation_score - v_rep_change),
      updated_at = now()
    WHERE profile_id = v_post_author_id;
  END IF;
  
  RETURN COALESCE(NEW, OLD);
END;
$$;


--
-- Name: user_statistics(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.user_statistics(target_user_id uuid) RETURNS json
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO ''
    AS $$
DECLARE
    result JSON;
BEGIN
    SELECT json_build_object(
        'user_id', target_user_id,
        'profile', (
            SELECT json_build_object(
                'nickname', nickname,
                'avatar_url', avatar_url,
                'rating_average', rating_average,
                'rating_count', rating_count,
                'member_since', created_at
            )
            FROM public.profiles_foodshare
            WHERE id = target_user_id
        ),
        'items_shared', (
            SELECT COUNT(*)
            FROM public.food_items
            WHERE user_id = target_user_id AND status = 'completed'
        ),
        'items_received', (
            SELECT COUNT(*)
            FROM public.reservations
            WHERE requester_id = target_user_id AND status = 'completed'
        ),
        'active_listings', (
            SELECT COUNT(*)
            FROM public.food_items
            WHERE user_id = target_user_id AND status = 'available' AND is_active = true
        ),
        'total_reviews_received', (
            SELECT COUNT(*)
            FROM public.foodshare_reviews
            WHERE reviewed_user_id = target_user_id
        ),
        'total_reviews_given', (
            SELECT COUNT(*)
            FROM public.foodshare_reviews
            WHERE reviewer_id = target_user_id
        ),
        'rating_breakdown', (
            SELECT json_build_object(
                '5_star', COUNT(*) FILTER (WHERE rating = 5),
                '4_star', COUNT(*) FILTER (WHERE rating = 4),
                '3_star', COUNT(*) FILTER (WHERE rating = 3),
                '2_star', COUNT(*) FILTER (WHERE rating = 2),
                '1_star', COUNT(*) FILTER (WHERE rating = 1)
            )
            FROM public.foodshare_reviews
            WHERE reviewed_user_id = target_user_id
        ),
        'recent_activity', (
            SELECT json_agg(
                json_build_object(
                    'id', id,
                    'title', title,
                    'status', status,
                    'created_at', created_at
                )
                ORDER BY created_at DESC
            )
            FROM (
                SELECT id, title, status, created_at
                FROM public.food_items
                WHERE user_id = target_user_id
                ORDER BY created_at DESC
                LIMIT 5
            ) recent
        )
    ) INTO result;
    
    RETURN result;
END;
$$;


--
-- Name: FUNCTION user_statistics(target_user_id uuid); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.user_statistics(target_user_id uuid) IS 'Get comprehensive statistics and activity for a user';


--
-- Name: vacuum_all_tables(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.vacuum_all_tables() RETURNS void
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
DECLARE
  table_name text;
BEGIN
  FOR table_name IN 
    SELECT tablename 
    FROM pg_tables 
    WHERE schemaname = 'public'
  LOOP
    EXECUTE 'VACUUM ANALYZE public.' || quote_ident(table_name);
  END LOOP;
END;
$$;


--
-- Name: validate_listing(text, text, text[], text, double precision, double precision, text, text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.validate_listing(p_title text, p_description text DEFAULT NULL::text, p_images text[] DEFAULT NULL::text[], p_post_type text DEFAULT 'food'::text, p_latitude double precision DEFAULT NULL::double precision, p_longitude double precision DEFAULT NULL::double precision, p_pickup_address text DEFAULT NULL::text, p_pickup_time text DEFAULT NULL::text) RETURNS jsonb
    LANGUAGE plpgsql
    SET search_path TO ''
    AS $$
DECLARE
    v_errors JSONB := '[]'::JSONB;
    v_title TEXT;
    v_description TEXT;
    v_valid_types TEXT[] := ARRAY['food', 'things', 'borrow', 'wanted', 'zerowaste', 'vegan'];
BEGIN
    -- Sanitize title (trim whitespace)
    v_title := TRIM(COALESCE(p_title, ''));
    v_description := TRIM(COALESCE(p_description, ''));

    -- ==========================================================================
    -- Title Validation
    -- ==========================================================================
    IF v_title = '' THEN
        v_errors := v_errors || jsonb_build_object(
            'field', 'title',
            'code', 'VALIDATION_REQUIRED',
            'message', 'Title is required'
        );
    ELSIF LENGTH(v_title) < 3 THEN
        v_errors := v_errors || jsonb_build_object(
            'field', 'title',
            'code', 'VALIDATION_TOO_SHORT',
            'message', 'Title must be at least 3 characters'
        );
    ELSIF LENGTH(v_title) > 100 THEN
        v_errors := v_errors || jsonb_build_object(
            'field', 'title',
            'code', 'VALIDATION_TOO_LONG',
            'message', 'Title must be less than 100 characters'
        );
    END IF;

    -- ==========================================================================
    -- Description Validation (optional but has max length)
    -- ==========================================================================
    IF v_description <> '' AND LENGTH(v_description) > 2000 THEN
        v_errors := v_errors || jsonb_build_object(
            'field', 'description',
            'code', 'VALIDATION_TOO_LONG',
            'message', 'Description must be less than 2000 characters'
        );
    END IF;

    -- ==========================================================================
    -- Images Validation
    -- ==========================================================================
    IF p_images IS NULL OR array_length(p_images, 1) IS NULL OR array_length(p_images, 1) < 1 THEN
        v_errors := v_errors || jsonb_build_object(
            'field', 'images',
            'code', 'VALIDATION_REQUIRED',
            'message', 'At least one image is required'
        );
    ELSIF array_length(p_images, 1) > 3 THEN
        v_errors := v_errors || jsonb_build_object(
            'field', 'images',
            'code', 'VALIDATION_TOO_MANY',
            'message', 'Maximum 3 images allowed'
        );
    END IF;

    -- ==========================================================================
    -- Post Type Validation
    -- ==========================================================================
    IF p_post_type IS NULL OR NOT (p_post_type = ANY(v_valid_types)) THEN
        v_errors := v_errors || jsonb_build_object(
            'field', 'postType',
            'code', 'VALIDATION_INVALID',
            'message', 'Invalid post type. Must be one of: ' || array_to_string(v_valid_types, ', ')
        );
    END IF;

    -- ==========================================================================
    -- Location Validation
    -- ==========================================================================
    IF p_latitude IS NULL OR p_longitude IS NULL THEN
        v_errors := v_errors || jsonb_build_object(
            'field', 'location',
            'code', 'VALIDATION_REQUIRED',
            'message', 'Location coordinates are required'
        );
    ELSIF p_latitude < -90 OR p_latitude > 90 THEN
        v_errors := v_errors || jsonb_build_object(
            'field', 'latitude',
            'code', 'VALIDATION_INVALID',
            'message', 'Latitude must be between -90 and 90'
        );
    ELSIF p_longitude < -180 OR p_longitude > 180 THEN
        v_errors := v_errors || jsonb_build_object(
            'field', 'longitude',
            'code', 'VALIDATION_INVALID',
            'message', 'Longitude must be between -180 and 180'
        );
    END IF;

    -- ==========================================================================
    -- Return Result
    -- ==========================================================================
    RETURN jsonb_build_object(
        'valid', jsonb_array_length(v_errors) = 0,
        'errors', v_errors,
        'sanitized', CASE WHEN jsonb_array_length(v_errors) = 0 THEN
            jsonb_build_object(
                'title', v_title,
                'description', CASE WHEN v_description = '' THEN NULL ELSE v_description END,
                'images', p_images,
                'postType', p_post_type,
                'latitude', p_latitude,
                'longitude', p_longitude,
                'pickupAddress', TRIM(COALESCE(p_pickup_address, '')),
                'pickupTime', TRIM(COALESCE(p_pickup_time, ''))
            )
        ELSE NULL END
    );
END;
$$;


--
-- Name: FUNCTION validate_listing(p_title text, p_description text, p_images text[], p_post_type text, p_latitude double precision, p_longitude double precision, p_pickup_address text, p_pickup_time text); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.validate_listing(p_title text, p_description text, p_images text[], p_post_type text, p_latitude double precision, p_longitude double precision, p_pickup_address text, p_pickup_time text) IS 'Server-side validation for listing creation. Returns { valid, errors[], sanitized }.
Called by iOS/Android clients before creating a listing to ensure data integrity.
This is the single source of truth for validation rules.';


--
-- Name: validate_listing_update(integer, text, text, boolean, boolean); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.validate_listing_update(p_listing_id integer, p_title text DEFAULT NULL::text, p_description text DEFAULT NULL::text, p_is_active boolean DEFAULT NULL::boolean, p_is_arranged boolean DEFAULT NULL::boolean) RETURNS jsonb
    LANGUAGE plpgsql
    SET search_path TO ''
    AS $$
DECLARE
    v_errors JSONB := '[]'::JSONB;
    v_title TEXT;
    v_description TEXT;
    v_listing_exists BOOLEAN;
    v_is_owner BOOLEAN;
BEGIN
    -- Check if listing exists
    SELECT EXISTS(SELECT 1 FROM public.posts WHERE id = p_listing_id) INTO v_listing_exists;

    IF NOT v_listing_exists THEN
        v_errors := v_errors || jsonb_build_object(
            'field', 'listingId',
            'code', 'RESOURCE_NOT_FOUND',
            'message', 'Listing not found'
        );
        RETURN jsonb_build_object('valid', false, 'errors', v_errors, 'sanitized', NULL);
    END IF;

    -- Check ownership (caller must own the listing)
    SELECT profile_id = auth.uid() INTO v_is_owner FROM public.posts WHERE id = p_listing_id;

    IF NOT v_is_owner THEN
        v_errors := v_errors || jsonb_build_object(
            'field', 'listingId',
            'code', 'RESOURCE_FORBIDDEN',
            'message', 'You can only update your own listings'
        );
        RETURN jsonb_build_object('valid', false, 'errors', v_errors, 'sanitized', NULL);
    END IF;

    -- Validate title if provided
    IF p_title IS NOT NULL THEN
        v_title := TRIM(p_title);
        IF LENGTH(v_title) < 3 THEN
            v_errors := v_errors || jsonb_build_object(
                'field', 'title',
                'code', 'VALIDATION_TOO_SHORT',
                'message', 'Title must be at least 3 characters'
            );
        ELSIF LENGTH(v_title) > 100 THEN
            v_errors := v_errors || jsonb_build_object(
                'field', 'title',
                'code', 'VALIDATION_TOO_LONG',
                'message', 'Title must be less than 100 characters'
            );
        END IF;
    END IF;

    -- Validate description if provided
    IF p_description IS NOT NULL THEN
        v_description := TRIM(p_description);
        IF LENGTH(v_description) > 2000 THEN
            v_errors := v_errors || jsonb_build_object(
                'field', 'description',
                'code', 'VALIDATION_TOO_LONG',
                'message', 'Description must be less than 2000 characters'
            );
        END IF;
    END IF;

    RETURN jsonb_build_object(
        'valid', jsonb_array_length(v_errors) = 0,
        'errors', v_errors,
        'sanitized', CASE WHEN jsonb_array_length(v_errors) = 0 THEN
            jsonb_build_object(
                'listingId', p_listing_id,
                'title', v_title,
                'description', v_description,
                'isActive', p_is_active,
                'isArranged', p_is_arranged
            )
        ELSE NULL END
    );
END;
$$;


--
-- Name: FUNCTION validate_listing_update(p_listing_id integer, p_title text, p_description text, p_is_active boolean, p_is_arranged boolean); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.validate_listing_update(p_listing_id integer, p_title text, p_description text, p_is_active boolean, p_is_arranged boolean) IS 'Server-side validation for listing updates. Checks ownership and validates provided fields.
Returns { valid, errors[], sanitized }.';


--
-- Name: verify_mfa_challenge(uuid, text, uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.verify_mfa_challenge(p_challenge_id uuid, p_code text, p_profile_id uuid) RETURNS jsonb
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO ''
    AS $$
DECLARE
  v_challenge RECORD;
  v_is_valid BOOLEAN;
  v_session_id UUID;
BEGIN
  SELECT * INTO v_challenge
  FROM mfa_verification_attempts
  WHERE id = p_challenge_id
    AND profile_id = p_profile_id
    AND is_expired = FALSE;

  IF v_challenge.id IS NULL THEN
    RETURN jsonb_build_object('success', FALSE, 'error', 'invalid_challenge');
  END IF;

  IF v_challenge.expires_at < NOW() THEN
    UPDATE mfa_verification_attempts SET is_expired = TRUE WHERE id = p_challenge_id;
    RETURN jsonb_build_object('success', FALSE, 'error', 'challenge_expired');
  END IF;

  IF v_challenge.attempts_count >= v_challenge.max_attempts THEN
    UPDATE mfa_verification_attempts SET is_expired = TRUE WHERE id = p_challenge_id;
    RETURN jsonb_build_object('success', FALSE, 'error', 'max_attempts_exceeded');
  END IF;

  v_is_valid := verify_mfa_code(p_code, v_challenge.code_hash);

  UPDATE mfa_verification_attempts
  SET
    attempts_count = attempts_count + 1,
    is_verified = v_is_valid,
    verified_at = CASE WHEN v_is_valid THEN NOW() ELSE NULL END
  WHERE id = p_challenge_id;

  IF NOT v_is_valid THEN
    RETURN jsonb_build_object(
      'success', FALSE,
      'error', 'invalid_code',
      'attempts_remaining', v_challenge.max_attempts - v_challenge.attempts_count - 1
    );
  END IF;

  INSERT INTO mfa_sessions (
    profile_id, session_id, current_aal, mfa_verified_at, mfa_method_used, ip_address, user_agent
  ) VALUES (
    p_profile_id, gen_random_uuid(), 'aal2', NOW(), v_challenge.verification_method, v_challenge.ip_address, v_challenge.user_agent
  )
  RETURNING session_id INTO v_session_id;

  UPDATE mfa_configuration SET last_mfa_verification_at = NOW() WHERE profile_id = p_profile_id;

  RETURN jsonb_build_object(
    'success', TRUE,
    'session_id', v_session_id,
    'aal', 'aal2',
    'verified_at', NOW()
  );
END;
$$;


--
-- Name: verify_mfa_code(text, text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.verify_mfa_code(code text, code_hash text) RETURNS boolean
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO ''
    AS $$
BEGIN
  RETURN code_hash = crypt(code, code_hash);
END;
$$;


--
-- Name: verify_phone_for_sms(uuid, text, text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.verify_phone_for_sms(p_user_id uuid, p_phone_number text, p_verification_code text) RETURNS jsonb
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
BEGIN
  -- TODO: Implement actual SMS verification via Twilio/etc
  -- For now, just update the phone number
  UPDATE notification_settings
  SET
    phone_number = p_phone_number,
    phone_verified = true,
    updated_at = now()
  WHERE user_id = p_user_id;

  RETURN jsonb_build_object('success', true, 'phone_verified', true);
END;
$$;


--
-- Name: forms; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.forms (
    id bigint NOT NULL,
    created_at timestamp with time zone DEFAULT now() NOT NULL
);


--
-- Name: TABLE forms; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE public.forms IS 'Suggestion forms etc';


--
-- Name: Forms_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

ALTER TABLE public.forms ALTER COLUMN id ADD GENERATED BY DEFAULT AS IDENTITY (
    SEQUENCE NAME public."Forms_id_seq"
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);


--
-- Name: Fridges; Type: FOREIGN TABLE; Schema: public; Owner: -
--

CREATE FOREIGN TABLE public."Fridges" (
    "Name" text,
    "Status" text,
    "Pantry?" text
)
SERVER airtable_server
OPTIONS (
    base_id 'appxQQHeIXAeUI0wI',
    id '33234',
    schema 'public',
    table_id 'tbllaKMP0FyNL0rF6'
);


--
-- Name: FOREIGN TABLE "Fridges"; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FOREIGN TABLE public."Fridges" IS 'Foreign table from Airtable. Not accessible via PostgREST API for security reasons. Access only via service_role. Note: Foreign tables do not support RLS policies.';


--
-- Name: address; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.address (
    profile_id uuid NOT NULL,
    address_line_1 text DEFAULT '-'::text NOT NULL,
    address_line_2 text DEFAULT '-'::text NOT NULL,
    address_line_3 text DEFAULT '-'::text NOT NULL,
    city text DEFAULT '-'::text NOT NULL,
    state_province text DEFAULT '-'::text NOT NULL,
    postal_code text DEFAULT '-'::text NOT NULL,
    county text DEFAULT '-'::text NOT NULL,
    country_id bigint DEFAULT '234'::bigint NOT NULL,
    location extensions.geography(Point,4326) DEFAULT '0101000020E6100000A4DFBE0E9C91614044FAEDEBC0494240'::extensions.geography NOT NULL,
    transportation text DEFAULT '-'::text NOT NULL,
    lat double precision DEFAULT '0'::double precision NOT NULL,
    long double precision DEFAULT '0'::double precision NOT NULL,
    radius_meters integer DEFAULT 50000 NOT NULL,
    generated_full_address text DEFAULT '-'::text NOT NULL,
    last_processed_id bigint DEFAULT 0,
    created_at timestamp with time zone DEFAULT (now() AT TIME ZONE 'utc'::text) NOT NULL,
    updated_at timestamp with time zone,
    location_status public.location_status,
    country text,
    test_delete jsonb,
    CONSTRAINT check_address_lat_valid CHECK (((lat >= ('-90'::integer)::double precision) AND (lat <= (90)::double precision))),
    CONSTRAINT check_address_long_valid CHECK (((long >= ('-180'::integer)::double precision) AND (long <= (180)::double precision))),
    CONSTRAINT check_radius_positive CHECK ((radius_meters > 0))
);


--
-- Name: TABLE address; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE public.address IS 'List of user countries.';


--
-- Name: COLUMN address.county; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.address.county IS 'A county is a political entity with precisely defined borders that is part of a state. ';


--
-- Name: COLUMN address.generated_full_address; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.address.generated_full_address IS 'Generated by a Trigger Function to Generate Full Address in PostgreSQL with Supabase';


--
-- Name: admin_audit_log; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.admin_audit_log (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    admin_id uuid NOT NULL,
    action text NOT NULL,
    resource_type text NOT NULL,
    resource_id text,
    metadata jsonb,
    ip_address inet,
    user_agent text,
    success boolean DEFAULT true,
    error_message text,
    created_at timestamp with time zone DEFAULT now() NOT NULL
);


--
-- Name: TABLE admin_audit_log; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE public.admin_audit_log IS 'Audit trail of all admin actions for SOC 2 compliance';


--
-- Name: analytics_daily_stats; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.analytics_daily_stats (
    date date NOT NULL,
    new_users integer DEFAULT 0,
    active_users integer DEFAULT 0,
    returning_users integer DEFAULT 0,
    new_listings integer DEFAULT 0,
    completed_shares integer DEFAULT 0,
    messages_sent integer DEFAULT 0,
    top_categories jsonb,
    computed_at timestamp with time zone DEFAULT now(),
    synced_to_motherduck boolean DEFAULT false
);


--
-- Name: likes; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.likes (
    id bigint NOT NULL,
    post_id bigint NOT NULL,
    challenge_id bigint NOT NULL,
    forum_id bigint NOT NULL,
    profile_id uuid NOT NULL,
    created_at timestamp with time zone DEFAULT (now() AT TIME ZONE 'utc'::text) NOT NULL,
    comment_id integer DEFAULT 0 NOT NULL
);


--
-- Name: TABLE likes; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE public.likes IS 'Unified likes table for all entity types (posts, forum, challenges, comments). Migrated from legacy tables: forum_likes, comment_likes. See migration 20260131000010 for data migration details.';


--
-- Name: analytics_full_favorites; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW public.analytics_full_favorites AS
 SELECT (likes.id)::text AS id,
    (likes.profile_id)::text AS user_id,
    (likes.post_id)::integer AS post_id,
    likes.created_at
   FROM public.likes
  WHERE (likes.post_id IS NOT NULL);


--
-- Name: analytics_full_listings; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW public.analytics_full_listings AS
 SELECT (posts.id)::integer AS id,
    (posts.profile_id)::text AS profile_id,
    posts.post_name,
    posts.post_description,
    posts.post_type,
    posts.post_address,
        CASE
            WHEN (posts.location_json IS NOT NULL) THEN (((posts.location_json -> 'coordinates'::text) ->> 1))::double precision
            ELSE NULL::double precision
        END AS latitude,
        CASE
            WHEN (posts.location_json IS NOT NULL) THEN (((posts.location_json -> 'coordinates'::text) ->> 0))::double precision
            ELSE NULL::double precision
        END AS longitude,
    posts.is_active,
    posts.is_arranged,
    (posts.post_arranged_to)::text AS post_arranged_to,
    posts.post_arranged_at,
    COALESCE(posts.post_views, 0) AS post_views,
    COALESCE(posts.post_like_counter, 0) AS post_like_counter,
    posts.created_at,
    posts.updated_at,
    posts.synced_to_motherduck
   FROM public.posts;


--
-- Name: reviews; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.reviews (
    reviewed_rating smallint DEFAULT '0'::smallint NOT NULL,
    profile_id uuid NOT NULL,
    id bigint NOT NULL,
    post_id bigint,
    forum_id bigint,
    challenge_id bigint,
    feedback text DEFAULT '-'::text NOT NULL,
    notes text DEFAULT '-'::text NOT NULL,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    CONSTRAINT check_rating_range CHECK (((reviewed_rating >= 0) AND (reviewed_rating <= 5)))
);


--
-- Name: TABLE reviews; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE public.reviews IS 'Stores feedback from users after successful post sharing, completed challenges or reviewd forum posts.';


--
-- Name: analytics_full_reviews; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW public.analytics_full_reviews AS
 SELECT (reviews.id)::text AS id,
    (reviews.profile_id)::text AS reviewer_id,
    (reviews.post_id)::integer AS post_id,
    reviews.reviewed_rating AS rating,
        CASE
            WHEN (reviews.post_id IS NOT NULL) THEN 'post'::text
            WHEN (reviews.forum_id IS NOT NULL) THEN 'forum'::text
            WHEN (reviews.challenge_id IS NOT NULL) THEN 'challenge'::text
            ELSE 'unknown'::text
        END AS review_type,
    reviews.created_at,
    reviews.created_at AS updated_at
   FROM public.reviews;


--
-- Name: rooms; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.rooms (
    last_message text DEFAULT ''::text NOT NULL,
    last_message_seen_by uuid NOT NULL,
    last_message_time timestamp with time zone DEFAULT (now() AT TIME ZONE 'utc'::text) NOT NULL,
    last_message_sent_by uuid NOT NULL,
    post_id bigint,
    id uuid DEFAULT extensions.uuid_generate_v4() NOT NULL,
    sharer uuid NOT NULL,
    requester uuid NOT NULL,
    post_arranged_to uuid,
    email_to text DEFAULT '-'::text NOT NULL,
    sync_version bigint DEFAULT nextval('public.sync_version_seq'::regclass)
);


--
-- Name: TABLE rooms; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE public.rooms IS 'Stores the user chats on each post request.';


--
-- Name: analytics_full_rooms; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW public.analytics_full_rooms AS
 SELECT (rooms.id)::text AS id,
    (rooms.post_id)::integer AS post_id,
    (rooms.sharer)::text AS sharer_id,
    (rooms.requester)::text AS requester_id,
    rooms.last_message_time AS last_message_at,
    rooms.last_message_time AS created_at,
    rooms.last_message_time AS updated_at
   FROM public.rooms;


--
-- Name: profiles; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.profiles (
    id uuid NOT NULL,
    nickname text DEFAULT ''::text NOT NULL,
    first_name text DEFAULT ''::text NOT NULL,
    second_name text DEFAULT ''::text NOT NULL,
    avatar_url text DEFAULT 'https://***REMOVED***/storage/v1/object/public/profiles/avatar.png'::text NOT NULL,
    about_me text DEFAULT '-'::text NOT NULL,
    phone text DEFAULT ''::text NOT NULL,
    updated_at timestamp with time zone DEFAULT (now() AT TIME ZONE 'utc'::text) NOT NULL,
    birth_date date DEFAULT '1990-01-01'::date NOT NULL,
    created_time timestamp with time zone DEFAULT (now() AT TIME ZONE 'utc'::text) NOT NULL,
    email text DEFAULT '-'::text,
    transportation text DEFAULT ''::text NOT NULL,
    facebook text DEFAULT ''::text NOT NULL,
    instagram text DEFAULT ''::text NOT NULL,
    twitter text DEFAULT ''::text NOT NULL,
    bio text,
    dietary_preferences jsonb DEFAULT '[]'::jsonb,
    notification_preferences jsonb DEFAULT '{"messages": true, "new_listings": true, "reservations": true}'::jsonb,
    search_radius_km integer DEFAULT 5,
    is_verified boolean DEFAULT false,
    is_active boolean DEFAULT true,
    last_seen_at timestamp with time zone DEFAULT now(),
    theme_preferences jsonb DEFAULT '{"theme": "dark", "schedule": {"enabled": false, "darkStart": "19:00", "lightStart": "07:00"}, "transition": "radial"}'::jsonb,
    telegram_id bigint,
    email_verified boolean DEFAULT false,
    verification_code character varying(6),
    verification_code_expires_at timestamp with time zone,
    location extensions.geography(Point,4326),
    language character varying(5) DEFAULT 'en'::character varying,
    verification_attempts integer DEFAULT 0,
    verification_locked_until timestamp with time zone,
    whatsapp_phone character varying(20),
    food_allergies text,
    preferred_contact_method text DEFAULT 'in_app'::text,
    phone_number text,
    available_days jsonb DEFAULT '["saturday", "sunday"]'::jsonb,
    preferred_pickup_time jsonb DEFAULT '{"end_hour": 17, "end_minute": 0, "start_hour": 12, "start_minute": 0}'::jsonb,
    profile_visibility text DEFAULT 'public'::text,
    location_sharing_enabled boolean DEFAULT true,
    synced_to_motherduck boolean DEFAULT false,
    preferred_locale text,
    search_radius_mi numeric(6,2) GENERATED ALWAYS AS (((search_radius_km)::numeric * 0.621371)) STORED,
    CONSTRAINT check_email_format CHECK (((email IS NULL) OR (email ~* '^[a-zA-Z0-9.!#$%&''*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$'::text))),
    CONSTRAINT check_phone_format CHECK (((phone = ''::text) OR (phone ~* '^\+?[1-9]\d{1,14}$'::text))),
    CONSTRAINT check_search_radius_km_range CHECK (((search_radius_km IS NULL) OR ((search_radius_km >= 1) AND (search_radius_km <= 805)))),
    CONSTRAINT profiles_preferred_contact_method_check CHECK ((preferred_contact_method = ANY (ARRAY['in_app'::text, 'email'::text, 'phone'::text, 'sms'::text]))),
    CONSTRAINT profiles_profile_visibility_check CHECK ((profile_visibility = ANY (ARRAY['public'::text, 'friends_only'::text, 'private'::text])))
);


--
-- Name: TABLE profiles; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE public.profiles IS 'Unified user profiles for web and iOS apps. Statistics stored in profile_stats table. User roles managed in user_roles table.';


--
-- Name: COLUMN profiles.avatar_url; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.profiles.avatar_url IS 'User avatar URL. Migrated from avatars to users bucket on 2024-11-30';


--
-- Name: COLUMN profiles.bio; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.profiles.bio IS 'User bio/about me text';


--
-- Name: COLUMN profiles.dietary_preferences; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.profiles.dietary_preferences IS 'User dietary preferences as JSON array (vegetarian, vegan, gluten_free, etc.)';


--
-- Name: COLUMN profiles.notification_preferences; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.profiles.notification_preferences IS 'User notification settings as JSON object';


--
-- Name: COLUMN profiles.search_radius_km; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.profiles.search_radius_km IS 'Search radius in kilometers (1-100, source of truth)';


--
-- Name: COLUMN profiles.is_verified; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.profiles.is_verified IS 'Whether user has verified their email/phone';


--
-- Name: COLUMN profiles.is_active; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.profiles.is_active IS 'Whether user account is active';


--
-- Name: COLUMN profiles.last_seen_at; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.profiles.last_seen_at IS 'Last time user was active in the app';


--
-- Name: COLUMN profiles.theme_preferences; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.profiles.theme_preferences IS 'User theme preferences including theme mode (default: dark), schedule settings, and transition style';


--
-- Name: COLUMN profiles.telegram_id; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.profiles.telegram_id IS 'Telegram user ID for bot integration';


--
-- Name: COLUMN profiles.food_allergies; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.profiles.food_allergies IS 'Free text description of food allergies';


--
-- Name: COLUMN profiles.preferred_contact_method; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.profiles.preferred_contact_method IS 'How the user prefers to be contacted (in_app, email, phone, sms)';


--
-- Name: COLUMN profiles.available_days; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.profiles.available_days IS 'Days of week user is available for pickups as JSON array';


--
-- Name: COLUMN profiles.preferred_pickup_time; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.profiles.preferred_pickup_time IS 'Preferred time window for pickups as JSON object with start/end hours';


--
-- Name: COLUMN profiles.profile_visibility; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.profiles.profile_visibility IS 'Who can view this profile (public, friends_only, private)';


--
-- Name: COLUMN profiles.location_sharing_enabled; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.profiles.location_sharing_enabled IS 'Whether user allows sharing their approximate location';


--
-- Name: COLUMN profiles.search_radius_mi; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.profiles.search_radius_mi IS 'Search radius in miles (computed from search_radius_km)';


--
-- Name: analytics_full_users; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW public.analytics_full_users AS
 SELECT (profiles.id)::text AS id,
    profiles.nickname,
    profiles.email,
    profiles.avatar_url,
    COALESCE(profiles.bio, profiles.about_me) AS bio,
    COALESCE(profiles.is_active, true) AS is_active,
    COALESCE(profiles.is_verified, false) AS is_verified,
    profiles.last_seen_at,
    profiles.created_time AS created_at,
    profiles.updated_at,
    profiles.synced_to_motherduck
   FROM public.profiles;


--
-- Name: analytics_post_activity; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.analytics_post_activity (
    id text NOT NULL,
    date date,
    post_type text,
    posts_viewed integer DEFAULT 0,
    posts_arranged integer DEFAULT 0,
    total_likes integer DEFAULT 0,
    updated_at timestamp with time zone DEFAULT now(),
    synced_to_motherduck boolean DEFAULT false
);


--
-- Name: analytics_staging_favorites; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.analytics_staging_favorites (
    id text NOT NULL,
    user_id text,
    post_id integer,
    created_at timestamp with time zone,
    synced_to_motherduck boolean DEFAULT false
);


--
-- Name: analytics_staging_listings; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.analytics_staging_listings (
    id integer NOT NULL,
    profile_id text,
    post_name text,
    post_description text,
    post_type text,
    post_address text,
    latitude double precision,
    longitude double precision,
    is_active boolean DEFAULT true,
    is_arranged boolean DEFAULT false,
    post_arranged_to text,
    post_arranged_at timestamp with time zone,
    post_views integer DEFAULT 0,
    post_like_counter integer DEFAULT 0,
    created_at timestamp with time zone,
    updated_at timestamp with time zone,
    synced_to_motherduck boolean DEFAULT false
);


--
-- Name: analytics_staging_reviews; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.analytics_staging_reviews (
    id text NOT NULL,
    reviewer_id text,
    post_id integer,
    rating integer,
    review_type text,
    created_at timestamp with time zone,
    updated_at timestamp with time zone,
    synced_to_motherduck boolean DEFAULT false
);


--
-- Name: analytics_staging_rooms; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.analytics_staging_rooms (
    id text NOT NULL,
    post_id integer,
    sharer_id text,
    requester_id text,
    last_message_at timestamp with time zone,
    created_at timestamp with time zone,
    updated_at timestamp with time zone,
    synced_to_motherduck boolean DEFAULT false
);


--
-- Name: analytics_staging_users; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.analytics_staging_users (
    id text NOT NULL,
    nickname text,
    email text,
    avatar_url text,
    bio text,
    is_active boolean DEFAULT true,
    is_verified boolean DEFAULT false,
    last_seen_at timestamp with time zone,
    created_at timestamp with time zone,
    updated_at timestamp with time zone,
    synced_to_motherduck boolean DEFAULT false
);


--
-- Name: analytics_user_activity; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.analytics_user_activity (
    user_id uuid NOT NULL,
    listings_viewed integer DEFAULT 0,
    listings_saved integer DEFAULT 0,
    messages_initiated integer DEFAULT 0,
    shares_completed integer DEFAULT 0,
    last_activity_at timestamp with time zone,
    updated_at timestamp with time zone DEFAULT now(),
    synced_to_motherduck boolean DEFAULT false
);


--
-- Name: api_analytics; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.api_analytics (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    endpoint text NOT NULL,
    method text NOT NULL,
    status_code integer,
    response_time_ms integer,
    user_id uuid,
    error_code text,
    created_at timestamp with time zone DEFAULT now() NOT NULL
);


--
-- Name: app_config; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.app_config (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    key text NOT NULL,
    value jsonb NOT NULL,
    platform text DEFAULT 'all'::text,
    category text NOT NULL,
    description text,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    CONSTRAINT app_config_platform_check CHECK ((platform = ANY (ARRAY['ios'::text, 'android'::text, 'web'::text, 'all'::text])))
);


--
-- Name: TABLE app_config; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE public.app_config IS 'Remote configuration for mobile and web apps. Allows changing app behavior without app updates.';


--
-- Name: app_version_requirements; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.app_version_requirements (
    platform text NOT NULL,
    min_version text NOT NULL,
    recommended_version text NOT NULL,
    force_update_message text,
    soft_update_message text,
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    CONSTRAINT app_version_requirements_platform_check CHECK ((platform = ANY (ARRAY['ios'::text, 'android'::text, 'web'::text])))
);


--
-- Name: TABLE app_version_requirements; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE public.app_version_requirements IS 'Minimum and recommended app versions per platform';


--
-- Name: audience_segments; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.audience_segments (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    name text NOT NULL,
    description text,
    criteria jsonb DEFAULT '{}'::jsonb NOT NULL,
    is_dynamic boolean DEFAULT true,
    cached_count integer DEFAULT 0,
    last_calculated_at timestamp with time zone,
    color text DEFAULT '#6366f1'::text,
    icon_name text DEFAULT 'users'::text,
    is_system boolean DEFAULT false,
    created_by uuid,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now()
);


--
-- Name: TABLE audience_segments; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE public.audience_segments IS 'Dynamic and static audience segments for targeting';


--
-- Name: audit_logs; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.audit_logs (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    user_id uuid,
    action text NOT NULL,
    resource_type text NOT NULL,
    resource_id text NOT NULL,
    metadata jsonb DEFAULT '{}'::jsonb,
    ip_address inet,
    user_agent text,
    created_at timestamp with time zone DEFAULT now()
);


--
-- Name: automation_enrollments; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.automation_enrollments (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    flow_id uuid NOT NULL,
    profile_id uuid NOT NULL,
    status text DEFAULT 'active'::text NOT NULL,
    current_step integer DEFAULT 0,
    enrolled_at timestamp with time zone DEFAULT now(),
    completed_at timestamp with time zone,
    exited_at timestamp with time zone,
    exit_reason text,
    converted boolean DEFAULT false,
    converted_at timestamp with time zone,
    step_history jsonb DEFAULT '[]'::jsonb,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    CONSTRAINT automation_enrollments_status_check CHECK ((status = ANY (ARRAY['active'::text, 'completed'::text, 'exited'::text, 'paused'::text])))
);


--
-- Name: TABLE automation_enrollments; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE public.automation_enrollments IS 'User enrollments in automation flows';


--
-- Name: blocked_users; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.blocked_users (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    user_id uuid NOT NULL,
    blocked_user_id uuid NOT NULL,
    reason text,
    blocked_at timestamp with time zone DEFAULT now() NOT NULL,
    CONSTRAINT no_self_block CHECK ((user_id <> blocked_user_id))
);


--
-- Name: TABLE blocked_users; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE public.blocked_users IS 'User blocking for content moderation - Apple App Review requirement';


--
-- Name: bookmarks; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.bookmarks (
    id integer NOT NULL,
    profile_id uuid NOT NULL,
    post_id integer DEFAULT 0 NOT NULL,
    forum_id integer DEFAULT 0 NOT NULL,
    created_at timestamp with time zone DEFAULT now()
);


--
-- Name: TABLE bookmarks; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE public.bookmarks IS 'Unified bookmarks table for posts and forum. Migrated from legacy tables: forum_bookmarks, post_bookmarks. See migration 20260131000010 for data migration details.';


--
-- Name: bookmarks_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.bookmarks_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: bookmarks_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.bookmarks_id_seq OWNED BY public.bookmarks.id;


--
-- Name: campaign_recipients; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.campaign_recipients (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    campaign_id uuid NOT NULL,
    profile_id uuid,
    subscriber_id uuid,
    email text NOT NULL,
    status text DEFAULT 'pending'::text NOT NULL,
    sent_at timestamp with time zone,
    delivered_at timestamp with time zone,
    opened_at timestamp with time zone,
    clicked_at timestamp with time zone,
    open_count integer DEFAULT 0,
    click_count integer DEFAULT 0,
    clicked_links jsonb DEFAULT '[]'::jsonb,
    provider text,
    provider_message_id text,
    error_message text,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    CONSTRAINT campaign_recipients_status_check CHECK ((status = ANY (ARRAY['pending'::text, 'sent'::text, 'delivered'::text, 'opened'::text, 'clicked'::text, 'bounced'::text, 'unsubscribed'::text, 'complained'::text, 'failed'::text]))),
    CONSTRAINT recipient_check CHECK (((profile_id IS NOT NULL) OR (subscriber_id IS NOT NULL)))
);


--
-- Name: TABLE campaign_recipients; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE public.campaign_recipients IS 'Individual recipient tracking for campaigns';


--
-- Name: categories; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.categories (
    id bigint NOT NULL,
    name text NOT NULL,
    description text,
    icon_url text,
    color text DEFAULT '#4CAF50'::text,
    sort_order integer DEFAULT 0,
    is_active boolean DEFAULT true,
    created_at timestamp with time zone DEFAULT now()
);


--
-- Name: TABLE categories; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE public.categories IS 'Food item categories';


--
-- Name: categories_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.categories_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: categories_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.categories_id_seq OWNED BY public.categories.id;


--
-- Name: challenge_activities; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.challenge_activities (
    id bigint NOT NULL,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    challenge_id bigint NOT NULL,
    user_accepted_challenge uuid,
    user_rejected_challenge uuid,
    user_completed_challenge uuid
);


--
-- Name: TABLE challenge_activities; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE public.challenge_activities IS 'Stores all activities that come from challenges.';


--
-- Name: challenge_activities_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

ALTER TABLE public.challenge_activities ALTER COLUMN id ADD GENERATED BY DEFAULT AS IDENTITY (
    SEQUENCE NAME public.challenge_activities_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);


--
-- Name: challenge_participants; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.challenge_participants (
    id bigint NOT NULL,
    challenge_id bigint NOT NULL,
    profile_id uuid NOT NULL,
    accepted_at timestamp with time zone DEFAULT now() NOT NULL,
    completed_at timestamp with time zone,
    is_completed boolean DEFAULT false NOT NULL
);


--
-- Name: challenge_participants_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

ALTER TABLE public.challenge_participants ALTER COLUMN id ADD GENERATED BY DEFAULT AS IDENTITY (
    SEQUENCE NAME public.challenge_participants_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);


--
-- Name: challenges; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.challenges (
    challenge_difficulty text DEFAULT 'Uncategorized'::text NOT NULL,
    challenged_people numeric DEFAULT '0'::numeric NOT NULL,
    challenge_score numeric DEFAULT '0'::numeric NOT NULL,
    challenge_action text DEFAULT '''Uncategorized''::text'::text NOT NULL,
    challenge_image text DEFAULT 'https://***REMOVED***/storage/v1/object/public/assets/challenge-pic.webp'::text NOT NULL,
    challenge_title text DEFAULT ''::text NOT NULL,
    challenge_views numeric DEFAULT '0'::numeric NOT NULL,
    challenge_description text DEFAULT ''::text NOT NULL,
    profile_id uuid DEFAULT 'b57f61eb-bcde-42a3-a2dd-038caaf24ceb'::uuid NOT NULL,
    id bigint NOT NULL,
    challenge_updated_at timestamp with time zone DEFAULT (now() AT TIME ZONE 'utc'::text) NOT NULL,
    challenge_created_at timestamp with time zone DEFAULT (now() AT TIME ZONE 'utc'::text) NOT NULL,
    challenge_published boolean DEFAULT false NOT NULL,
    challenge_likes_counter integer DEFAULT 0 NOT NULL,
    CONSTRAINT check_challenge_likes_non_negative CHECK ((challenge_likes_counter >= 0)),
    CONSTRAINT check_challenge_score_non_negative CHECK ((challenge_score >= (0)::numeric)),
    CONSTRAINT check_challenge_views_non_negative CHECK ((challenge_views >= (0)::numeric)),
    CONSTRAINT check_challenged_people_non_negative CHECK ((challenged_people >= (0)::numeric))
);


--
-- Name: TABLE challenges; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE public.challenges IS 'Stores challenges that users can do for fun and learning.';


--
-- Name: challenges_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

ALTER TABLE public.challenges ALTER COLUMN id ADD GENERATED BY DEFAULT AS IDENTITY (
    SEQUENCE NAME public.challenges_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);


--
-- Name: comments; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.comments (
    comment text,
    user_id uuid NOT NULL,
    id bigint NOT NULL,
    forum_id bigint,
    comment_created_at timestamp with time zone DEFAULT (now() AT TIME ZONE 'utc'::text) NOT NULL,
    parent_id bigint,
    depth integer DEFAULT 0,
    is_edited boolean DEFAULT false,
    updated_at timestamp with time zone,
    likes_count integer DEFAULT 0,
    replies_count integer DEFAULT 0,
    reports_count integer DEFAULT 0,
    is_best_answer boolean DEFAULT false,
    is_pinned boolean DEFAULT false,
    rich_content jsonb,
    reactions_count jsonb DEFAULT '{}'::jsonb,
    firebase_id text,
    firebase_metadata jsonb DEFAULT '{}'::jsonb,
    CONSTRAINT comments_max_depth CHECK (((depth >= 0) AND (depth <= 2)))
);


--
-- Name: TABLE comments; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE public.comments IS 'Stores users comments on any forum post.';


--
-- Name: COLUMN comments.parent_id; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.comments.parent_id IS 'Reference to parent comment for threading';


--
-- Name: COLUMN comments.depth; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.comments.depth IS 'Nesting level (0=top-level, max 2)';


--
-- Name: COLUMN comments.firebase_id; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.comments.firebase_id IS 'Original Firebase document ID for tracking migration';


--
-- Name: comments_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

ALTER TABLE public.comments ALTER COLUMN id ADD GENERATED BY DEFAULT AS IDENTITY (
    SEQUENCE NAME public.comments_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);


--
-- Name: community_fridges; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.community_fridges (
    name text NOT NULL,
    status text DEFAULT 'Active'::text,
    description text,
    street_address text,
    city text,
    state text,
    zip_code text,
    full_address text,
    latitude double precision,
    longitude double precision,
    location extensions.geography(Point,4326),
    reference_directions text,
    location_type text,
    host_company text,
    company_type text,
    point_person_name text,
    point_person_email text,
    available_hours text,
    has_pantry boolean DEFAULT false,
    languages text[],
    launch_date timestamp with time zone,
    created_date timestamp with time zone,
    last_check_in timestamp with time zone,
    status_last_updated timestamp with time zone,
    total_check_ins integer DEFAULT 0,
    age_years numeric,
    latest_food_status text,
    latest_cleanliness_status text,
    check_in_link text,
    slack_channel_id text,
    slack_channel_link text,
    photo_url text,
    qr_code_url text,
    firebase_metadata jsonb DEFAULT '{}'::jsonb,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    CONSTRAINT community_fridges_latitude_check CHECK (((latitude >= ('-90'::integer)::double precision) AND (latitude <= (90)::double precision))),
    CONSTRAINT community_fridges_longitude_check CHECK (((longitude >= ('-180'::integer)::double precision) AND (longitude <= (180)::double precision))),
    CONSTRAINT community_fridges_status_check CHECK ((status = ANY (ARRAY['Active'::text, 'Inactive'::text, 'Pending'::text])))
);


--
-- Name: TABLE community_fridges; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE public.community_fridges IS 'Community fridges migrated from Firebase. Original IDs stored in firebase_metadata->''original_id''';


--
-- Name: COLUMN community_fridges.location; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.community_fridges.location IS 'PostGIS geography point for spatial queries';


--
-- Name: COLUMN community_fridges.id; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.community_fridges.id IS 'UUID primary key following Supabase best practices';


--
-- Name: compressed_images; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.compressed_images (
    id bigint NOT NULL,
    bucket_id text NOT NULL,
    object_path text NOT NULL,
    original_size bigint NOT NULL,
    compressed_size bigint NOT NULL,
    savings_percent numeric(5,2),
    compressed_at timestamp with time zone DEFAULT now()
);


--
-- Name: compressed_images_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.compressed_images_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: compressed_images_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.compressed_images_id_seq OWNED BY public.compressed_images.id;


--
-- Name: image_upload_metrics; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.image_upload_metrics (
    id bigint NOT NULL,
    user_id uuid,
    bucket text NOT NULL,
    path text NOT NULL,
    original_size bigint NOT NULL,
    compressed_size bigint NOT NULL,
    saved_bytes bigint NOT NULL,
    compression_method text NOT NULL,
    processing_time_ms integer NOT NULL,
    uploaded_at timestamp with time zone DEFAULT now() NOT NULL,
    storage text DEFAULT 'supabase'::text NOT NULL
);


--
-- Name: TABLE image_upload_metrics; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE public.image_upload_metrics IS 'Tracks all image uploads for monitoring and cost analysis';


--
-- Name: COLUMN image_upload_metrics.storage; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.image_upload_metrics.storage IS 'Storage provider: r2 or supabase';


--
-- Name: compression_efficiency; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW public.compression_efficiency AS
 SELECT image_upload_metrics.compression_method,
    count(*) AS uses,
    round(avg((((image_upload_metrics.saved_bytes)::numeric / (NULLIF(image_upload_metrics.original_size, 0))::numeric) * (100)::numeric)), 2) AS avg_savings_percent,
    sum(image_upload_metrics.saved_bytes) AS total_saved_bytes,
    round(avg(image_upload_metrics.processing_time_ms)) AS avg_time_ms
   FROM public.image_upload_metrics
  WHERE (image_upload_metrics.uploaded_at > (now() - '7 days'::interval))
  GROUP BY image_upload_metrics.compression_method
  ORDER BY (count(*)) DESC;


--
-- Name: VIEW compression_efficiency; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON VIEW public.compression_efficiency IS 'Compression method performance comparison';


--
-- Name: image_compressions; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.image_compressions (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    bucket text NOT NULL,
    original_path text NOT NULL,
    compressed_path text,
    original_size bigint NOT NULL,
    compressed_size bigint,
    saved_bytes bigint GENERATED ALWAYS AS ((original_size - compressed_size)) STORED,
    saved_percent numeric(5,2) GENERATED ALWAYS AS (
CASE
    WHEN ((original_size > 0) AND (compressed_size IS NOT NULL)) THEN round(((((original_size - compressed_size))::numeric / (original_size)::numeric) * (100)::numeric), 2)
    ELSE (0)::numeric
END) STORED,
    original_width integer,
    original_height integer,
    compressed_width integer,
    compressed_height integer,
    original_format text,
    compressed_format text,
    compression_method text,
    quality_setting integer,
    processing_time_ms integer,
    status text DEFAULT 'pending'::text,
    error_message text,
    created_at timestamp with time zone DEFAULT now(),
    completed_at timestamp with time zone,
    CONSTRAINT image_compressions_status_check CHECK ((status = ANY (ARRAY['pending'::text, 'processing'::text, 'completed'::text, 'failed'::text, 'skipped'::text])))
);


--
-- Name: compression_stats; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW public.compression_stats WITH (security_invoker='true') AS
 SELECT ic.bucket,
    count(*) AS total_compressions,
    sum(ic.original_size) AS total_original_bytes,
    sum(ic.compressed_size) AS total_compressed_bytes,
    round(avg(ic.saved_percent), 2) AS avg_saved_percent,
    sum(ic.saved_bytes) AS total_bytes_saved
   FROM public.image_compressions ic
  GROUP BY ic.bucket;


--
-- Name: VIEW compression_stats; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON VIEW public.compression_stats IS 'Aggregated compression statistics by bucket. Security invoker enabled 2024-12-08.';


--
-- Name: content_translations; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.content_translations (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    content_type text NOT NULL,
    content_id text NOT NULL,
    field_name text NOT NULL,
    source_locale text NOT NULL,
    target_locale text NOT NULL,
    source_text text NOT NULL,
    translated_text text NOT NULL,
    translation_service text DEFAULT 'self-hosted-llm'::text,
    quality_score double precision DEFAULT 0.95,
    character_count integer,
    created_at timestamp with time zone DEFAULT now(),
    expires_at timestamp with time zone DEFAULT (now() + '90 days'::interval),
    hit_count integer DEFAULT 0,
    last_hit_at timestamp with time zone,
    CONSTRAINT content_translations_content_type_check CHECK ((content_type = ANY (ARRAY['post'::text, 'challenge'::text, 'forum_post'::text])))
);


--
-- Name: TABLE content_translations; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE public.content_translations IS 'Stores translations of user-generated content using self-hosted LLM';


--
-- Name: COLUMN content_translations.content_type; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.content_translations.content_type IS 'Type of content: post, challenge, forum_post';


--
-- Name: COLUMN content_translations.expires_at; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.content_translations.expires_at IS 'Translations expire after 90 days but popular ones (hit_count > 5) are kept';


--
-- Name: COLUMN content_translations.hit_count; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.content_translations.hit_count IS 'Number of times this translation was served from cache';


--
-- Name: countries; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.countries (
    id bigint NOT NULL,
    name text DEFAULT '-'::text NOT NULL,
    iso2 text DEFAULT '-'::text NOT NULL,
    iso3 text DEFAULT '-'::text NOT NULL,
    local_name text DEFAULT '-'::text NOT NULL,
    continent public.continents DEFAULT 'Europe'::public.continents NOT NULL
);


--
-- Name: TABLE countries; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE public.countries IS 'Full list of countries for the address table.';


--
-- Name: COLUMN countries.name; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.countries.name IS 'Full country name.';


--
-- Name: COLUMN countries.iso2; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.countries.iso2 IS 'ISO 3166-1 alpha-2 code.';


--
-- Name: COLUMN countries.iso3; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.countries.iso3 IS 'ISO 3166-1 alpha-3 code.';


--
-- Name: COLUMN countries.local_name; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.countries.local_name IS 'Local variation of the name.';


--
-- Name: countries_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

ALTER TABLE public.countries ALTER COLUMN id ADD GENERATED BY DEFAULT AS IDENTITY (
    SEQUENCE NAME public.countries_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);


--
-- Name: crm_customer_notes; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.crm_customer_notes (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    customer_id uuid NOT NULL,
    admin_id uuid NOT NULL,
    content text NOT NULL,
    note_type text DEFAULT 'general'::text,
    is_pinned boolean DEFAULT false,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    note_text text,
    CONSTRAINT crm_customer_notes_note_type_check CHECK ((note_type = ANY (ARRAY['general'::text, 'call'::text, 'email'::text, 'meeting'::text, 'support'::text])))
);


--
-- Name: crm_customer_tag_assignments; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.crm_customer_tag_assignments (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    customer_id uuid NOT NULL,
    tag_id uuid NOT NULL,
    created_at timestamp with time zone DEFAULT now()
);


--
-- Name: crm_customer_tags; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.crm_customer_tags (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    name text NOT NULL,
    color text DEFAULT '#6366f1'::text,
    description text,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    is_system boolean DEFAULT false
);


--
-- Name: crm_customers; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.crm_customers (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    profile_id uuid NOT NULL,
    status text DEFAULT 'active'::text,
    source text DEFAULT 'organic'::text,
    lifetime_value numeric DEFAULT 0,
    total_transactions integer DEFAULT 0,
    last_interaction_at timestamp with time zone,
    notes text,
    custom_fields jsonb DEFAULT '{}'::jsonb,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    customer_type text DEFAULT 'both'::text,
    engagement_score integer DEFAULT 50,
    lifecycle_stage text DEFAULT 'lead'::text,
    total_interactions integer DEFAULT 0,
    first_interaction_at timestamp with time zone,
    ltv_score numeric DEFAULT 0,
    churn_risk_score integer DEFAULT 0,
    preferred_contact_method text DEFAULT 'in_app'::text,
    is_archived boolean DEFAULT false,
    archived_at timestamp with time zone,
    archived_reason text,
    CONSTRAINT crm_customers_churn_risk_score_check CHECK (((churn_risk_score >= 0) AND (churn_risk_score <= 100))),
    CONSTRAINT crm_customers_customer_type_check CHECK ((customer_type = ANY (ARRAY['donor'::text, 'receiver'::text, 'both'::text]))),
    CONSTRAINT crm_customers_engagement_score_check CHECK (((engagement_score >= 0) AND (engagement_score <= 100))),
    CONSTRAINT crm_customers_lifecycle_stage_check CHECK ((lifecycle_stage = ANY (ARRAY['lead'::text, 'active'::text, 'champion'::text, 'at_risk'::text, 'churned'::text]))),
    CONSTRAINT crm_customers_preferred_contact_method_check CHECK ((preferred_contact_method = ANY (ARRAY['email'::text, 'in_app'::text, 'both'::text]))),
    CONSTRAINT crm_customers_source_check CHECK ((source = ANY (ARRAY['organic'::text, 'referral'::text, 'campaign'::text, 'import'::text]))),
    CONSTRAINT crm_customers_status_check CHECK ((status = ANY (ARRAY['active'::text, 'inactive'::text, 'churned'::text, 'vip'::text])))
);


--
-- Name: daily_stats; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.daily_stats (
    date date NOT NULL,
    new_users integer DEFAULT 0 NOT NULL,
    active_users integer DEFAULT 0 NOT NULL,
    returning_users integer DEFAULT 0 NOT NULL,
    new_listings integer DEFAULT 0 NOT NULL,
    completed_shares integer DEFAULT 0 NOT NULL,
    expired_listings integer DEFAULT 0 NOT NULL,
    messages_sent integer DEFAULT 0 NOT NULL,
    notifications_sent integer DEFAULT 0 NOT NULL,
    searches_performed integer DEFAULT 0 NOT NULL,
    active_cities jsonb DEFAULT '[]'::jsonb,
    top_categories jsonb DEFAULT '[]'::jsonb,
    computed_at timestamp with time zone DEFAULT now() NOT NULL
);


--
-- Name: TABLE daily_stats; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE public.daily_stats IS 'Platform-wide daily aggregated metrics';


--
-- Name: device_attestations; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.device_attestations (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    key_id text NOT NULL,
    trust_level text DEFAULT 'unknown'::text NOT NULL,
    attestation_verified boolean DEFAULT false NOT NULL,
    user_id uuid,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    last_seen timestamp with time zone DEFAULT now() NOT NULL,
    verification_count integer DEFAULT 0 NOT NULL,
    flags jsonb DEFAULT '{}'::jsonb NOT NULL,
    bundle_id text,
    app_version text,
    os_version text,
    CONSTRAINT device_attestations_trust_level_check CHECK ((trust_level = ANY (ARRAY['unknown'::text, 'trusted'::text, 'suspicious'::text, 'blocked'::text])))
);


--
-- Name: TABLE device_attestations; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE public.device_attestations IS 'Stores device integrity verification results from App Attest and DeviceCheck';


--
-- Name: COLUMN device_attestations.key_id; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.device_attestations.key_id IS 'Unique key identifier from App Attest or hash of DeviceCheck token';


--
-- Name: COLUMN device_attestations.trust_level; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.device_attestations.trust_level IS 'Device reputation level: unknown, trusted, suspicious, or blocked';


--
-- Name: COLUMN device_attestations.attestation_verified; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.device_attestations.attestation_verified IS 'Whether the attestation was successfully verified';


--
-- Name: COLUMN device_attestations.flags; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.device_attestations.flags IS 'Additional flags for fraud detection (e.g., {"promotional_abuse": true})';


--
-- Name: device_tokens; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.device_tokens (
    profile_id uuid NOT NULL,
    token text NOT NULL,
    platform text NOT NULL,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    endpoint text,
    p256dh text,
    auth text,
    user_agent text,
    last_used_at timestamp with time zone DEFAULT now(),
    CONSTRAINT device_tokens_platform_check CHECK ((platform = ANY (ARRAY['ios'::text, 'android'::text, 'web'::text])))
);


--
-- Name: TABLE device_tokens; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE public.device_tokens IS 'Stores push notification tokens for iOS (APNs), Android (FCM), and Web (VAPID/Web Push API)';


--
-- Name: COLUMN device_tokens.token; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.device_tokens.token IS 'For iOS: APNs device token. For Android: FCM token. For Web: can be empty (use endpoint instead)';


--
-- Name: COLUMN device_tokens.endpoint; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.device_tokens.endpoint IS 'Web Push: The push service endpoint URL';


--
-- Name: COLUMN device_tokens.p256dh; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.device_tokens.p256dh IS 'Web Push: The p256dh key from PushSubscription.getKey()';


--
-- Name: COLUMN device_tokens.auth; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.device_tokens.auth IS 'Web Push: The auth key from PushSubscription.getKey()';


--
-- Name: display_name_overrides; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.display_name_overrides (
    user_id uuid NOT NULL,
    display_name text NOT NULL,
    reason text NOT NULL,
    overridden_by uuid,
    expires_at timestamp with time zone,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    CONSTRAINT display_name_overrides_display_name_check CHECK (((length(TRIM(BOTH FROM display_name)) >= 2) AND (length(display_name) <= 100))),
    CONSTRAINT display_name_overrides_reason_check CHECK ((length(reason) >= 1))
);


--
-- Name: TABLE display_name_overrides; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE public.display_name_overrides IS 'Admin-set display name overrides for users with optional expiration';


--
-- Name: COLUMN display_name_overrides.user_id; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.display_name_overrides.user_id IS 'User whose display name is being overridden';


--
-- Name: COLUMN display_name_overrides.display_name; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.display_name_overrides.display_name IS 'The corrected display name to use';


--
-- Name: COLUMN display_name_overrides.reason; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.display_name_overrides.reason IS 'Reason for the override (e.g., user request, inappropriate content)';


--
-- Name: COLUMN display_name_overrides.overridden_by; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.display_name_overrides.overridden_by IS 'Admin user who set the override';


--
-- Name: COLUMN display_name_overrides.expires_at; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.display_name_overrides.expires_at IS 'Optional expiration timestamp for temporary overrides';


--
-- Name: dynamic_content_translations; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.dynamic_content_translations (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    content_hash text NOT NULL,
    source_locale text DEFAULT 'en'::text NOT NULL,
    target_locale text NOT NULL,
    source_text text NOT NULL,
    translated_text text NOT NULL,
    content_type text DEFAULT 'general'::text NOT NULL,
    quality_score numeric(3,2) DEFAULT 0.95,
    translation_source text DEFAULT 'llm'::text,
    hit_count integer DEFAULT 0,
    last_hit_at timestamp with time zone,
    created_at timestamp with time zone DEFAULT now(),
    expires_at timestamp with time zone DEFAULT (now() + '90 days'::interval)
);


--
-- Name: email_audit_log; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.email_audit_log (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    event_type text NOT NULL,
    severity text NOT NULL,
    user_id uuid,
    target_user_id uuid,
    target_email text,
    provider text,
    action text NOT NULL,
    details jsonb DEFAULT '{}'::jsonb,
    request_id text,
    ip_address inet,
    user_agent text,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    CONSTRAINT email_audit_log_event_type_check CHECK ((event_type ~ '^[a-z_]+\.[a-z_]+$'::text)),
    CONSTRAINT email_audit_log_severity_check CHECK ((severity = ANY (ARRAY['info'::text, 'warning'::text, 'critical'::text])))
);


--
-- Name: TABLE email_audit_log; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE public.email_audit_log IS 'Audit trail for all sensitive email operations. Retains logs for compliance and forensics.';


--
-- Name: COLUMN email_audit_log.event_type; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.email_audit_log.event_type IS 'Dot-separated event type (e.g., email.send, suppression.add)';


--
-- Name: COLUMN email_audit_log.severity; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.email_audit_log.severity IS 'Event severity: info, warning, or critical';


--
-- Name: COLUMN email_audit_log.user_id; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.email_audit_log.user_id IS 'User who performed the action';


--
-- Name: COLUMN email_audit_log.target_user_id; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.email_audit_log.target_user_id IS 'User affected by the action';


--
-- Name: COLUMN email_audit_log.target_email; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.email_audit_log.target_email IS 'Email address affected';


--
-- Name: COLUMN email_audit_log.provider; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.email_audit_log.provider IS 'Email provider used (resend, brevo, etc.)';


--
-- Name: COLUMN email_audit_log.action; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.email_audit_log.action IS 'Human-readable action description';


--
-- Name: COLUMN email_audit_log.details; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.email_audit_log.details IS 'Additional context as JSON';


--
-- Name: COLUMN email_audit_log.request_id; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.email_audit_log.request_id IS 'Request ID for correlation';


--
-- Name: email_automation_flows; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.email_automation_flows (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    name text NOT NULL,
    description text,
    trigger_type text NOT NULL,
    trigger_config jsonb DEFAULT '{}'::jsonb,
    status text DEFAULT 'draft'::text NOT NULL,
    steps jsonb DEFAULT '[]'::jsonb,
    total_enrolled integer DEFAULT 0,
    total_completed integer DEFAULT 0,
    total_converted integer DEFAULT 0,
    conversion_goal text,
    created_by uuid,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    CONSTRAINT email_automation_flows_status_check CHECK ((status = ANY (ARRAY['draft'::text, 'active'::text, 'paused'::text, 'archived'::text]))),
    CONSTRAINT email_automation_flows_trigger_type_check CHECK ((trigger_type = ANY (ARRAY['user_signup'::text, 'first_listing'::text, 'first_share'::text, 'inactivity'::text, 'food_listed_nearby'::text, 'food_reserved'::text, 'food_collected'::text, 'message_received'::text, 'profile_incomplete'::text, 'milestone_reached'::text, 'segment_entry'::text, 'manual'::text, 'scheduled'::text])))
);


--
-- Name: TABLE email_automation_flows; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE public.email_automation_flows IS 'Email automation flows table. Note: The on_profile_created_automation trigger was removed on 2025-12-24 because it was causing signup failures. Re-enable when automation flows are properly configured.';


--
-- Name: email_automation_queue; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.email_automation_queue (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    enrollment_id uuid NOT NULL,
    flow_id uuid NOT NULL,
    profile_id uuid NOT NULL,
    step_index integer DEFAULT 0 NOT NULL,
    scheduled_for timestamp with time zone NOT NULL,
    status text DEFAULT 'pending'::text NOT NULL,
    attempts integer DEFAULT 0 NOT NULL,
    max_attempts integer DEFAULT 3 NOT NULL,
    last_attempt_at timestamp with time zone,
    sent_at timestamp with time zone,
    error_message text,
    email_data jsonb DEFAULT '{}'::jsonb NOT NULL,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    CONSTRAINT email_automation_queue_status_check CHECK ((status = ANY (ARRAY['pending'::text, 'processing'::text, 'sent'::text, 'failed'::text, 'cancelled'::text])))
);


--
-- Name: TABLE email_automation_queue; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE public.email_automation_queue IS 'Queue of scheduled automation emails waiting to be sent';


--
-- Name: email_bounce_events; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.email_bounce_events (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    email text NOT NULL,
    provider text NOT NULL,
    event_type text NOT NULL,
    bounce_type text,
    bounce_category text,
    message_id text,
    raw_payload jsonb DEFAULT '{}'::jsonb,
    processed_at timestamp with time zone DEFAULT now(),
    created_at timestamp with time zone DEFAULT now(),
    CONSTRAINT email_bounce_events_event_type_check CHECK ((event_type = ANY (ARRAY['bounce'::text, 'complaint'::text, 'delivery'::text, 'open'::text, 'click'::text, 'unsubscribe'::text]))),
    CONSTRAINT email_bounce_events_provider_check CHECK ((provider = ANY (ARRAY['resend'::text, 'brevo'::text, 'mailersend'::text, 'aws_ses'::text])))
);


--
-- Name: TABLE email_bounce_events; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE public.email_bounce_events IS 'Log of all bounce/complaint/delivery events for analytics';


--
-- Name: email_circuit_breaker_state; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.email_circuit_breaker_state (
    provider text NOT NULL,
    state text DEFAULT 'closed'::text NOT NULL,
    failures integer DEFAULT 0 NOT NULL,
    consecutive_successes integer DEFAULT 0 NOT NULL,
    last_failure_time timestamp with time zone,
    next_retry_time timestamp with time zone,
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    organization_id uuid NOT NULL,
    CONSTRAINT email_circuit_breaker_state_provider_check CHECK ((provider = ANY (ARRAY['resend'::text, 'brevo'::text, 'mailersend'::text, 'aws_ses'::text]))),
    CONSTRAINT email_circuit_breaker_state_state_check CHECK ((state = ANY (ARRAY['closed'::text, 'open'::text, 'half-open'::text]))),
    CONSTRAINT valid_provider CHECK ((provider = ANY (ARRAY['resend'::text, 'brevo'::text, 'mailersend'::text, 'aws_ses'::text]))),
    CONSTRAINT valid_state CHECK ((state = ANY (ARRAY['closed'::text, 'open'::text, 'half-open'::text])))
);


--
-- Name: TABLE email_circuit_breaker_state; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE public.email_circuit_breaker_state IS 'Stores circuit breaker state for email providers to prevent cascading failures';


--
-- Name: email_dead_letter_queue; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.email_dead_letter_queue (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    original_queue_id uuid,
    recipient_id uuid,
    recipient_email text NOT NULL,
    email_type text NOT NULL,
    template_name text NOT NULL,
    template_data jsonb DEFAULT '{}'::jsonb NOT NULL,
    total_attempts integer DEFAULT 0 NOT NULL,
    failure_reason text NOT NULL,
    last_error text,
    failed_providers text[] DEFAULT ARRAY[]::text[],
    first_attempt_at timestamp with time zone,
    last_attempt_at timestamp with time zone,
    moved_to_dlq_at timestamp with time zone DEFAULT now(),
    metadata jsonb DEFAULT '{}'::jsonb,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    CONSTRAINT email_dead_letter_queue_email_type_check CHECK ((email_type = ANY (ARRAY['auth'::text, 'chat'::text, 'food_listing'::text, 'feedback'::text, 'review_reminder'::text])))
);


--
-- Name: TABLE email_dead_letter_queue; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE public.email_dead_letter_queue IS 'Stores permanently failed emails that have exhausted all retry attempts';


--
-- Name: email_delivery_log; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.email_delivery_log (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    user_id uuid NOT NULL,
    campaign_id uuid,
    email_type text NOT NULL,
    template_slug text,
    status text DEFAULT 'queued'::text NOT NULL,
    provider text,
    message_id text,
    queued_at timestamp with time zone DEFAULT now() NOT NULL,
    sent_at timestamp with time zone,
    delivered_at timestamp with time zone,
    opened_at timestamp with time zone,
    clicked_at timestamp with time zone,
    error_code text,
    error_message text,
    retry_count integer DEFAULT 0 NOT NULL,
    metadata jsonb DEFAULT '{}'::jsonb NOT NULL,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    CONSTRAINT email_delivery_log_email_type_check CHECK ((email_type = ANY (ARRAY['newsletter'::text, 'digest'::text, 'notification'::text, 'transactional'::text, 'marketing'::text]))),
    CONSTRAINT email_delivery_log_status_check CHECK ((status = ANY (ARRAY['queued'::text, 'sent'::text, 'delivered'::text, 'opened'::text, 'clicked'::text, 'bounced'::text, 'complained'::text, 'failed'::text])))
);


--
-- Name: TABLE email_delivery_log; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE public.email_delivery_log IS 'Tracks every email delivery with status and timing';


--
-- Name: COLUMN email_delivery_log.status; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.email_delivery_log.status IS 'Delivery status: queued, sent, delivered, opened, clicked, bounced, complained, failed';


--
-- Name: COLUMN email_delivery_log.message_id; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.email_delivery_log.message_id IS 'Provider-assigned message ID for webhook correlation';


--
-- Name: email_health_events; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.email_health_events (
    id bigint NOT NULL,
    provider text,
    event_type text NOT NULL,
    severity text DEFAULT 'info'::text NOT NULL,
    message text NOT NULL,
    metadata jsonb,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    CONSTRAINT email_health_events_event_type_check CHECK ((event_type = ANY (ARRAY['circuit_opened'::text, 'circuit_half_opened'::text, 'circuit_closed'::text, 'manual_reset'::text, 'manual_disable'::text, 'quota_warning'::text, 'quota_exhausted'::text, 'provider_failure'::text, 'all_providers_exhausted'::text]))),
    CONSTRAINT email_health_events_provider_check CHECK ((provider = ANY (ARRAY['resend'::text, 'brevo'::text, 'mailersend'::text, 'aws_ses'::text]))),
    CONSTRAINT email_health_events_severity_check CHECK ((severity = ANY (ARRAY['info'::text, 'warning'::text, 'error'::text, 'critical'::text]))),
    CONSTRAINT valid_event_type CHECK ((event_type = ANY (ARRAY['circuit_opened'::text, 'circuit_half_opened'::text, 'circuit_closed'::text, 'manual_reset'::text, 'manual_disable'::text, 'quota_warning'::text, 'quota_exhausted'::text, 'provider_failure'::text, 'all_providers_exhausted'::text]))),
    CONSTRAINT valid_severity CHECK ((severity = ANY (ARRAY['info'::text, 'warning'::text, 'error'::text, 'critical'::text])))
);


--
-- Name: TABLE email_health_events; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE public.email_health_events IS 'Audit log of email provider health events for monitoring and debugging';


--
-- Name: email_health_events_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.email_health_events_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: email_health_events_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.email_health_events_id_seq OWNED BY public.email_health_events.id;


--
-- Name: email_logs; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.email_logs (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    recipient_id uuid,
    recipient_email text NOT NULL,
    email_type text NOT NULL,
    subject text NOT NULL,
    provider text NOT NULL,
    provider_message_id text,
    status text DEFAULT 'pending'::text,
    error_message text,
    template_data jsonb,
    sent_at timestamp with time zone DEFAULT now(),
    created_at timestamp with time zone DEFAULT now(),
    CONSTRAINT email_logs_email_type_check CHECK ((email_type = ANY (ARRAY['auth'::text, 'chat'::text, 'food_listing'::text, 'feedback'::text, 'review_reminder'::text]))),
    CONSTRAINT email_logs_provider_check CHECK ((provider = ANY (ARRAY['resend'::text, 'brevo'::text, 'mailersend'::text, 'aws_ses'::text]))),
    CONSTRAINT email_logs_status_check CHECK ((status = ANY (ARRAY['pending'::text, 'sent'::text, 'delivered'::text, 'failed'::text, 'bounced'::text])))
);


--
-- Name: TABLE email_logs; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE public.email_logs IS 'Log of all email sending attempts for debugging and analytics';


--
-- Name: email_preferences; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.email_preferences (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    profile_id uuid NOT NULL,
    chat_notifications boolean DEFAULT true,
    food_listings_notifications boolean DEFAULT true,
    feedback_notifications boolean DEFAULT false,
    review_reminders boolean DEFAULT true,
    notification_frequency text DEFAULT 'instant'::text,
    quiet_hours_start time without time zone,
    quiet_hours_end time without time zone,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    CONSTRAINT email_preferences_notification_frequency_check CHECK ((notification_frequency = ANY (ARRAY['instant'::text, 'daily_digest'::text, 'weekly_digest'::text])))
);


--
-- Name: TABLE email_preferences; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE public.email_preferences IS 'User email notification preferences and settings';


--
-- Name: email_provider_health_history; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.email_provider_health_history (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    provider text NOT NULL,
    health_score integer NOT NULL,
    success_rate numeric(5,2) NOT NULL,
    average_latency_ms numeric(10,2) NOT NULL,
    total_requests integer NOT NULL,
    successful_requests integer NOT NULL,
    failed_requests integer NOT NULL,
    snapshot_at timestamp with time zone DEFAULT now(),
    created_at timestamp with time zone DEFAULT now(),
    CONSTRAINT email_provider_health_history_provider_check CHECK ((provider = ANY (ARRAY['resend'::text, 'brevo'::text, 'mailersend'::text, 'aws_ses'::text])))
);


--
-- Name: TABLE email_provider_health_history; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE public.email_provider_health_history IS 'Historical health snapshots for trend analysis';


--
-- Name: email_provider_health_metrics; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.email_provider_health_metrics (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    provider text NOT NULL,
    health_score integer DEFAULT 100 NOT NULL,
    total_requests integer DEFAULT 0 NOT NULL,
    successful_requests integer DEFAULT 0 NOT NULL,
    failed_requests integer DEFAULT 0 NOT NULL,
    average_latency_ms integer DEFAULT 0 NOT NULL,
    circuit_state text DEFAULT 'closed'::text,
    consecutive_failures integer DEFAULT 0 NOT NULL,
    last_failure_at timestamp with time zone,
    last_success_at timestamp with time zone,
    daily_quota_used integer DEFAULT 0 NOT NULL,
    daily_quota_limit integer DEFAULT 500 NOT NULL,
    monthly_quota_used integer DEFAULT 0 NOT NULL,
    monthly_quota_limit integer DEFAULT 15000 NOT NULL,
    emails_delivered integer DEFAULT 0 NOT NULL,
    emails_opened integer DEFAULT 0 NOT NULL,
    emails_clicked integer DEFAULT 0 NOT NULL,
    emails_bounced integer DEFAULT 0 NOT NULL,
    emails_complained integer DEFAULT 0 NOT NULL,
    last_updated timestamp with time zone DEFAULT now() NOT NULL,
    last_synced_at timestamp with time zone,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    CONSTRAINT email_provider_health_metrics_circuit_state_check CHECK ((circuit_state = ANY (ARRAY['closed'::text, 'open'::text, 'half-open'::text])))
);


--
-- Name: TABLE email_provider_health_metrics; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE public.email_provider_health_metrics IS 'Real-time health metrics for email providers, synced from provider APIs';


--
-- Name: email_provider_metrics; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.email_provider_metrics (
    id bigint NOT NULL,
    provider text NOT NULL,
    date date DEFAULT CURRENT_DATE NOT NULL,
    total_requests integer DEFAULT 0 NOT NULL,
    success_count integer DEFAULT 0 NOT NULL,
    failure_count integer DEFAULT 0 NOT NULL,
    total_latency_ms bigint DEFAULT 0 NOT NULL,
    average_latency_ms numeric(10,2) GENERATED ALWAYS AS (
CASE
    WHEN (total_requests > 0) THEN ((total_latency_ms)::numeric / (total_requests)::numeric)
    ELSE (0)::numeric
END) STORED,
    success_rate numeric(5,4) GENERATED ALWAYS AS (
CASE
    WHEN (total_requests > 0) THEN ((success_count)::numeric / (total_requests)::numeric)
    ELSE (0)::numeric
END) STORED,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    CONSTRAINT email_provider_metrics_provider_check CHECK ((provider = ANY (ARRAY['resend'::text, 'brevo'::text, 'mailersend'::text, 'aws_ses'::text])))
);


--
-- Name: TABLE email_provider_metrics; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE public.email_provider_metrics IS 'Daily performance metrics for email providers including success rate and latency';


--
-- Name: email_provider_metrics_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.email_provider_metrics_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: email_provider_metrics_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.email_provider_metrics_id_seq OWNED BY public.email_provider_metrics.id;


--
-- Name: email_provider_monthly_quota; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.email_provider_monthly_quota (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    provider text NOT NULL,
    year_month text NOT NULL,
    emails_sent integer DEFAULT 0 NOT NULL,
    monthly_limit integer NOT NULL,
    organization_id uuid DEFAULT '00000000-0000-0000-0000-000000000001'::uuid NOT NULL,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    CONSTRAINT email_provider_monthly_quota_emails_sent_check CHECK ((emails_sent >= 0)),
    CONSTRAINT email_provider_monthly_quota_monthly_limit_check CHECK ((monthly_limit > 0)),
    CONSTRAINT email_provider_monthly_quota_provider_check CHECK ((provider = ANY (ARRAY['resend'::text, 'brevo'::text, 'mailersend'::text, 'aws_ses'::text])))
);


--
-- Name: TABLE email_provider_monthly_quota; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE public.email_provider_monthly_quota IS 'Monthly email quota tracking per provider';


--
-- Name: email_provider_quota; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.email_provider_quota (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    provider text NOT NULL,
    date date DEFAULT CURRENT_DATE NOT NULL,
    emails_sent integer DEFAULT 0,
    daily_limit integer NOT NULL,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    organization_id uuid NOT NULL,
    monthly_limit integer DEFAULT 3000 NOT NULL,
    CONSTRAINT email_provider_quota_daily_limit_check CHECK ((daily_limit > 0)),
    CONSTRAINT email_provider_quota_emails_sent_check CHECK ((emails_sent >= 0)),
    CONSTRAINT email_provider_quota_monthly_limit_check CHECK ((monthly_limit > 0)),
    CONSTRAINT email_provider_quota_provider_check CHECK ((provider = ANY (ARRAY['resend'::text, 'brevo'::text, 'mailersend'::text, 'aws_ses'::text])))
);


--
-- Name: TABLE email_provider_quota; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE public.email_provider_quota IS 'Daily email quota tracking for all email providers';


--
-- Name: COLUMN email_provider_quota.monthly_limit; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.email_provider_quota.monthly_limit IS 'Monthly email sending limit for the provider';


--
-- Name: email_provider_stats; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.email_provider_stats (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    provider text NOT NULL,
    date date DEFAULT CURRENT_DATE NOT NULL,
    requests_total integer DEFAULT 0 NOT NULL,
    requests_success integer DEFAULT 0 NOT NULL,
    requests_failed integer DEFAULT 0 NOT NULL,
    emails_sent integer DEFAULT 0 NOT NULL,
    emails_delivered integer DEFAULT 0 NOT NULL,
    emails_opened integer DEFAULT 0 NOT NULL,
    emails_clicked integer DEFAULT 0 NOT NULL,
    emails_bounced integer DEFAULT 0 NOT NULL,
    emails_complained integer DEFAULT 0 NOT NULL,
    avg_latency_ms integer DEFAULT 0 NOT NULL,
    total_latency_ms bigint DEFAULT 0 NOT NULL,
    daily_quota_limit integer DEFAULT 500 NOT NULL,
    monthly_quota_limit integer DEFAULT 15000 NOT NULL,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL
);


--
-- Name: TABLE email_provider_stats; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE public.email_provider_stats IS 'Real-time email provider statistics tracked per day per provider';


--
-- Name: email_suppression_list; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.email_suppression_list (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    email text NOT NULL,
    reason text NOT NULL,
    provider text,
    bounce_type text,
    bounce_subtype text,
    original_message_id text,
    metadata jsonb DEFAULT '{}'::jsonb,
    suppressed_at timestamp with time zone DEFAULT now(),
    expires_at timestamp with time zone,
    created_at timestamp with time zone DEFAULT now(),
    CONSTRAINT email_suppression_list_provider_check CHECK ((provider = ANY (ARRAY['resend'::text, 'brevo'::text, 'mailersend'::text, 'aws_ses'::text]))),
    CONSTRAINT email_suppression_list_reason_check CHECK ((reason = ANY (ARRAY['hard_bounce'::text, 'soft_bounce'::text, 'complaint'::text, 'unsubscribe'::text, 'manual'::text])))
);


--
-- Name: TABLE email_suppression_list; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE public.email_suppression_list IS 'Email addresses that should not receive emails (bounces, complaints, unsubscribes)';


--
-- Name: email_suppressions; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.email_suppressions (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    email text NOT NULL,
    reason text NOT NULL,
    source text,
    expires_at timestamp with time zone,
    created_at timestamp with time zone DEFAULT now() NOT NULL
);


--
-- Name: TABLE email_suppressions; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE public.email_suppressions IS 'Email addresses that should not receive emails';


--
-- Name: email_template_versions; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.email_template_versions (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    template_id uuid,
    version integer NOT NULL,
    subject character varying(500) NOT NULL,
    html_content text NOT NULL,
    text_content text,
    variables jsonb,
    changed_by uuid,
    changed_at timestamp with time zone DEFAULT now(),
    change_reason text
);


--
-- Name: email_templates; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.email_templates (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    name text NOT NULL,
    slug text NOT NULL,
    subject text NOT NULL,
    html_content text NOT NULL,
    text_content text,
    category text DEFAULT 'automation'::text NOT NULL,
    variables jsonb DEFAULT '[]'::jsonb,
    is_active boolean DEFAULT true,
    created_by uuid,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    metadata jsonb DEFAULT '{}'::jsonb,
    version integer DEFAULT 1,
    updated_by uuid,
    CONSTRAINT email_templates_category_check CHECK ((category = ANY (ARRAY['automation'::text, 'transactional'::text, 'marketing'::text, 'system'::text, 'digest'::text])))
);


--
-- Name: TABLE email_templates; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE public.email_templates IS 'Reusable email templates for automations and campaigns';


--
-- Name: experiment_assignments; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.experiment_assignments (
    user_id uuid NOT NULL,
    experiment_key text NOT NULL,
    variant_id text NOT NULL,
    assigned_at timestamp with time zone DEFAULT now() NOT NULL
);


--
-- Name: TABLE experiment_assignments; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE public.experiment_assignments IS 'User experiment variant assignments';


--
-- Name: experiments; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.experiments (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    key text NOT NULL,
    name text NOT NULL,
    description text,
    status text DEFAULT 'draft'::text NOT NULL,
    variants jsonb DEFAULT '[{"id": "control", "weight": 50}, {"id": "treatment", "weight": 50}]'::jsonb NOT NULL,
    target_platforms text[] DEFAULT '{}'::text[],
    user_segments text[] DEFAULT '{}'::text[],
    sample_percentage integer DEFAULT 100,
    primary_metric text,
    secondary_metrics text[] DEFAULT '{}'::text[],
    hypothesis text,
    start_date timestamp with time zone,
    end_date timestamp with time zone,
    results jsonb,
    winner_variant text,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    CONSTRAINT experiments_sample_percentage_check CHECK (((sample_percentage >= 0) AND (sample_percentage <= 100))),
    CONSTRAINT experiments_status_check CHECK ((status = ANY (ARRAY['draft'::text, 'running'::text, 'paused'::text, 'completed'::text, 'cancelled'::text])))
);


--
-- Name: TABLE experiments; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE public.experiments IS 'A/B test experiment definitions';


--
-- Name: feature_flag_overrides; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.feature_flag_overrides (
    user_id uuid NOT NULL,
    flag_key text NOT NULL,
    enabled boolean NOT NULL,
    reason text,
    created_by uuid,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    expires_at timestamp with time zone
);


--
-- Name: TABLE feature_flag_overrides; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE public.feature_flag_overrides IS 'Per-user feature flag overrides';


--
-- Name: feature_flags; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.feature_flags (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    flag_key text NOT NULL,
    display_name text NOT NULL,
    description text,
    enabled boolean DEFAULT false NOT NULL,
    rollout_percentage integer DEFAULT 100 NOT NULL,
    target_segments text[] DEFAULT '{}'::text[],
    expires_at timestamp with time zone,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    created_by uuid,
    metadata jsonb DEFAULT '{}'::jsonb NOT NULL,
    target_platforms text[] DEFAULT '{}'::text[],
    min_app_version jsonb DEFAULT '{}'::jsonb,
    config jsonb DEFAULT '{}'::jsonb,
    enabled_at timestamp with time zone,
    disabled_at timestamp with time zone,
    CONSTRAINT feature_flags_rollout_percentage_check CHECK (((rollout_percentage >= 0) AND (rollout_percentage <= 100)))
);


--
-- Name: TABLE feature_flags; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE public.feature_flags IS 'Remote feature flag configuration for controlled rollouts';


--
-- Name: COLUMN feature_flags.flag_key; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.feature_flags.flag_key IS 'Unique identifier matching FeatureFlag enum in Swift';


--
-- Name: COLUMN feature_flags.rollout_percentage; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.feature_flags.rollout_percentage IS 'Percentage of users who see this feature (0-100)';


--
-- Name: COLUMN feature_flags.target_segments; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.feature_flags.target_segments IS 'User segments this flag applies to (empty = all users)';


--
-- Name: feedback; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.feedback (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    profile_id uuid,
    name text NOT NULL,
    email text NOT NULL,
    subject text NOT NULL,
    message text NOT NULL,
    feedback_type text DEFAULT 'general'::text,
    status text DEFAULT 'new'::text,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    CONSTRAINT feedback_feedback_type_check CHECK ((feedback_type = ANY (ARRAY['bug'::text, 'feature'::text, 'general'::text, 'complaint'::text]))),
    CONSTRAINT feedback_status_check CHECK ((status = ANY (ARRAY['new'::text, 'in_progress'::text, 'resolved'::text, 'closed'::text])))
);


--
-- Name: TABLE feedback; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE public.feedback IS 'User feedback and support requests';


--
-- Name: notifications; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.notifications (
    users_ff uuid,
    status text,
    num_sent numeric,
    initial_page_name text,
    "timestamp" jsonb,
    notification_text text,
    parameter_data text,
    notification_title text,
    target_audience text,
    notification_sound text,
    user_refs text,
    error text,
    notification_image_url text,
    num_batches numeric,
    batch_index numeric,
    id bigint NOT NULL,
    profile_id uuid,
    sync_version bigint DEFAULT nextval('public.sync_version_seq'::regclass),
    CONSTRAINT check_batch_index_non_negative CHECK (((batch_index IS NULL) OR (batch_index >= (0)::numeric))),
    CONSTRAINT check_batch_index_within_range CHECK (((batch_index IS NULL) OR (num_batches IS NULL) OR (batch_index < num_batches))),
    CONSTRAINT check_num_batches_positive CHECK (((num_batches IS NULL) OR (num_batches > (0)::numeric))),
    CONSTRAINT check_num_sent_non_negative CHECK (((num_sent IS NULL) OR (num_sent >= (0)::numeric)))
);


--
-- Name: TABLE notifications; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE public.notifications IS 'Stores all FlutterFlow notifications.';


--
-- Name: ff_push_notifications_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

ALTER TABLE public.notifications ALTER COLUMN id ADD GENERATED BY DEFAULT AS IDENTITY (
    SEQUENCE NAME public.ff_push_notifications_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);


--
-- Name: forum; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.forum (
    forum_post_image text,
    forum_post_name text,
    forum_comments_counter numeric,
    forum_post_description text,
    id bigint NOT NULL,
    profile_id uuid NOT NULL,
    forum_post_created_at timestamp with time zone DEFAULT (now() AT TIME ZONE 'utc'::text) NOT NULL,
    forum_post_updated_at timestamp with time zone DEFAULT (now() AT TIME ZONE 'utc'::text) NOT NULL,
    forum_published boolean DEFAULT true NOT NULL,
    forum_likes_counter integer DEFAULT 0 NOT NULL,
    category_id integer,
    slug text,
    views_count integer DEFAULT 0,
    is_pinned boolean DEFAULT false,
    is_locked boolean DEFAULT false,
    is_edited boolean DEFAULT false,
    last_activity_at timestamp with time zone DEFAULT now(),
    search_vector tsvector,
    reactions_count jsonb DEFAULT '{}'::jsonb,
    reports_count integer DEFAULT 0,
    post_type text DEFAULT 'discussion'::text,
    best_answer_id bigint,
    rich_content jsonb,
    hot_score numeric(12,4) DEFAULT 0,
    is_featured boolean DEFAULT false,
    featured_at timestamp with time zone,
    featured_until timestamp with time zone,
    featured_by uuid,
    series_id uuid,
    series_order integer,
    CONSTRAINT check_forum_comments_non_negative CHECK (((forum_comments_counter IS NULL) OR (forum_comments_counter >= (0)::numeric))),
    CONSTRAINT check_forum_likes_non_negative CHECK ((forum_likes_counter >= 0)),
    CONSTRAINT forum_post_type_check CHECK ((post_type = ANY (ARRAY['discussion'::text, 'question'::text, 'announcement'::text, 'guide'::text])))
);


--
-- Name: TABLE forum; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE public.forum IS 'Stores forum posts.';


--
-- Name: COLUMN forum.slug; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.forum.slug IS 'URL-friendly unique identifier';


--
-- Name: COLUMN forum.is_pinned; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.forum.is_pinned IS 'Pinned posts appear at the top of lists';


--
-- Name: COLUMN forum.is_locked; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.forum.is_locked IS 'Locked posts cannot receive new comments';


--
-- Name: COLUMN forum.search_vector; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.forum.search_vector IS 'Full-text search index';


--
-- Name: COLUMN forum.hot_score; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.forum.hot_score IS 'Calculated hot score for trending algorithm';


--
-- Name: COLUMN forum.is_featured; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.forum.is_featured IS 'Whether post is currently featured by moderators';


--
-- Name: forum_activities; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.forum_activities (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    profile_id uuid NOT NULL,
    activity_type text NOT NULL,
    target_forum_id integer,
    target_comment_id integer,
    target_profile_id uuid,
    target_badge_id integer,
    target_series_id uuid,
    metadata jsonb DEFAULT '{}'::jsonb,
    is_public boolean DEFAULT true,
    created_at timestamp with time zone DEFAULT now()
);


--
-- Name: TABLE forum_activities; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE public.forum_activities IS 'Activity stream for user actions in the forum';


--
-- Name: forum_activity_types; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.forum_activity_types (
    id integer NOT NULL,
    name text NOT NULL,
    description text,
    icon_name text,
    is_public boolean DEFAULT true,
    created_at timestamp with time zone DEFAULT now()
);


--
-- Name: forum_activity_types_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.forum_activity_types_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: forum_activity_types_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.forum_activity_types_id_seq OWNED BY public.forum_activity_types.id;


--
-- Name: forum_announcement_analytics; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.forum_announcement_analytics (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    announcement_id uuid NOT NULL,
    profile_id uuid,
    event_type text NOT NULL,
    event_data jsonb,
    page_url text,
    created_at timestamp with time zone DEFAULT now(),
    CONSTRAINT forum_announcement_analytics_event_type_check CHECK ((event_type = ANY (ARRAY['view'::text, 'click'::text, 'dismiss'::text])))
);


--
-- Name: forum_announcement_dismissals; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.forum_announcement_dismissals (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    announcement_id uuid NOT NULL,
    profile_id uuid NOT NULL,
    dismissed_at timestamp with time zone DEFAULT now()
);


--
-- Name: forum_announcements; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.forum_announcements (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    title text NOT NULL,
    content text NOT NULL,
    rich_content jsonb,
    announcement_type text DEFAULT 'info'::text,
    icon_name text,
    background_color text,
    text_color text,
    target_type text DEFAULT 'all'::text,
    target_category_id integer,
    target_trust_levels integer[],
    target_segment jsonb,
    display_location text DEFAULT 'banner'::text,
    is_dismissible boolean DEFAULT true,
    is_pinned boolean DEFAULT false,
    priority integer DEFAULT 0,
    starts_at timestamp with time zone DEFAULT now(),
    ends_at timestamp with time zone,
    is_active boolean DEFAULT true,
    is_published boolean DEFAULT false,
    cta_text text,
    cta_url text,
    cta_style text DEFAULT 'primary'::text,
    views_count integer DEFAULT 0,
    clicks_count integer DEFAULT 0,
    dismissals_count integer DEFAULT 0,
    created_by uuid NOT NULL,
    updated_by uuid,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    CONSTRAINT forum_announcements_announcement_type_check CHECK ((announcement_type = ANY (ARRAY['info'::text, 'warning'::text, 'success'::text, 'error'::text, 'maintenance'::text, 'feature'::text, 'event'::text]))),
    CONSTRAINT forum_announcements_cta_style_check CHECK ((cta_style = ANY (ARRAY['primary'::text, 'secondary'::text, 'link'::text]))),
    CONSTRAINT forum_announcements_display_location_check CHECK ((display_location = ANY (ARRAY['banner'::text, 'modal'::text, 'sidebar'::text, 'inline'::text, 'notification'::text]))),
    CONSTRAINT forum_announcements_target_type_check CHECK ((target_type = ANY (ARRAY['all'::text, 'category'::text, 'trust_level'::text, 'segment'::text])))
);


--
-- Name: TABLE forum_announcements; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE public.forum_announcements IS 'Site-wide and targeted announcements';


--
-- Name: forum_author_analytics; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.forum_author_analytics (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    profile_id uuid NOT NULL,
    date date DEFAULT CURRENT_DATE NOT NULL,
    total_views integer DEFAULT 0,
    total_likes integer DEFAULT 0,
    total_comments integer DEFAULT 0,
    total_reactions integer DEFAULT 0,
    total_followers_gained integer DEFAULT 0,
    total_followers_lost integer DEFAULT 0,
    new_posts_count integer DEFAULT 0,
    top_post_id integer,
    engagement_rate numeric(5,2) DEFAULT 0,
    created_at timestamp with time zone DEFAULT now()
);


--
-- Name: TABLE forum_author_analytics; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE public.forum_author_analytics IS 'Aggregated daily analytics for authors';


--
-- Name: forum_badges; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.forum_badges (
    id integer NOT NULL,
    name text NOT NULL,
    slug text NOT NULL,
    description text NOT NULL,
    icon_name text,
    color text DEFAULT '#6366f1'::text,
    badge_type text NOT NULL,
    criteria jsonb DEFAULT '{}'::jsonb,
    points integer DEFAULT 0,
    is_active boolean DEFAULT true,
    created_at timestamp with time zone DEFAULT now(),
    CONSTRAINT forum_badges_badge_type_check CHECK ((badge_type = ANY (ARRAY['milestone'::text, 'achievement'::text, 'special'::text, 'seasonal'::text])))
);


--
-- Name: TABLE forum_badges; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE public.forum_badges IS 'Available badges for forum gamification';


--
-- Name: forum_badges_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.forum_badges_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: forum_badges_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.forum_badges_id_seq OWNED BY public.forum_badges.id;


--
-- Name: forum_bookmark_collections; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.forum_bookmark_collections (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    profile_id uuid NOT NULL,
    name text NOT NULL,
    description text,
    color text DEFAULT '#6366f1'::text,
    icon_name text DEFAULT 'folder'::text,
    is_private boolean DEFAULT true,
    is_default boolean DEFAULT false,
    sort_order integer DEFAULT 0,
    bookmarks_count integer DEFAULT 0,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now()
);


--
-- Name: TABLE forum_bookmark_collections; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE public.forum_bookmark_collections IS 'Folders/collections for organizing bookmarks';


--
-- Name: forum_categories; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.forum_categories (
    id integer NOT NULL,
    name text NOT NULL,
    slug text NOT NULL,
    description text,
    icon_name text DEFAULT 'message-circle'::text,
    color text DEFAULT '#4CAF50'::text,
    sort_order integer DEFAULT 0,
    is_active boolean DEFAULT true,
    posts_count integer DEFAULT 0,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    CONSTRAINT forum_categories_name_min_length CHECK ((char_length(name) >= 2)),
    CONSTRAINT forum_categories_slug_format CHECK ((slug ~ '^[a-z0-9-]+$'::text))
);


--
-- Name: TABLE forum_categories; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE public.forum_categories IS 'Categories for organizing forum discussions';


--
-- Name: forum_categories_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.forum_categories_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: forum_categories_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.forum_categories_id_seq OWNED BY public.forum_categories.id;


--
-- Name: forum_comment_history; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.forum_comment_history (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    comment_id bigint NOT NULL,
    editor_id uuid NOT NULL,
    previous_content text,
    edit_reason text,
    created_at timestamp with time zone DEFAULT now()
);


--
-- Name: TABLE forum_comment_history; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE public.forum_comment_history IS 'Edit history for comments';


--
-- Name: forum_comment_reactions; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.forum_comment_reactions (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    comment_id integer NOT NULL,
    profile_id uuid NOT NULL,
    reaction_type_id integer NOT NULL,
    created_at timestamp with time zone DEFAULT now()
);


--
-- Name: TABLE forum_comment_reactions; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE public.forum_comment_reactions IS 'Reactions on forum comments (emoji reactions)';


--
-- Name: forum_content_experiments; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.forum_content_experiments (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    forum_id integer NOT NULL,
    experiment_type text NOT NULL,
    variant_a text NOT NULL,
    variant_b text NOT NULL,
    variant_a_views integer DEFAULT 0,
    variant_a_clicks integer DEFAULT 0,
    variant_b_views integer DEFAULT 0,
    variant_b_clicks integer DEFAULT 0,
    winning_variant text,
    is_active boolean DEFAULT true,
    started_at timestamp with time zone DEFAULT now(),
    ended_at timestamp with time zone,
    created_at timestamp with time zone DEFAULT now(),
    CONSTRAINT forum_content_experiments_experiment_type_check CHECK ((experiment_type = ANY (ARRAY['title'::text, 'image'::text, 'description'::text]))),
    CONSTRAINT forum_content_experiments_winning_variant_check CHECK ((winning_variant = ANY (ARRAY['a'::text, 'b'::text, 'inconclusive'::text])))
);


--
-- Name: forum_conversation_participants; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.forum_conversation_participants (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    conversation_id uuid NOT NULL,
    profile_id uuid NOT NULL,
    role text DEFAULT 'member'::text,
    joined_at timestamp with time zone DEFAULT now(),
    left_at timestamp with time zone,
    last_read_at timestamp with time zone DEFAULT now(),
    is_muted boolean DEFAULT false,
    muted_until timestamp with time zone,
    nickname text,
    CONSTRAINT forum_conversation_participants_role_check CHECK ((role = ANY (ARRAY['owner'::text, 'admin'::text, 'member'::text])))
);


--
-- Name: forum_conversations; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.forum_conversations (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    title text,
    is_group boolean DEFAULT false,
    created_by uuid,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    last_message_at timestamp with time zone DEFAULT now(),
    last_message_preview text,
    is_archived boolean DEFAULT false,
    metadata jsonb DEFAULT '{}'::jsonb
);


--
-- Name: TABLE forum_conversations; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE public.forum_conversations IS 'Private messaging conversations (1:1 and group chats)';


--
-- Name: forum_drafts; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.forum_drafts (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    profile_id uuid NOT NULL,
    title text,
    description text,
    rich_content jsonb,
    category_id integer,
    post_type text DEFAULT 'discussion'::text,
    tags integer[],
    image_url text,
    poll_data jsonb,
    last_saved_at timestamp with time zone DEFAULT now(),
    created_at timestamp with time zone DEFAULT now(),
    CONSTRAINT forum_drafts_post_type_check CHECK ((post_type = ANY (ARRAY['discussion'::text, 'question'::text, 'announcement'::text, 'guide'::text]))),
    CONSTRAINT max_drafts_check CHECK (true)
);


--
-- Name: TABLE forum_drafts; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE public.forum_drafts IS 'Draft forum posts for auto-save functionality';


--
-- Name: forum_feed_preferences; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.forum_feed_preferences (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    profile_id uuid NOT NULL,
    show_posts boolean DEFAULT true,
    show_comments boolean DEFAULT true,
    show_likes boolean DEFAULT true,
    show_follows boolean DEFAULT true,
    show_badges boolean DEFAULT true,
    show_polls boolean DEFAULT true,
    show_bookmarks boolean DEFAULT false,
    show_reactions boolean DEFAULT true,
    feed_sort text DEFAULT 'recent'::text,
    hide_read_items boolean DEFAULT false,
    compact_view boolean DEFAULT false,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    CONSTRAINT forum_feed_preferences_feed_sort_check CHECK ((feed_sort = ANY (ARRAY['recent'::text, 'popular'::text, 'relevant'::text])))
);


--
-- Name: TABLE forum_feed_preferences; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE public.forum_feed_preferences IS 'User preferences for their activity feed';


--
-- Name: forum_feed_read_status; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.forum_feed_read_status (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    profile_id uuid NOT NULL,
    activity_id uuid NOT NULL,
    read_at timestamp with time zone DEFAULT now()
);


--
-- Name: forum_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

ALTER TABLE public.forum ALTER COLUMN id ADD GENERATED BY DEFAULT AS IDENTITY (
    SEQUENCE NAME public.forum_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);


--
-- Name: forum_mentions; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.forum_mentions (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    mentioned_profile_id uuid NOT NULL,
    mentioner_profile_id uuid NOT NULL,
    forum_id bigint,
    comment_id bigint,
    created_at timestamp with time zone DEFAULT now(),
    CONSTRAINT mention_target_check CHECK ((((forum_id IS NOT NULL) AND (comment_id IS NULL)) OR ((forum_id IS NULL) AND (comment_id IS NOT NULL))))
);


--
-- Name: TABLE forum_mentions; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE public.forum_mentions IS 'Tracks @username mentions in forum posts and comments';


--
-- Name: forum_message_reactions; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.forum_message_reactions (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    message_id uuid NOT NULL,
    profile_id uuid NOT NULL,
    reaction_type_id integer NOT NULL,
    created_at timestamp with time zone DEFAULT now()
);


--
-- Name: forum_message_read_receipts; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.forum_message_read_receipts (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    message_id uuid NOT NULL,
    profile_id uuid NOT NULL,
    read_at timestamp with time zone DEFAULT now()
);


--
-- Name: TABLE forum_message_read_receipts; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE public.forum_message_read_receipts IS 'Track which messages have been read by whom';


--
-- Name: forum_messages; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.forum_messages (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    conversation_id uuid NOT NULL,
    sender_id uuid,
    content text,
    rich_content jsonb,
    message_type text DEFAULT 'text'::text,
    reply_to_id uuid,
    is_edited boolean DEFAULT false,
    edited_at timestamp with time zone,
    is_deleted boolean DEFAULT false,
    deleted_at timestamp with time zone,
    created_at timestamp with time zone DEFAULT now(),
    metadata jsonb DEFAULT '{}'::jsonb,
    CONSTRAINT forum_messages_message_type_check CHECK ((message_type = ANY (ARRAY['text'::text, 'image'::text, 'file'::text, 'system'::text, 'deleted'::text])))
);


--
-- Name: TABLE forum_messages; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE public.forum_messages IS 'Messages within conversations';


--
-- Name: forum_moderation_notes; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.forum_moderation_notes (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    queue_id uuid NOT NULL,
    moderator_id uuid NOT NULL,
    note text NOT NULL,
    is_internal boolean DEFAULT true,
    created_at timestamp with time zone DEFAULT now()
);


--
-- Name: forum_moderation_queue; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.forum_moderation_queue (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    forum_id integer,
    comment_id integer,
    message_id uuid,
    profile_id uuid,
    queue_type text NOT NULL,
    content_type text NOT NULL,
    priority integer DEFAULT 0,
    status text DEFAULT 'pending'::text,
    report_id uuid,
    reporter_id uuid,
    flag_reason text,
    flag_score numeric,
    flag_details jsonb DEFAULT '{}'::jsonb,
    content_snapshot jsonb,
    assigned_to uuid,
    assigned_at timestamp with time zone,
    resolved_by uuid,
    resolved_at timestamp with time zone,
    resolution text,
    resolution_notes text,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    CONSTRAINT forum_moderation_queue_content_type_check CHECK ((content_type = ANY (ARRAY['post'::text, 'comment'::text, 'message'::text, 'profile'::text]))),
    CONSTRAINT forum_moderation_queue_queue_type_check CHECK ((queue_type = ANY (ARRAY['report'::text, 'auto_flag'::text, 'appeal'::text, 'review'::text, 'spam'::text, 'new_user'::text]))),
    CONSTRAINT forum_moderation_queue_resolution_check CHECK ((resolution = ANY (ARRAY['approved'::text, 'removed'::text, 'edited'::text, 'warning_issued'::text, 'user_banned'::text, 'no_action'::text, 'escalated'::text]))),
    CONSTRAINT forum_moderation_queue_status_check CHECK ((status = ANY (ARRAY['pending'::text, 'in_review'::text, 'resolved'::text, 'escalated'::text, 'dismissed'::text])))
);


--
-- Name: TABLE forum_moderation_queue; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE public.forum_moderation_queue IS 'Centralized queue for content moderation';


--
-- Name: forum_moderation_stats; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.forum_moderation_stats (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    moderator_id uuid NOT NULL,
    date date DEFAULT CURRENT_DATE NOT NULL,
    items_reviewed integer DEFAULT 0,
    items_approved integer DEFAULT 0,
    items_removed integer DEFAULT 0,
    warnings_issued integer DEFAULT 0,
    bans_issued integer DEFAULT 0,
    avg_response_time_minutes integer
);


--
-- Name: forum_moderator_logs; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.forum_moderator_logs (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    moderator_id uuid NOT NULL,
    action_type text NOT NULL,
    target_type text NOT NULL,
    target_id text NOT NULL,
    target_profile_id uuid,
    reason text,
    details jsonb DEFAULT '{}'::jsonb,
    ip_address inet,
    created_at timestamp with time zone DEFAULT now(),
    CONSTRAINT forum_moderator_logs_action_type_check CHECK ((action_type = ANY (ARRAY['post_remove'::text, 'post_restore'::text, 'post_lock'::text, 'post_unlock'::text, 'post_pin'::text, 'post_unpin'::text, 'comment_remove'::text, 'comment_restore'::text, 'comment_pin'::text, 'comment_unpin'::text, 'user_warn'::text, 'user_mute'::text, 'user_unmute'::text, 'user_ban'::text, 'user_unban'::text, 'report_resolve'::text, 'report_dismiss'::text, 'badge_award'::text, 'badge_revoke'::text, 'category_create'::text, 'category_update'::text, 'category_delete'::text, 'tag_create'::text, 'tag_update'::text, 'tag_delete'::text]))),
    CONSTRAINT forum_moderator_logs_target_type_check CHECK ((target_type = ANY (ARRAY['post'::text, 'comment'::text, 'user'::text, 'report'::text, 'badge'::text, 'category'::text, 'tag'::text])))
);


--
-- Name: TABLE forum_moderator_logs; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE public.forum_moderator_logs IS 'Audit log of all moderator actions for accountability';


--
-- Name: forum_notifications; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.forum_notifications (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    recipient_id uuid NOT NULL,
    actor_id uuid,
    type text NOT NULL,
    forum_id bigint,
    comment_id bigint,
    data jsonb DEFAULT '{}'::jsonb,
    is_read boolean DEFAULT false,
    created_at timestamp with time zone DEFAULT now(),
    CONSTRAINT forum_notifications_type_check CHECK ((type = ANY (ARRAY['forum_reply'::text, 'comment_reply'::text, 'mention_post'::text, 'mention_comment'::text, 'reaction'::text, 'comment_like'::text, 'post_bookmark'::text, 'trust_level_up'::text, 'badge_earned'::text, 'series_new_chapter'::text, 'poll_ended'::text])))
);


--
-- Name: TABLE forum_notifications; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE public.forum_notifications IS 'User notifications for forum activity (replies, mentions, reactions)';


--
-- Name: forum_poll_options; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.forum_poll_options (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    poll_id uuid NOT NULL,
    option_text text NOT NULL,
    votes_count integer DEFAULT 0,
    sort_order integer DEFAULT 0,
    created_at timestamp with time zone DEFAULT now()
);


--
-- Name: TABLE forum_poll_options; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE public.forum_poll_options IS 'Options for forum polls';


--
-- Name: forum_poll_votes; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.forum_poll_votes (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    poll_id uuid NOT NULL,
    option_id uuid NOT NULL,
    profile_id uuid NOT NULL,
    created_at timestamp with time zone DEFAULT now()
);


--
-- Name: TABLE forum_poll_votes; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE public.forum_poll_votes IS 'User votes on poll options';


--
-- Name: forum_polls; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.forum_polls (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    forum_id bigint NOT NULL,
    question text NOT NULL,
    poll_type text DEFAULT 'single'::text NOT NULL,
    ends_at timestamp with time zone,
    is_anonymous boolean DEFAULT false,
    show_results_before_vote boolean DEFAULT false,
    total_votes integer DEFAULT 0,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    CONSTRAINT forum_polls_poll_type_check CHECK ((poll_type = ANY (ARRAY['single'::text, 'multiple'::text])))
);


--
-- Name: TABLE forum_polls; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE public.forum_polls IS 'Polls attached to forum posts';


--
-- Name: forum_popular_searches; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.forum_popular_searches (
    id integer NOT NULL,
    query text NOT NULL,
    search_count integer DEFAULT 1,
    last_searched_at timestamp with time zone DEFAULT now(),
    first_searched_at timestamp with time zone DEFAULT now()
);


--
-- Name: TABLE forum_popular_searches; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE public.forum_popular_searches IS 'Aggregated popular search terms';


--
-- Name: forum_popular_searches_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.forum_popular_searches_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: forum_popular_searches_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.forum_popular_searches_id_seq OWNED BY public.forum_popular_searches.id;


--
-- Name: forum_post_analytics; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.forum_post_analytics (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    forum_id integer NOT NULL,
    date date DEFAULT CURRENT_DATE NOT NULL,
    views_count integer DEFAULT 0,
    unique_visitors integer DEFAULT 0,
    likes_count integer DEFAULT 0,
    comments_count integer DEFAULT 0,
    reactions_count integer DEFAULT 0,
    bookmarks_count integer DEFAULT 0,
    shares_count integer DEFAULT 0,
    avg_read_time_seconds integer DEFAULT 0,
    bounce_rate numeric(5,2) DEFAULT 0,
    referrer_sources jsonb DEFAULT '{}'::jsonb,
    device_breakdown jsonb DEFAULT '{}'::jsonb,
    created_at timestamp with time zone DEFAULT now()
);


--
-- Name: TABLE forum_post_analytics; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE public.forum_post_analytics IS 'Daily analytics snapshots for individual posts';


--
-- Name: forum_post_history; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.forum_post_history (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    forum_id bigint NOT NULL,
    editor_id uuid NOT NULL,
    previous_title text,
    previous_description text,
    previous_image text,
    edit_reason text,
    created_at timestamp with time zone DEFAULT now()
);


--
-- Name: TABLE forum_post_history; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE public.forum_post_history IS 'Edit history for forum posts';


--
-- Name: forum_post_tags; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.forum_post_tags (
    forum_id bigint NOT NULL,
    tag_id integer NOT NULL,
    created_at timestamp with time zone DEFAULT now()
);


--
-- Name: TABLE forum_post_tags; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE public.forum_post_tags IS 'Many-to-many relationship between forum posts and tags';


--
-- Name: forum_publication_queue; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.forum_publication_queue (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    scheduled_post_id uuid,
    recurring_post_id uuid,
    scheduled_for timestamp with time zone NOT NULL,
    priority integer DEFAULT 0,
    status text DEFAULT 'pending'::text,
    attempts integer DEFAULT 0,
    max_attempts integer DEFAULT 3,
    last_attempt_at timestamp with time zone,
    error_message text,
    created_at timestamp with time zone DEFAULT now(),
    CONSTRAINT forum_publication_queue_check CHECK (((scheduled_post_id IS NOT NULL) OR (recurring_post_id IS NOT NULL))),
    CONSTRAINT forum_publication_queue_status_check CHECK ((status = ANY (ARRAY['pending'::text, 'processing'::text, 'completed'::text, 'failed'::text])))
);


--
-- Name: TABLE forum_publication_queue; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE public.forum_publication_queue IS 'Queue for processing scheduled publications';


--
-- Name: forum_rate_limit_config; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.forum_rate_limit_config (
    id integer NOT NULL,
    action_type text NOT NULL,
    max_actions integer NOT NULL,
    window_seconds integer NOT NULL,
    cooldown_seconds integer DEFAULT 0,
    trust_level_multipliers jsonb DEFAULT '{"0": 1, "1": 1.5, "2": 2, "3": 3, "4": 5}'::jsonb,
    is_active boolean DEFAULT true,
    description text,
    created_at timestamp with time zone DEFAULT now()
);


--
-- Name: TABLE forum_rate_limit_config; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE public.forum_rate_limit_config IS 'Configuration for different rate limit types';


--
-- Name: forum_rate_limit_config_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.forum_rate_limit_config_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: forum_rate_limit_config_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.forum_rate_limit_config_id_seq OWNED BY public.forum_rate_limit_config.id;


--
-- Name: forum_rate_limits; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.forum_rate_limits (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    profile_id uuid NOT NULL,
    action_type text NOT NULL,
    action_count integer DEFAULT 1,
    window_start timestamp with time zone DEFAULT now(),
    window_end timestamp with time zone,
    metadata jsonb DEFAULT '{}'::jsonb,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now()
);


--
-- Name: TABLE forum_rate_limits; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE public.forum_rate_limits IS 'Tracks user actions for rate limiting';


--
-- Name: forum_reactions; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.forum_reactions (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    forum_id bigint NOT NULL,
    profile_id uuid NOT NULL,
    reaction_type_id integer NOT NULL,
    created_at timestamp with time zone DEFAULT now()
);


--
-- Name: TABLE forum_reactions; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE public.forum_reactions IS 'User reactions on forum posts';


--
-- Name: forum_reading_history; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.forum_reading_history (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    profile_id uuid NOT NULL,
    forum_id bigint NOT NULL,
    viewed_at timestamp with time zone DEFAULT now()
);


--
-- Name: TABLE forum_reading_history; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE public.forum_reading_history IS 'Timeline of posts viewed by users';


--
-- Name: forum_reading_progress; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.forum_reading_progress (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    profile_id uuid NOT NULL,
    forum_id bigint NOT NULL,
    last_read_comment_id bigint,
    last_read_at timestamp with time zone DEFAULT now(),
    read_count integer DEFAULT 1,
    scroll_position integer DEFAULT 0,
    time_spent_seconds integer DEFAULT 0,
    is_fully_read boolean DEFAULT false,
    created_at timestamp with time zone DEFAULT now()
);


--
-- Name: TABLE forum_reading_progress; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE public.forum_reading_progress IS 'Tracks user reading progress on forum posts';


--
-- Name: forum_recurring_posts; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.forum_recurring_posts (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    profile_id uuid NOT NULL,
    title_template text NOT NULL,
    description_template text,
    category_id integer,
    post_type text DEFAULT 'discussion'::text,
    tags integer[],
    recurrence_type text NOT NULL,
    recurrence_day integer,
    recurrence_time time without time zone NOT NULL,
    timezone text DEFAULT 'UTC'::text,
    custom_cron text,
    template_variables jsonb DEFAULT '{}'::jsonb,
    is_active boolean DEFAULT true,
    next_scheduled_at timestamp with time zone,
    last_published_at timestamp with time zone,
    total_published integer DEFAULT 0,
    max_occurrences integer,
    end_date date,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    CONSTRAINT forum_recurring_posts_recurrence_type_check CHECK ((recurrence_type = ANY (ARRAY['daily'::text, 'weekly'::text, 'biweekly'::text, 'monthly'::text, 'custom'::text])))
);


--
-- Name: TABLE forum_recurring_posts; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE public.forum_recurring_posts IS 'Templates for recurring post schedules';


--
-- Name: forum_reports; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.forum_reports (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    reporter_id uuid NOT NULL,
    reported_profile_id uuid,
    forum_id bigint,
    comment_id bigint,
    reason text NOT NULL,
    description text,
    status text DEFAULT 'pending'::text NOT NULL,
    moderator_id uuid,
    moderator_notes text,
    resolved_at timestamp with time zone,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    CONSTRAINT forum_reports_reason_check CHECK ((reason = ANY (ARRAY['spam'::text, 'harassment'::text, 'hate_speech'::text, 'misinformation'::text, 'inappropriate'::text, 'off_topic'::text, 'other'::text]))),
    CONSTRAINT forum_reports_status_check CHECK ((status = ANY (ARRAY['pending'::text, 'under_review'::text, 'resolved_removed'::text, 'resolved_warning'::text, 'resolved_no_action'::text, 'dismissed'::text]))),
    CONSTRAINT report_target_check CHECK ((((forum_id IS NOT NULL) AND (comment_id IS NULL)) OR ((forum_id IS NULL) AND (comment_id IS NOT NULL))))
);


--
-- Name: TABLE forum_reports; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE public.forum_reports IS 'Content reports for forum moderation';


--
-- Name: forum_reputation_actions; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.forum_reputation_actions (
    id integer NOT NULL,
    action_key text NOT NULL,
    description text NOT NULL,
    points integer NOT NULL,
    is_positive boolean DEFAULT true,
    daily_limit integer,
    is_active boolean DEFAULT true,
    created_at timestamp with time zone DEFAULT now()
);


--
-- Name: forum_reputation_actions_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.forum_reputation_actions_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: forum_reputation_actions_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.forum_reputation_actions_id_seq OWNED BY public.forum_reputation_actions.id;


--
-- Name: forum_reputation_history; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.forum_reputation_history (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    profile_id uuid NOT NULL,
    action_key text NOT NULL,
    points integer NOT NULL,
    source_profile_id uuid,
    source_forum_id bigint,
    source_comment_id bigint,
    description text,
    metadata jsonb DEFAULT '{}'::jsonb,
    created_at timestamp with time zone DEFAULT now()
);


--
-- Name: TABLE forum_reputation_history; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE public.forum_reputation_history IS 'Log of all reputation changes';


--
-- Name: forum_reputation_levels; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.forum_reputation_levels (
    level integer NOT NULL,
    title text NOT NULL,
    min_points integer NOT NULL,
    color text,
    icon_name text,
    perks jsonb DEFAULT '{}'::jsonb,
    created_at timestamp with time zone DEFAULT now()
);


--
-- Name: forum_saved_searches; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.forum_saved_searches (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    profile_id uuid NOT NULL,
    name text NOT NULL,
    query text NOT NULL,
    filters jsonb DEFAULT '{}'::jsonb,
    notify_on_new boolean DEFAULT false,
    last_notified_at timestamp with time zone,
    results_count integer DEFAULT 0,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    CONSTRAINT forum_saved_searches_name_check CHECK ((char_length(name) >= 1))
);


--
-- Name: TABLE forum_saved_searches; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE public.forum_saved_searches IS 'User saved searches for quick access';


--
-- Name: forum_scheduled_posts; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.forum_scheduled_posts (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    profile_id uuid NOT NULL,
    title text NOT NULL,
    description text,
    rich_content jsonb,
    image_url text,
    category_id integer,
    post_type text DEFAULT 'discussion'::text,
    tags integer[],
    poll_data jsonb,
    series_id uuid,
    series_order integer,
    scheduled_for timestamp with time zone NOT NULL,
    timezone text DEFAULT 'UTC'::text,
    status text DEFAULT 'scheduled'::text,
    published_at timestamp with time zone,
    published_forum_id integer,
    failure_reason text,
    notify_followers boolean DEFAULT true,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    CONSTRAINT forum_scheduled_posts_post_type_check CHECK ((post_type = ANY (ARRAY['discussion'::text, 'question'::text, 'article'::text, 'announcement'::text, 'poll'::text]))),
    CONSTRAINT forum_scheduled_posts_status_check CHECK ((status = ANY (ARRAY['scheduled'::text, 'published'::text, 'failed'::text, 'cancelled'::text])))
);


--
-- Name: TABLE forum_scheduled_posts; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE public.forum_scheduled_posts IS 'Posts scheduled for future publication';


--
-- Name: forum_search_history; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.forum_search_history (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    profile_id uuid NOT NULL,
    query text NOT NULL,
    filters jsonb DEFAULT '{}'::jsonb,
    results_count integer DEFAULT 0,
    searched_at timestamp with time zone DEFAULT now()
);


--
-- Name: TABLE forum_search_history; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE public.forum_search_history IS 'User search history for personalization';


--
-- Name: forum_series; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.forum_series (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    profile_id uuid NOT NULL,
    title text NOT NULL,
    slug text NOT NULL,
    description text,
    cover_image text,
    category_id integer,
    is_published boolean DEFAULT false,
    is_complete boolean DEFAULT false,
    posts_count integer DEFAULT 0,
    total_views integer DEFAULT 0,
    total_likes integer DEFAULT 0,
    estimated_read_time integer DEFAULT 0,
    difficulty_level text DEFAULT 'beginner'::text,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    published_at timestamp with time zone,
    CONSTRAINT forum_series_difficulty_level_check CHECK ((difficulty_level = ANY (ARRAY['beginner'::text, 'intermediate'::text, 'advanced'::text]))),
    CONSTRAINT forum_series_slug_check CHECK ((slug ~ '^[a-z0-9-]+$'::text)),
    CONSTRAINT forum_series_title_check CHECK ((char_length(title) >= 3))
);


--
-- Name: TABLE forum_series; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE public.forum_series IS 'Collections of related forum posts organized as series/tutorials';


--
-- Name: forum_series_posts; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.forum_series_posts (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    series_id uuid NOT NULL,
    forum_id bigint NOT NULL,
    sort_order integer DEFAULT 0 NOT NULL,
    chapter_title text,
    chapter_description text,
    is_free_preview boolean DEFAULT false,
    created_at timestamp with time zone DEFAULT now()
);


--
-- Name: TABLE forum_series_posts; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE public.forum_series_posts IS 'Junction table linking posts to series with ordering';


--
-- Name: forum_subscriptions; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.forum_subscriptions (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    profile_id uuid NOT NULL,
    forum_id bigint,
    category_id integer,
    notify_on_reply boolean DEFAULT true,
    notify_on_mention boolean DEFAULT true,
    notify_on_reaction boolean DEFAULT false,
    email_notifications boolean DEFAULT false,
    created_at timestamp with time zone DEFAULT now(),
    CONSTRAINT subscription_target_check CHECK ((((forum_id IS NOT NULL) AND (category_id IS NULL)) OR ((forum_id IS NULL) AND (category_id IS NOT NULL))))
);


--
-- Name: TABLE forum_subscriptions; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE public.forum_subscriptions IS 'User subscriptions to forum posts and categories';


--
-- Name: forum_system_messages; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.forum_system_messages (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    message_key text NOT NULL,
    title text NOT NULL,
    content text NOT NULL,
    message_type text DEFAULT 'info'::text,
    variables jsonb DEFAULT '{}'::jsonb,
    is_active boolean DEFAULT true,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    CONSTRAINT forum_system_messages_message_type_check CHECK ((message_type = ANY (ARRAY['info'::text, 'warning'::text, 'error'::text, 'success'::text])))
);


--
-- Name: TABLE forum_system_messages; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE public.forum_system_messages IS 'Reusable system message templates';


--
-- Name: forum_tags; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.forum_tags (
    id integer NOT NULL,
    name text NOT NULL,
    slug text NOT NULL,
    description text,
    color text DEFAULT '#6B7280'::text,
    usage_count integer DEFAULT 0,
    created_at timestamp with time zone DEFAULT now(),
    CONSTRAINT forum_tags_name_min CHECK ((char_length(name) >= 2)),
    CONSTRAINT forum_tags_slug_format CHECK ((slug ~ '^[a-z0-9-]+$'::text))
);


--
-- Name: TABLE forum_tags; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE public.forum_tags IS 'Tags for categorizing forum posts';


--
-- Name: forum_tags_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.forum_tags_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: forum_tags_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.forum_tags_id_seq OWNED BY public.forum_tags.id;


--
-- Name: forum_trust_levels; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.forum_trust_levels (
    level integer NOT NULL,
    name text NOT NULL,
    description text,
    color text DEFAULT '#6B7280'::text,
    min_days_since_join integer DEFAULT 0,
    min_posts_read integer DEFAULT 0,
    min_topics_read integer DEFAULT 0,
    min_posts_created integer DEFAULT 0,
    min_topics_created integer DEFAULT 0,
    min_likes_given integer DEFAULT 0,
    min_likes_received integer DEFAULT 0,
    min_replies_received integer DEFAULT 0,
    min_time_spent_minutes integer DEFAULT 0,
    can_post boolean DEFAULT true,
    can_reply boolean DEFAULT true,
    can_like boolean DEFAULT true,
    can_flag boolean DEFAULT false,
    can_edit_own_posts boolean DEFAULT true,
    can_delete_own_posts boolean DEFAULT false,
    can_upload_images boolean DEFAULT false,
    can_post_links boolean DEFAULT false,
    can_mention_users boolean DEFAULT false,
    can_send_messages boolean DEFAULT false,
    can_create_polls boolean DEFAULT false,
    can_create_wiki boolean DEFAULT false,
    max_posts_per_day integer DEFAULT 5,
    max_topics_per_day integer DEFAULT 1,
    max_likes_per_day integer DEFAULT 10,
    max_flags_per_day integer DEFAULT 0,
    created_at timestamp with time zone DEFAULT now()
);


--
-- Name: TABLE forum_trust_levels; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE public.forum_trust_levels IS 'Trust level definitions with requirements and permissions';


--
-- Name: forum_user_badges; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.forum_user_badges (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    profile_id uuid NOT NULL,
    badge_id integer NOT NULL,
    awarded_at timestamp with time zone DEFAULT now(),
    awarded_by uuid,
    is_featured boolean DEFAULT false
);


--
-- Name: TABLE forum_user_badges; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE public.forum_user_badges IS 'Badges earned by users';


--
-- Name: forum_user_blocks; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.forum_user_blocks (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    blocker_id uuid NOT NULL,
    blocked_id uuid NOT NULL,
    reason text,
    created_at timestamp with time zone DEFAULT now(),
    CONSTRAINT forum_user_blocks_check CHECK ((blocker_id <> blocked_id))
);


--
-- Name: TABLE forum_user_blocks; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE public.forum_user_blocks IS 'User block relationships for content filtering';


--
-- Name: forum_user_follows; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.forum_user_follows (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    follower_id uuid NOT NULL,
    following_id uuid NOT NULL,
    notify_on_new_post boolean DEFAULT true,
    created_at timestamp with time zone DEFAULT now(),
    CONSTRAINT no_self_follow CHECK ((follower_id <> following_id))
);


--
-- Name: TABLE forum_user_follows; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE public.forum_user_follows IS 'User follows for forum members';


--
-- Name: forum_user_reputation; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.forum_user_reputation (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    profile_id uuid NOT NULL,
    total_points integer DEFAULT 0,
    positive_points integer DEFAULT 0,
    negative_points integer DEFAULT 0,
    reputation_level integer DEFAULT 1,
    level_title text DEFAULT 'Newcomer'::text,
    points_this_week integer DEFAULT 0,
    points_this_month integer DEFAULT 0,
    week_start_date date DEFAULT CURRENT_DATE,
    month_start_date date DEFAULT (date_trunc('month'::text, (CURRENT_DATE)::timestamp with time zone))::date,
    current_streak integer DEFAULT 0,
    longest_streak integer DEFAULT 0,
    last_activity_date date,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now()
);


--
-- Name: TABLE forum_user_reputation; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE public.forum_user_reputation IS 'Aggregated reputation scores for users';


--
-- Name: forum_user_stats; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.forum_user_stats (
    profile_id uuid NOT NULL,
    posts_count integer DEFAULT 0,
    comments_count integer DEFAULT 0,
    reactions_received integer DEFAULT 0,
    helpful_count integer DEFAULT 0,
    reputation_score integer DEFAULT 0,
    joined_forum_at timestamp with time zone DEFAULT now(),
    last_post_at timestamp with time zone,
    last_comment_at timestamp with time zone,
    updated_at timestamp with time zone DEFAULT now(),
    followers_count integer DEFAULT 0,
    following_count integer DEFAULT 0,
    trust_level integer DEFAULT 0,
    topics_read integer DEFAULT 0,
    posts_read integer DEFAULT 0,
    time_spent_minutes integer DEFAULT 0,
    likes_given integer DEFAULT 0,
    likes_received integer DEFAULT 0,
    replies_received integer DEFAULT 0,
    flags_agreed integer DEFAULT 0,
    was_warned boolean DEFAULT false,
    was_silenced boolean DEFAULT false,
    silenced_until timestamp with time zone,
    trust_level_locked boolean DEFAULT false
);


--
-- Name: TABLE forum_user_stats; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE public.forum_user_stats IS 'User statistics and reputation for forum gamification';


--
-- Name: COLUMN forum_user_stats.trust_level; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.forum_user_stats.trust_level IS 'User trust level (0-4) based on activity';


--
-- Name: forum_user_warnings; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.forum_user_warnings (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    profile_id uuid NOT NULL,
    moderator_id uuid NOT NULL,
    queue_id uuid,
    warning_type text NOT NULL,
    reason text NOT NULL,
    details jsonb DEFAULT '{}'::jsonb,
    ban_until timestamp with time zone,
    ban_lifted_at timestamp with time zone,
    ban_lifted_by uuid,
    is_active boolean DEFAULT true,
    acknowledged_at timestamp with time zone,
    created_at timestamp with time zone DEFAULT now(),
    expires_at timestamp with time zone,
    CONSTRAINT forum_user_warnings_warning_type_check CHECK ((warning_type = ANY (ARRAY['verbal'::text, 'written'::text, 'final'::text, 'temp_ban'::text, 'perm_ban'::text])))
);


--
-- Name: TABLE forum_user_warnings; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE public.forum_user_warnings IS 'User warnings and ban records';


--
-- Name: grok_usage_logs; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.grok_usage_logs (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    model text NOT NULL,
    tokens integer DEFAULT 0 NOT NULL,
    "timestamp" timestamp with time zone DEFAULT now() NOT NULL,
    created_at timestamp with time zone DEFAULT now()
);


--
-- Name: TABLE grok_usage_logs; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE public.grok_usage_logs IS 'Tracks Grok AI API usage for cost monitoring';


--
-- Name: handlers; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.handlers (
    handler_name text,
    icon_image text,
    handlers_description text,
    qr_code text,
    profile_id uuid NOT NULL,
    id bigint NOT NULL
);


--
-- Name: TABLE handlers; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE public.handlers IS 'Stores some useful information that doesn''t fit anywhere else.';


--
-- Name: handlers_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

ALTER TABLE public.handlers ALTER COLUMN id ADD GENERATED BY DEFAULT AS IDENTITY (
    SEQUENCE NAME public.handlers_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);


--
-- Name: image_upload_metrics_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.image_upload_metrics_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: image_upload_metrics_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.image_upload_metrics_id_seq OWNED BY public.image_upload_metrics.id;


--
-- Name: image_upload_stats; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW public.image_upload_stats AS
 SELECT image_upload_metrics.bucket,
    count(*) AS total_uploads,
    sum(image_upload_metrics.original_size) AS total_original_size,
    sum(image_upload_metrics.compressed_size) AS total_compressed_size,
    sum(image_upload_metrics.saved_bytes) AS total_saved_bytes,
    round(avg(image_upload_metrics.processing_time_ms)) AS avg_processing_time_ms,
    count(DISTINCT image_upload_metrics.user_id) AS unique_users,
    date_trunc('day'::text, image_upload_metrics.uploaded_at) AS upload_date
   FROM public.image_upload_metrics
  WHERE (image_upload_metrics.uploaded_at > (now() - '30 days'::interval))
  GROUP BY image_upload_metrics.bucket, (date_trunc('day'::text, image_upload_metrics.uploaded_at))
  ORDER BY (date_trunc('day'::text, image_upload_metrics.uploaded_at)) DESC, image_upload_metrics.bucket;


--
-- Name: VIEW image_upload_stats; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON VIEW public.image_upload_stats IS 'Daily upload statistics by bucket';


--
-- Name: in_app_notifications; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.in_app_notifications (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    user_id uuid NOT NULL,
    title text NOT NULL,
    body text NOT NULL,
    data jsonb DEFAULT '{}'::jsonb,
    image_url text,
    action_url text,
    category text DEFAULT 'system'::text NOT NULL,
    read_at timestamp with time zone,
    created_at timestamp with time zone DEFAULT now() NOT NULL
);


--
-- Name: TABLE in_app_notifications; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE public.in_app_notifications IS 'Storage for in-app notifications delivered via Supabase Realtime';


--
-- Name: languages; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.languages (
    country_flag jsonb,
    "flagCode" text,
    flag_url text,
    "languageCode" text,
    language text,
    id bigint NOT NULL
);


--
-- Name: TABLE languages; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE public.languages IS 'Stores languages.';


--
-- Name: languages_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

ALTER TABLE public.languages ALTER COLUMN id ADD GENERATED BY DEFAULT AS IDENTITY (
    SEQUENCE NAME public.languages_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);


--
-- Name: legal; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.legal (
    covid19 text,
    id bigint NOT NULL
);


--
-- Name: TABLE legal; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE public.legal IS 'Stores legal documentation.';


--
-- Name: legal_documents; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.legal_documents (
    id uuid DEFAULT extensions.uuid_generate_v4() NOT NULL,
    type text NOT NULL,
    locale text NOT NULL,
    title text NOT NULL,
    content text NOT NULL,
    version text DEFAULT '1.0.0'::text NOT NULL,
    effective_date timestamp with time zone DEFAULT now() NOT NULL,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    CONSTRAINT legal_documents_type_check CHECK ((type = ANY (ARRAY['terms'::text, 'privacy'::text])))
);


--
-- Name: TABLE legal_documents; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE public.legal_documents IS 'Stores localized legal documents (Terms of Service, Privacy Policy)';


--
-- Name: COLUMN legal_documents.type; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.legal_documents.type IS 'Document type: terms or privacy';


--
-- Name: COLUMN legal_documents.locale; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.legal_documents.locale IS 'Language locale code (e.g., en, es, fr)';


--
-- Name: COLUMN legal_documents.content; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.legal_documents.content IS 'Markdown-formatted document content';


--
-- Name: legal_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

ALTER TABLE public.legal ALTER COLUMN id ADD GENERATED BY DEFAULT AS IDENTITY (
    SEQUENCE NAME public.legal_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);


--
-- Name: likes_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

ALTER TABLE public.likes ALTER COLUMN id ADD GENERATED BY DEFAULT AS IDENTITY (
    SEQUENCE NAME public.likes_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);


--
-- Name: location_update_queue; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.location_update_queue (
    id integer NOT NULL,
    post_id bigint NOT NULL,
    created_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP NOT NULL,
    post_address text,
    status text DEFAULT 'pending'::text,
    retry_count integer DEFAULT 0,
    max_retries integer DEFAULT 3,
    error_message text,
    updated_at timestamp with time zone DEFAULT now(),
    last_attempt_at timestamp with time zone,
    completed_at timestamp with time zone
);


--
-- Name: TABLE location_update_queue; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE public.location_update_queue IS 'Queue for managing geocoding requests with retry logic';


--
-- Name: location_update_queue_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.location_update_queue_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: location_update_queue_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.location_update_queue_id_seq OWNED BY public.location_update_queue.id;


--
-- Name: mfa_configuration; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.mfa_configuration (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    profile_id uuid NOT NULL,
    is_mfa_enabled boolean DEFAULT false,
    mfa_method text,
    phone_verified boolean DEFAULT false,
    email_verified boolean DEFAULT false,
    require_mfa_for_admin boolean DEFAULT true,
    backup_codes text[],
    backup_codes_used text[],
    mfa_enabled_at timestamp with time zone,
    last_mfa_verification_at timestamp with time zone,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    CONSTRAINT mfa_configuration_mfa_method_check CHECK ((mfa_method = ANY (ARRAY['sms'::text, 'email'::text, 'both'::text])))
);


--
-- Name: mfa_rate_limits; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.mfa_rate_limits (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    profile_id uuid,
    ip_address inet,
    limit_type text NOT NULL,
    attempt_count integer DEFAULT 1,
    window_start timestamp with time zone DEFAULT now() NOT NULL,
    window_duration interval DEFAULT '00:15:00'::interval,
    max_attempts integer DEFAULT 5,
    is_locked_out boolean DEFAULT false,
    locked_until timestamp with time zone,
    last_attempt_at timestamp with time zone DEFAULT now(),
    metadata jsonb,
    CONSTRAINT mfa_rate_limits_limit_type_check CHECK ((limit_type = ANY (ARRAY['mfa_attempts'::text, 'login_attempts'::text, 'admin_actions'::text, 'api_calls'::text])))
);


--
-- Name: mfa_sessions; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.mfa_sessions (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    profile_id uuid NOT NULL,
    session_id uuid NOT NULL,
    current_aal text NOT NULL,
    mfa_verified_at timestamp with time zone,
    mfa_method_used text,
    ip_address inet,
    user_agent text,
    device_fingerprint text,
    expires_at timestamp with time zone DEFAULT (now() + '01:00:00'::interval) NOT NULL,
    last_activity_at timestamp with time zone DEFAULT now(),
    is_active boolean DEFAULT true,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    CONSTRAINT mfa_sessions_current_aal_check CHECK ((current_aal = ANY (ARRAY['aal1'::text, 'aal2'::text]))),
    CONSTRAINT mfa_sessions_mfa_method_used_check CHECK ((mfa_method_used = ANY (ARRAY['sms'::text, 'email'::text, 'backup_code'::text])))
);


--
-- Name: mfa_verification_attempts; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.mfa_verification_attempts (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    profile_id uuid NOT NULL,
    verification_method text NOT NULL,
    code_hash text NOT NULL,
    attempts_count integer DEFAULT 0,
    max_attempts integer DEFAULT 5,
    is_verified boolean DEFAULT false,
    is_expired boolean DEFAULT false,
    ip_address inet,
    user_agent text,
    expires_at timestamp with time zone DEFAULT (now() + '00:05:00'::interval) NOT NULL,
    verified_at timestamp with time zone,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    CONSTRAINT mfa_verification_attempts_verification_method_check CHECK ((verification_method = ANY (ARRAY['sms'::text, 'email'::text])))
);


--
-- Name: moderation_queue; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.moderation_queue (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    item_type text NOT NULL,
    item_id uuid NOT NULL,
    reporter_id uuid,
    reason text,
    status text DEFAULT 'pending'::text NOT NULL,
    reviewed_by uuid,
    reviewed_at timestamp with time zone,
    resolution_notes text,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    CONSTRAINT moderation_queue_item_type_check CHECK ((item_type = ANY (ARRAY['listing'::text, 'user'::text, 'message'::text, 'review'::text, 'post'::text, 'user_block'::text]))),
    CONSTRAINT moderation_queue_status_check CHECK ((status = ANY (ARRAY['pending'::text, 'reviewing'::text, 'resolved'::text, 'dismissed'::text])))
);


--
-- Name: TABLE moderation_queue; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE public.moderation_queue IS 'Queue for moderating reported content and blocked users';


--
-- Name: COLUMN moderation_queue.item_type; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.moderation_queue.item_type IS 'Type of content: listing, user, message, review, post, user_block';


--
-- Name: COLUMN moderation_queue.status; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.moderation_queue.status IS 'Review status: pending, reviewing, resolved, dismissed';


--
-- Name: profile_stats; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.profile_stats (
    profile_id uuid NOT NULL,
    reviews_post_counter integer DEFAULT 0,
    reviews_challenge_counter integer DEFAULT 0,
    reviews_forum_counter integer DEFAULT 0,
    reviewed_posts_average_rating smallint DEFAULT 0,
    reviewed_forum_average_rating smallint DEFAULT 0,
    reviewed_challenges_average_rating smallint DEFAULT 0,
    liked_posts_counter integer DEFAULT 0,
    liked_forums_counter integer DEFAULT 0,
    liked_challenges_counter integer DEFAULT 0,
    four_stars_rating boolean DEFAULT false,
    five_stars_rating boolean DEFAULT false,
    shared_posts_with_five_users boolean DEFAULT false,
    shared_posts_counter integer DEFAULT 0,
    shared_forums_counter integer DEFAULT 0,
    shared_challenges_counter integer DEFAULT 0,
    items_shared integer DEFAULT 0,
    items_received integer DEFAULT 0,
    rating_average numeric DEFAULT 0.0,
    rating_count integer DEFAULT 0,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    CONSTRAINT profile_stats_items_received_check CHECK ((items_received >= 0)),
    CONSTRAINT profile_stats_items_shared_check CHECK ((items_shared >= 0)),
    CONSTRAINT profile_stats_liked_challenges_counter_check CHECK ((liked_challenges_counter >= 0)),
    CONSTRAINT profile_stats_liked_forums_counter_check CHECK ((liked_forums_counter >= 0)),
    CONSTRAINT profile_stats_liked_posts_counter_check CHECK ((liked_posts_counter >= 0)),
    CONSTRAINT profile_stats_rating_average_check CHECK (((rating_average >= (0)::numeric) AND (rating_average <= 5.0))),
    CONSTRAINT profile_stats_rating_count_check CHECK ((rating_count >= 0)),
    CONSTRAINT profile_stats_reviewed_challenges_average_rating_check CHECK (((reviewed_challenges_average_rating >= 0) AND (reviewed_challenges_average_rating <= 5))),
    CONSTRAINT profile_stats_reviewed_forum_average_rating_check CHECK (((reviewed_forum_average_rating >= 0) AND (reviewed_forum_average_rating <= 5))),
    CONSTRAINT profile_stats_reviewed_posts_average_rating_check CHECK (((reviewed_posts_average_rating >= 0) AND (reviewed_posts_average_rating <= 5))),
    CONSTRAINT profile_stats_reviews_challenge_counter_check CHECK ((reviews_challenge_counter >= 0)),
    CONSTRAINT profile_stats_reviews_forum_counter_check CHECK ((reviews_forum_counter >= 0)),
    CONSTRAINT profile_stats_reviews_post_counter_check CHECK ((reviews_post_counter >= 0)),
    CONSTRAINT profile_stats_shared_challenges_counter_check CHECK ((shared_challenges_counter >= 0)),
    CONSTRAINT profile_stats_shared_forums_counter_check CHECK ((shared_forums_counter >= 0)),
    CONSTRAINT profile_stats_shared_posts_counter_check CHECK ((shared_posts_counter >= 0))
);


--
-- Name: TABLE profile_stats; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE public.profile_stats IS 'Separated statistics and counters from profiles table for better performance';


--
-- Name: user_notifications; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.user_notifications (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    recipient_id uuid NOT NULL,
    actor_id uuid,
    type text NOT NULL,
    title text NOT NULL,
    body text,
    post_id bigint,
    room_id uuid,
    review_id bigint,
    data jsonb DEFAULT '{}'::jsonb,
    is_read boolean DEFAULT false,
    read_at timestamp with time zone,
    push_sent boolean DEFAULT false,
    push_sent_at timestamp with time zone,
    email_sent boolean DEFAULT false,
    email_sent_at timestamp with time zone,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    CONSTRAINT user_notifications_type_check CHECK ((type = ANY (ARRAY['new_message'::text, 'post_claimed'::text, 'post_arranged'::text, 'review_received'::text, 'review_reminder'::text, 'post_expiring'::text, 'nearby_post'::text, 'welcome'::text, 'system'::text])))
);


--
-- Name: TABLE user_notifications; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE public.user_notifications IS 'Unified notification system for all app events';


--
-- Name: COLUMN user_notifications.type; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.user_notifications.type IS 'Notification type: new_message, post_claimed, post_arranged, review_received, review_reminder, post_expiring, nearby_post, welcome, system';


--
-- Name: COLUMN user_notifications.data; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.user_notifications.data IS 'Flexible JSON for type-specific additional data';


--
-- Name: mv_user_stats; Type: MATERIALIZED VIEW; Schema: public; Owner: -
--

CREATE MATERIALIZED VIEW public.mv_user_stats AS
 SELECT p.id AS user_id,
    count(DISTINCT po.id) FILTER (WHERE ((po.is_active = true) AND (po.post_type = 'food'::text))) AS active_listings,
    count(DISTINCT po.id) FILTER (WHERE ((po.is_active = true) AND (po.post_type = 'request'::text))) AS pending_requests,
    count(DISTINCT un.id) FILTER (WHERE (un.is_read = false)) AS unread_notifications,
    count(DISTINCT r.id) FILTER (WHERE ((r.last_message_sent_by IS DISTINCT FROM p.id) AND ((r.last_message_seen_by IS NULL) OR (r.last_message_seen_by IS DISTINCT FROM p.id)) AND (r.last_message IS NOT NULL) AND (r.last_message <> ''::text))) AS unread_messages,
    COALESCE(ps.items_shared, 0) AS items_shared,
    COALESCE(ps.rating_average, 0.0) AS rating_average,
    COALESCE(ps.rating_count, 0) AS rating_count,
    max(po.created_at) AS last_listing_at,
    max(un.created_at) AS last_notification_at,
    max(r.last_message_time) AS last_message_at,
    now() AS refreshed_at
   FROM ((((public.profiles p
     LEFT JOIN public.posts po ON ((po.profile_id = p.id)))
     LEFT JOIN public.user_notifications un ON ((un.recipient_id = p.id)))
     LEFT JOIN public.rooms r ON (((r.sharer = p.id) OR (r.requester = p.id))))
     LEFT JOIN public.profile_stats ps ON ((ps.profile_id = p.id)))
  WHERE (p.is_active = true)
  GROUP BY p.id, ps.items_shared, ps.rating_average, ps.rating_count
  WITH NO DATA;


--
-- Name: newsletter_campaigns; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.newsletter_campaigns (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    name text NOT NULL,
    subject text NOT NULL,
    preview_text text,
    html_content text,
    plain_text_content text,
    status text DEFAULT 'draft'::text NOT NULL,
    campaign_type text DEFAULT 'newsletter'::text NOT NULL,
    segment_id uuid,
    segment_criteria jsonb DEFAULT '{}'::jsonb,
    scheduled_at timestamp with time zone,
    sent_at timestamp with time zone,
    completed_at timestamp with time zone,
    total_recipients integer DEFAULT 0,
    total_sent integer DEFAULT 0,
    total_delivered integer DEFAULT 0,
    total_opened integer DEFAULT 0,
    total_clicked integer DEFAULT 0,
    total_bounced integer DEFAULT 0,
    total_unsubscribed integer DEFAULT 0,
    total_complained integer DEFAULT 0,
    created_by uuid,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    CONSTRAINT newsletter_campaigns_campaign_type_check CHECK ((campaign_type = ANY (ARRAY['newsletter'::text, 'announcement'::text, 'promotion'::text, 'onboarding'::text, 'reengagement'::text, 'transactional'::text]))),
    CONSTRAINT newsletter_campaigns_status_check CHECK ((status = ANY (ARRAY['draft'::text, 'scheduled'::text, 'sending'::text, 'sent'::text, 'paused'::text, 'cancelled'::text])))
);


--
-- Name: TABLE newsletter_campaigns; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE public.newsletter_campaigns IS 'Email marketing campaigns for newsletters, announcements, and promotions';


--
-- Name: newsletter_subscribers; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.newsletter_subscribers (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    email text NOT NULL,
    first_name text,
    status text DEFAULT 'active'::text NOT NULL,
    source text DEFAULT 'website'::text,
    subscribed_at timestamp with time zone DEFAULT now(),
    unsubscribed_at timestamp with time zone,
    unsubscribe_reason text,
    metadata jsonb DEFAULT '{}'::jsonb,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    CONSTRAINT newsletter_subscribers_source_check CHECK ((source = ANY (ARRAY['website'::text, 'import'::text, 'api'::text, 'referral'::text]))),
    CONSTRAINT newsletter_subscribers_status_check CHECK ((status = ANY (ARRAY['active'::text, 'unsubscribed'::text, 'bounced'::text, 'complained'::text])))
);


--
-- Name: TABLE newsletter_subscribers; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE public.newsletter_subscribers IS 'Non-registered email subscribers for newsletters';


--
-- Name: notification_delivery_log; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.notification_delivery_log (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    notification_id uuid NOT NULL,
    user_id uuid NOT NULL,
    type text NOT NULL,
    title text NOT NULL,
    body text NOT NULL,
    channels jsonb DEFAULT '[]'::jsonb NOT NULL,
    status text NOT NULL,
    delivered_at timestamp with time zone,
    error text,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    CONSTRAINT notification_delivery_log_status_check CHECK ((status = ANY (ARRAY['pending'::text, 'delivered'::text, 'failed'::text, 'scheduled'::text])))
);


--
-- Name: TABLE notification_delivery_log; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE public.notification_delivery_log IS 'Central log for all notification deliveries across all channels';


--
-- Name: notification_digest_queue; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.notification_digest_queue (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    user_id uuid NOT NULL,
    notification_type text NOT NULL,
    category public.notification_category NOT NULL,
    title text NOT NULL,
    body text NOT NULL,
    data jsonb DEFAULT '{}'::jsonb,
    frequency text NOT NULL,
    scheduled_for timestamp with time zone NOT NULL,
    status text DEFAULT 'pending'::text NOT NULL,
    sent_at timestamp with time zone,
    error_message text,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    CONSTRAINT notification_digest_queue_frequency_check CHECK ((frequency = ANY (ARRAY['hourly'::text, 'daily'::text, 'weekly'::text]))),
    CONSTRAINT notification_digest_queue_status_check CHECK ((status = ANY (ARRAY['pending'::text, 'sent'::text, 'failed'::text, 'expired'::text])))
);


--
-- Name: TABLE notification_digest_queue; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE public.notification_digest_queue IS 'Queue for digest batching (hourly, daily, weekly)';


--
-- Name: notification_preferences; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.notification_preferences (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    user_id uuid NOT NULL,
    category public.notification_category NOT NULL,
    channel public.notification_channel NOT NULL,
    enabled boolean DEFAULT true NOT NULL,
    frequency text DEFAULT 'instant'::text NOT NULL,
    quiet_hours_enabled boolean,
    quiet_hours_start time without time zone,
    quiet_hours_end time without time zone,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    CONSTRAINT notification_preferences_frequency_check CHECK ((frequency = ANY (ARRAY['instant'::text, 'hourly'::text, 'daily'::text, 'weekly'::text, 'never'::text])))
);


--
-- Name: notification_priority_config; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.notification_priority_config (
    notification_type text NOT NULL,
    base_priority integer DEFAULT 5 NOT NULL,
    bypass_consolidation boolean DEFAULT false NOT NULL,
    bypass_quiet_hours boolean DEFAULT false NOT NULL,
    max_per_hour integer,
    consolidation_window_minutes integer DEFAULT 15,
    ttl_seconds integer DEFAULT 86400,
    CONSTRAINT notification_priority_config_base_priority_check CHECK (((base_priority >= 1) AND (base_priority <= 10)))
);


--
-- Name: TABLE notification_priority_config; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE public.notification_priority_config IS 'Priority and consolidation settings per notification type';


--
-- Name: notification_queue; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.notification_queue (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    user_id uuid NOT NULL,
    notification_type text NOT NULL,
    consolidation_key text,
    title text NOT NULL,
    body text,
    payload jsonb DEFAULT '{}'::jsonb NOT NULL,
    priority integer DEFAULT 5 NOT NULL,
    scheduled_for timestamp with time zone DEFAULT now() NOT NULL,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    status text DEFAULT 'pending'::text NOT NULL,
    processed_at timestamp with time zone,
    error_message text,
    consolidated_count integer DEFAULT 1,
    consolidated_ids uuid[] DEFAULT '{}'::uuid[],
    CONSTRAINT notification_queue_priority_check CHECK (((priority >= 1) AND (priority <= 10))),
    CONSTRAINT notification_queue_status_check CHECK ((status = ANY (ARRAY['pending'::text, 'consolidated'::text, 'sent'::text, 'dropped'::text, 'failed'::text])))
);


--
-- Name: TABLE notification_queue; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE public.notification_queue IS 'Queue for scheduled and delayed notifications';


--
-- Name: notification_settings; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.notification_settings (
    user_id uuid NOT NULL,
    push_enabled boolean DEFAULT true NOT NULL,
    email_enabled boolean DEFAULT true NOT NULL,
    sms_enabled boolean DEFAULT false NOT NULL,
    phone_number text,
    phone_verified boolean DEFAULT false NOT NULL,
    quiet_hours_enabled boolean DEFAULT false NOT NULL,
    quiet_hours_start time without time zone DEFAULT '22:00:00'::time without time zone NOT NULL,
    quiet_hours_end time without time zone DEFAULT '08:00:00'::time without time zone NOT NULL,
    timezone text DEFAULT 'UTC'::text NOT NULL,
    daily_digest_enabled boolean DEFAULT false NOT NULL,
    daily_digest_time time without time zone DEFAULT '09:00:00'::time without time zone NOT NULL,
    weekly_digest_enabled boolean DEFAULT false NOT NULL,
    weekly_digest_day integer DEFAULT 1 NOT NULL,
    dnd_enabled boolean DEFAULT false NOT NULL,
    dnd_until timestamp with time zone,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL
);


--
-- Name: organization_members; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.organization_members (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    organization_id uuid NOT NULL,
    user_id uuid NOT NULL,
    role text DEFAULT 'member'::text,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    CONSTRAINT organization_members_role_check CHECK ((role = ANY (ARRAY['owner'::text, 'admin'::text, 'member'::text])))
);


--
-- Name: TABLE organization_members; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE public.organization_members IS 'Maps users to organizations with roles';


--
-- Name: organizations; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.organizations (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    name text NOT NULL,
    slug text NOT NULL,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL
);


--
-- Name: TABLE organizations; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE public.organizations IS 'Multi-tenant organizations for B2B SaaS';


--
-- Name: orphaned_storage_cleanup; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.orphaned_storage_cleanup (
    id integer NOT NULL,
    bucket_id text NOT NULL,
    name text NOT NULL,
    size_bytes bigint,
    created_at timestamp with time zone,
    deleted_at timestamp with time zone DEFAULT now()
);


--
-- Name: orphaned_storage_cleanup_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.orphaned_storage_cleanup_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: orphaned_storage_cleanup_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.orphaned_storage_cleanup_id_seq OWNED BY public.orphaned_storage_cleanup.id;


--
-- Name: pending_automation_emails; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW public.pending_automation_emails WITH (security_invoker='true') AS
 SELECT eaq.id,
    eaq.enrollment_id,
    eaq.flow_id,
    eaq.profile_id,
    eaq.step_index,
    eaq.scheduled_for,
    eaq.status,
    eaq.attempts,
    eaq.max_attempts,
    eaq.last_attempt_at,
    eaq.sent_at,
    eaq.error_message,
    eaq.email_data,
    eaq.created_at,
    eaq.updated_at,
    p.email,
    p.first_name,
    p.second_name
   FROM (public.email_automation_queue eaq
     LEFT JOIN public.profiles p ON ((eaq.profile_id = p.id)))
  WHERE ((eaq.status = 'pending'::text) AND (eaq.scheduled_for <= now()));


--
-- Name: pending_operations; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.pending_operations (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    user_id uuid NOT NULL,
    operation_type text NOT NULL,
    table_name text NOT NULL,
    record_id uuid,
    payload jsonb NOT NULL,
    client_timestamp timestamp with time zone NOT NULL,
    server_timestamp timestamp with time zone DEFAULT now() NOT NULL,
    status text DEFAULT 'pending'::text NOT NULL,
    conflict_resolution jsonb,
    error_message text,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    CONSTRAINT pending_operations_operation_type_check CHECK ((operation_type = ANY (ARRAY['create'::text, 'update'::text, 'delete'::text]))),
    CONSTRAINT pending_operations_status_check CHECK ((status = ANY (ARRAY['pending'::text, 'applied'::text, 'conflict'::text, 'rejected'::text, 'resolved'::text])))
);


--
-- Name: TABLE pending_operations; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE public.pending_operations IS 'Queue for optimistic update conflict resolution';


--
-- Name: post_activity_daily_stats; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.post_activity_daily_stats (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    date date NOT NULL,
    post_type text DEFAULT 'all'::text NOT NULL,
    posts_created integer DEFAULT 0,
    posts_updated integer DEFAULT 0,
    posts_deleted integer DEFAULT 0,
    posts_viewed integer DEFAULT 0,
    posts_arranged integer DEFAULT 0,
    posts_collected integer DEFAULT 0,
    posts_reported integer DEFAULT 0,
    posts_expired integer DEFAULT 0,
    total_likes integer DEFAULT 0,
    total_shares integer DEFAULT 0,
    total_contacts integer DEFAULT 0,
    unique_posters integer DEFAULT 0,
    unique_viewers integer DEFAULT 0,
    unique_arrangers integer DEFAULT 0,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now()
);


--
-- Name: TABLE post_activity_daily_stats; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE public.post_activity_daily_stats IS 'Aggregated daily statistics for post activities. Updated by scheduled jobs or triggers.';


--
-- Name: post_activity_logs; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.post_activity_logs (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    post_id bigint,
    actor_id uuid,
    activity_type public.post_activity_type NOT NULL,
    previous_state jsonb DEFAULT '{}'::jsonb,
    new_state jsonb DEFAULT '{}'::jsonb,
    changes jsonb DEFAULT '{}'::jsonb,
    metadata jsonb DEFAULT '{}'::jsonb,
    reason text,
    notes text,
    ip_address inet,
    user_agent text,
    request_id text,
    related_post_id bigint,
    related_profile_id uuid,
    related_room_id uuid,
    created_at timestamp with time zone DEFAULT now() NOT NULL
);


--
-- Name: TABLE post_activity_logs; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE public.post_activity_logs IS 'Audit log for post changes. post_id is nullable to preserve logs after post deletion (ON DELETE SET NULL).';


--
-- Name: COLUMN post_activity_logs.previous_state; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.post_activity_logs.previous_state IS 'Snapshot of relevant post fields before the activity';


--
-- Name: COLUMN post_activity_logs.new_state; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.post_activity_logs.new_state IS 'Snapshot of relevant post fields after the activity';


--
-- Name: COLUMN post_activity_logs.changes; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.post_activity_logs.changes IS 'Diff of what changed (for updates)';


--
-- Name: COLUMN post_activity_logs.metadata; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.post_activity_logs.metadata IS 'Additional context-specific data';


--
-- Name: COLUMN post_activity_logs.request_id; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.post_activity_logs.request_id IS 'Correlation ID for tracing requests';


--
-- Name: post_reports; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.post_reports (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    post_id bigint NOT NULL,
    reporter_id uuid NOT NULL,
    reason text NOT NULL,
    description text,
    ai_analysis jsonb DEFAULT '{}'::jsonb,
    ai_severity_score integer,
    ai_recommended_action text,
    ai_confidence numeric(3,2),
    status text DEFAULT 'pending'::text NOT NULL,
    moderator_id uuid,
    moderator_action text,
    moderator_notes text,
    resolved_at timestamp with time zone,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    CONSTRAINT post_reports_ai_confidence_check CHECK (((ai_confidence >= (0)::numeric) AND (ai_confidence <= (1)::numeric))),
    CONSTRAINT post_reports_ai_recommended_action_check CHECK ((ai_recommended_action = ANY (ARRAY['dismiss'::text, 'warn_user'::text, 'hide_post'::text, 'remove_post'::text, 'ban_user'::text, 'escalate'::text]))),
    CONSTRAINT post_reports_ai_severity_score_check CHECK (((ai_severity_score >= 0) AND (ai_severity_score <= 100))),
    CONSTRAINT post_reports_moderator_action_check CHECK ((moderator_action = ANY (ARRAY['dismissed'::text, 'warning_sent'::text, 'post_hidden'::text, 'post_removed'::text, 'user_banned'::text]))),
    CONSTRAINT post_reports_reason_check CHECK ((reason = ANY (ARRAY['spam'::text, 'inappropriate'::text, 'misleading'::text, 'expired'::text, 'wrong_location'::text, 'safety_concern'::text, 'duplicate'::text, 'other'::text]))),
    CONSTRAINT post_reports_status_check CHECK ((status = ANY (ARRAY['pending'::text, 'ai_reviewed'::text, 'under_review'::text, 'resolved'::text, 'dismissed'::text])))
);


--
-- Name: TABLE post_reports; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE public.post_reports IS 'Post reports table with optimized RLS policies (2024-12-08)';


--
-- Name: post_views; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.post_views (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    post_id integer NOT NULL,
    viewer_id uuid,
    viewer_ip_hash text,
    session_id text,
    created_at timestamp with time zone DEFAULT now() NOT NULL
);


--
-- Name: posts_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

ALTER TABLE public.posts ALTER COLUMN id ADD GENERATED BY DEFAULT AS IDENTITY (
    SEQUENCE NAME public.posts_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);


--
-- Name: posts_image_backup; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.posts_image_backup (
    id bigint NOT NULL,
    image_url_1 text,
    image_url_2 text,
    image_url_3 text,
    backed_up_at timestamp with time zone DEFAULT now()
);


--
-- Name: TABLE posts_image_backup; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE public.posts_image_backup IS 'Backup of legacy image_url_1/2/3 columns before dropping. Created during migration to images array. Safe to drop after 30 days if no issues.';


--
-- Name: posts_with_location; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW public.posts_with_location WITH (security_invoker='true') AS
 SELECT p.id,
    p.post_name,
    p.post_description,
    p.post_type,
    p.post_address,
    p.post_stripped_address,
    p.quantity,
    p.pickup_time,
    p.is_active,
    p.is_arranged,
    p.created_at,
    p.updated_at,
    p.profile_id,
    p.images,
    p.post_views,
    p.location,
    p.location_json,
    extensions.st_y((p.location)::extensions.geometry) AS latitude,
    extensions.st_x((p.location)::extensions.geometry) AS longitude,
    p.category_id,
    p.tags
   FROM public.posts p
  WHERE (p.is_active = true);


--
-- Name: precomputed_feed_cells; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.precomputed_feed_cells (
    cell_id text NOT NULL,
    center_lat double precision NOT NULL,
    center_lng double precision NOT NULL,
    radius_km integer DEFAULT 10 NOT NULL,
    feed_data jsonb NOT NULL,
    item_count integer DEFAULT 0 NOT NULL,
    computed_at timestamp with time zone DEFAULT now() NOT NULL,
    expires_at timestamp with time zone DEFAULT (now() + '00:05:00'::interval) NOT NULL,
    access_count integer DEFAULT 0 NOT NULL,
    last_accessed_at timestamp with time zone DEFAULT now() NOT NULL,
    computation_time_ms integer,
    version integer DEFAULT 1 NOT NULL
);


--
-- Name: rate_limits; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.rate_limits (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    identifier character varying(255) NOT NULL,
    request_count integer DEFAULT 1,
    window_start timestamp with time zone DEFAULT now()
);


--
-- Name: reaction_types; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.reaction_types (
    id integer NOT NULL,
    name text NOT NULL,
    emoji text NOT NULL,
    sort_order integer DEFAULT 0
);


--
-- Name: TABLE reaction_types; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE public.reaction_types IS 'Available reaction types (emoji reactions)';


--
-- Name: reaction_types_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.reaction_types_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: reaction_types_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.reaction_types_id_seq OWNED BY public.reaction_types.id;


--
-- Name: recent_audit_activity; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW public.recent_audit_activity WITH (security_invoker='true') AS
 SELECT audit_logs.id,
    audit_logs.user_id,
    audit_logs.action,
    audit_logs.resource_type,
    audit_logs.resource_id,
    audit_logs.metadata,
    audit_logs.ip_address,
    audit_logs.user_agent,
    audit_logs.created_at
   FROM public.audit_logs
  WHERE (audit_logs.created_at >= (now() - '7 days'::interval))
  ORDER BY audit_logs.created_at DESC
 LIMIT 100;


--
-- Name: reports; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.reports (
    id bigint NOT NULL,
    created_at timestamp with time zone DEFAULT (now() AT TIME ZONE 'utc'::text) NOT NULL,
    profile_id uuid DEFAULT '8f7a9bf4-99e0-487b-b211-99b116749b1c'::uuid NOT NULL,
    description text DEFAULT '-'::text NOT NULL,
    notes text DEFAULT '-'::text NOT NULL
);


--
-- Name: TABLE reports; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE public.reports IS 'User reports provide information on the platform''s malicious activity ';


--
-- Name: reports_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

ALTER TABLE public.reports ALTER COLUMN id ADD GENERATED BY DEFAULT AS IDENTITY (
    SEQUENCE NAME public.reports_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);


--
-- Name: reviews_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

ALTER TABLE public.reviews ALTER COLUMN id ADD GENERATED BY DEFAULT AS IDENTITY (
    SEQUENCE NAME public.reviews_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);


--
-- Name: roles; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.roles (
    id integer NOT NULL,
    name text NOT NULL,
    description text,
    created_at timestamp with time zone DEFAULT now()
);


--
-- Name: TABLE roles; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE public.roles IS 'Available user roles in the system';


--
-- Name: roles_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.roles_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: roles_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.roles_id_seq OWNED BY public.roles.id;


--
-- Name: room_participants; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.room_participants (
    text text DEFAULT ''::text NOT NULL,
    image text DEFAULT ''::text NOT NULL,
    profile_id uuid NOT NULL,
    "timestamp" timestamp with time zone DEFAULT (now() AT TIME ZONE 'utc'::text) NOT NULL,
    room_id uuid,
    id uuid DEFAULT extensions.uuid_generate_v4() NOT NULL
);


--
-- Name: TABLE room_participants; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE public.room_participants IS 'Stores user chat messages.';


--
-- Name: storage_costs; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW public.storage_costs AS
 SELECT image_upload_metrics.bucket,
    (((sum(image_upload_metrics.compressed_size) / 1024.0) / 1024.0) / 1024.0) AS total_gb,
    round(((((sum(image_upload_metrics.compressed_size) / 1024.0) / 1024.0) / 1024.0) * 0.021), 2) AS estimated_monthly_cost_usd,
    count(*) AS file_count
   FROM public.image_upload_metrics
  WHERE (image_upload_metrics.uploaded_at > (now() - '30 days'::interval))
  GROUP BY image_upload_metrics.bucket
  ORDER BY (((sum(image_upload_metrics.compressed_size) / 1024.0) / 1024.0) / 1024.0) DESC;


--
-- Name: VIEW storage_costs; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON VIEW public.storage_costs IS 'Estimated storage costs by bucket';


--
-- Name: sync_checkpoints; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.sync_checkpoints (
    user_id uuid NOT NULL,
    table_name text NOT NULL,
    last_sync_version bigint DEFAULT 0 NOT NULL,
    last_sync_at timestamp with time zone DEFAULT now() NOT NULL
);


--
-- Name: TABLE sync_checkpoints; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE public.sync_checkpoints IS 'Tracks last sync point per user per table';


--
-- Name: telegram_rate_limits; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.telegram_rate_limits (
    user_id bigint NOT NULL,
    request_count integer DEFAULT 1,
    window_start timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now()
);


--
-- Name: telegram_user_activity; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.telegram_user_activity (
    id integer NOT NULL,
    user_id bigint NOT NULL,
    username text,
    message_count integer DEFAULT 0,
    first_message_date date,
    last_message_date date,
    messages_per_day jsonb DEFAULT '{}'::jsonb,
    messages_per_week jsonb DEFAULT '{}'::jsonb,
    messages_per_month jsonb DEFAULT '{}'::jsonb,
    first_name text,
    last_name text,
    total_characters integer,
    average_message_length double precision,
    media_count integer,
    reply_count integer,
    forward_count integer,
    mention_count integer,
    hashtag_count integer,
    link_count integer,
    voice_message_count integer,
    sticker_count integer,
    most_active_hour integer,
    most_used_words jsonb,
    active_days text[],
    sentiment_score double precision,
    emoji_usage jsonb,
    topics jsonb,
    active_hours jsonb,
    interactions jsonb,
    total_messages integer,
    new_users integer,
    CONSTRAINT check_avg_message_length_non_negative CHECK (((average_message_length IS NULL) OR (average_message_length >= (0)::double precision))),
    CONSTRAINT check_message_count_non_negative CHECK (((message_count IS NULL) OR (message_count >= 0))),
    CONSTRAINT check_most_active_hour_range CHECK (((most_active_hour IS NULL) OR ((most_active_hour >= 0) AND (most_active_hour <= 23)))),
    CONSTRAINT check_total_characters_non_negative CHECK (((total_characters IS NULL) OR (total_characters >= 0))),
    CONSTRAINT check_total_messages_non_negative CHECK (((total_messages IS NULL) OR (total_messages >= 0)))
);


--
-- Name: telegram_user_states; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.telegram_user_states (
    user_id bigint NOT NULL,
    state jsonb NOT NULL,
    updated_at timestamp with time zone DEFAULT now(),
    expires_at timestamp with time zone DEFAULT (now() + '00:30:00'::interval)
);


--
-- Name: top_uploaders; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW public.top_uploaders AS
 SELECT image_upload_metrics.user_id,
    count(*) AS upload_count,
    sum(image_upload_metrics.original_size) AS total_size_uploaded,
    sum(image_upload_metrics.saved_bytes) AS total_saved,
    max(image_upload_metrics.uploaded_at) AS last_upload
   FROM public.image_upload_metrics
  WHERE ((image_upload_metrics.uploaded_at > (now() - '30 days'::interval)) AND (image_upload_metrics.user_id IS NOT NULL))
  GROUP BY image_upload_metrics.user_id
  ORDER BY (count(*)) DESC
 LIMIT 100;


--
-- Name: VIEW top_uploaders; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON VIEW public.top_uploaders IS 'Top 100 users by upload volume (last 30 days)';


--
-- Name: translation_analytics; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.translation_analytics (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    locale character varying(10) NOT NULL,
    platform character varying(20) NOT NULL,
    user_id uuid,
    device_id character varying(255),
    response_time_ms integer,
    status_code integer,
    cached boolean DEFAULT false,
    fallback boolean DEFAULT false,
    user_agent text,
    ip_address inet,
    "timestamp" timestamp with time zone DEFAULT now()
);


--
-- Name: translation_backfill_jobs; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.translation_backfill_jobs (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    job_type text NOT NULL,
    status text DEFAULT 'in_progress'::text NOT NULL,
    started_at timestamp with time zone DEFAULT now() NOT NULL,
    completed_at timestamp with time zone,
    items_processed integer DEFAULT 0,
    error_message text,
    triggered_by text DEFAULT 'cron'::text
);


--
-- Name: translation_cache; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.translation_cache (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    locale character varying(10) NOT NULL,
    platform character varying(50) NOT NULL,
    etag character varying(64) NOT NULL,
    compressed_data bytea,
    uncompressed_size integer,
    compressed_size integer,
    created_at timestamp with time zone DEFAULT now(),
    expires_at timestamp with time zone NOT NULL
);


--
-- Name: translation_change_log; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.translation_change_log (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    locale character varying(10) NOT NULL,
    key_path text NOT NULL,
    old_value text,
    new_value text,
    change_type character varying(20) DEFAULT 'update'::character varying,
    version character varying(50) NOT NULL,
    changed_by uuid,
    created_at timestamp with time zone DEFAULT now(),
    CONSTRAINT translation_change_log_change_type_check CHECK (((change_type)::text = ANY ((ARRAY['add'::character varying, 'update'::character varying, 'delete'::character varying])::text[])))
);


--
-- Name: translation_errors; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.translation_errors (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    locale character varying(10) NOT NULL,
    platform character varying(20) NOT NULL,
    error_code character varying(50),
    error_message text,
    user_id uuid,
    "timestamp" timestamp with time zone DEFAULT now()
);


--
-- Name: translation_platform_config; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.translation_platform_config (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    platform character varying(50) NOT NULL,
    cache_ttl_seconds integer DEFAULT 3600,
    max_batch_size integer DEFAULT 10,
    supports_delta_updates boolean DEFAULT true,
    supports_offline_mode boolean DEFAULT true,
    compression_enabled boolean DEFAULT true,
    rate_limit_requests integer DEFAULT 100,
    rate_limit_window_seconds integer DEFAULT 3600,
    custom_headers jsonb DEFAULT '{}'::jsonb,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    realtime_enabled boolean DEFAULT false,
    streaming_enabled boolean DEFAULT false,
    prefetch_enabled boolean DEFAULT true,
    background_sync_enabled boolean DEFAULT true
);


--
-- Name: translation_queue; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.translation_queue (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    content_type text NOT NULL,
    content_id text NOT NULL,
    field_name text NOT NULL,
    source_text text NOT NULL,
    target_locale text NOT NULL,
    status text DEFAULT 'pending'::text NOT NULL,
    attempts integer DEFAULT 0 NOT NULL,
    error_message text,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    processed_at timestamp with time zone
);


--
-- Name: TABLE translation_queue; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE public.translation_queue IS 'Queue for translation tasks to be processed by cron job';


--
-- Name: translation_service_usage; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.translation_service_usage (
    id integer NOT NULL,
    service_name text NOT NULL,
    month_year text NOT NULL,
    chars_used bigint DEFAULT 0,
    free_limit bigint NOT NULL,
    updated_at timestamp with time zone DEFAULT now()
);


--
-- Name: translation_service_usage_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.translation_service_usage_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: translation_service_usage_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.translation_service_usage_id_seq OWNED BY public.translation_service_usage.id;


--
-- Name: translation_sync_status; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.translation_sync_status (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    user_id uuid,
    device_id character varying(255),
    locale character varying(10) NOT NULL,
    last_synced_version character varying(50),
    last_synced_at timestamp with time zone DEFAULT now(),
    sync_status character varying(20) DEFAULT 'synced'::character varying,
    pending_changes jsonb DEFAULT '{}'::jsonb,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    CONSTRAINT translation_sync_status_sync_status_check CHECK (((sync_status)::text = ANY ((ARRAY['synced'::character varying, 'pending'::character varying, 'failed'::character varying])::text[])))
);


--
-- Name: translation_usage_analytics; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.translation_usage_analytics (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    user_id uuid,
    target_locale text NOT NULL,
    content_type text NOT NULL,
    cache_hit boolean NOT NULL,
    response_time_ms integer,
    tokens_used integer,
    created_at timestamp with time zone DEFAULT now()
);


--
-- Name: translation_versions; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.translation_versions (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    locale character varying(10) NOT NULL,
    version character varying(50) NOT NULL,
    changes jsonb DEFAULT '{}'::jsonb NOT NULL,
    previous_version character varying(50),
    created_at timestamp with time zone DEFAULT now()
);


--
-- Name: translations; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.translations (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    locale character varying(10) NOT NULL,
    messages jsonb DEFAULT '{}'::jsonb NOT NULL,
    version character varying(50) NOT NULL,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now()
);


--
-- Name: TABLE translations; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE public.translations IS 'Cross-platform translation messages for web, iOS, Android, desktop, and other clients. Synced from .po files via sync script.';


--
-- Name: user_activity_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.user_activity_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: user_activity_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.user_activity_id_seq OWNED BY public.telegram_user_activity.id;


--
-- Name: user_activity_summary; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.user_activity_summary (
    user_id uuid NOT NULL,
    categories_viewed jsonb DEFAULT '{}'::jsonb NOT NULL,
    search_terms text[] DEFAULT '{}'::text[] NOT NULL,
    search_count integer DEFAULT 0 NOT NULL,
    locations_searched jsonb DEFAULT '[]'::jsonb NOT NULL,
    peak_activity_hours jsonb DEFAULT '{}'::jsonb NOT NULL,
    listings_viewed integer DEFAULT 0 NOT NULL,
    listings_saved integer DEFAULT 0 NOT NULL,
    messages_initiated integer DEFAULT 0 NOT NULL,
    shares_completed integer DEFAULT 0 NOT NULL,
    first_activity_at timestamp with time zone,
    last_activity_at timestamp with time zone,
    updated_at timestamp with time zone DEFAULT now() NOT NULL
);


--
-- Name: TABLE user_activity_summary; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE public.user_activity_summary IS 'Per-user activity tracking for personalization';


--
-- Name: user_addresses; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.user_addresses (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    profile_id uuid NOT NULL,
    address_line1 text,
    address_line2 text,
    city text,
    state_province text,
    postal_code text,
    country text,
    latitude double precision,
    longitude double precision,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now()
);


--
-- Name: TABLE user_addresses; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE public.user_addresses IS 'User address information for profile display, one-to-one with profiles';


--
-- Name: user_email_health; Type: MATERIALIZED VIEW; Schema: public; Owner: -
--

CREATE MATERIALIZED VIEW public.user_email_health AS
 SELECT email_delivery_log.user_id,
    count(*) AS total_emails,
    count(*) FILTER (WHERE (email_delivery_log.status = ANY (ARRAY['delivered'::text, 'opened'::text, 'clicked'::text]))) AS delivered,
    count(*) FILTER (WHERE (email_delivery_log.status = ANY (ARRAY['opened'::text, 'clicked'::text]))) AS opened,
    count(*) FILTER (WHERE (email_delivery_log.status = 'clicked'::text)) AS clicked,
    count(*) FILTER (WHERE (email_delivery_log.status = 'bounced'::text)) AS bounced,
    count(*) FILTER (WHERE (email_delivery_log.status = 'complained'::text)) AS complained,
    count(*) FILTER (WHERE (email_delivery_log.status = 'failed'::text)) AS failed,
    round((((count(*) FILTER (WHERE (email_delivery_log.status = ANY (ARRAY['delivered'::text, 'opened'::text, 'clicked'::text]))))::numeric / (NULLIF(count(*), 0))::numeric) * (100)::numeric), 2) AS delivery_rate,
    round((((count(*) FILTER (WHERE (email_delivery_log.status = ANY (ARRAY['opened'::text, 'clicked'::text]))))::numeric / (NULLIF(count(*) FILTER (WHERE (email_delivery_log.status = ANY (ARRAY['delivered'::text, 'opened'::text, 'clicked'::text]))), 0))::numeric) * (100)::numeric), 2) AS open_rate,
    max(email_delivery_log.delivered_at) AS last_delivered_at,
    max(email_delivery_log.opened_at) AS last_opened_at,
    max(email_delivery_log.queued_at) AS last_queued_at
   FROM public.email_delivery_log
  WHERE (email_delivery_log.queued_at > (now() - '90 days'::interval))
  GROUP BY email_delivery_log.user_id
  WITH NO DATA;


--
-- Name: MATERIALIZED VIEW user_email_health; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON MATERIALIZED VIEW public.user_email_health IS 'Aggregated 90-day email delivery stats per user';


--
-- Name: user_events; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.user_events (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    user_id uuid NOT NULL,
    event_type text NOT NULL,
    event_data jsonb DEFAULT '{}'::jsonb NOT NULL,
    created_at timestamp with time zone DEFAULT now() NOT NULL
)
PARTITION BY RANGE (created_at);


--
-- Name: TABLE user_events; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE public.user_events IS 'User event tracking for ML and personalization (partitioned by month)';


--
-- Name: user_events_2025_12; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.user_events_2025_12 (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    user_id uuid NOT NULL,
    event_type text NOT NULL,
    event_data jsonb DEFAULT '{}'::jsonb NOT NULL,
    created_at timestamp with time zone DEFAULT now() NOT NULL
);


--
-- Name: user_events_2026_01; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.user_events_2026_01 (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    user_id uuid NOT NULL,
    event_type text NOT NULL,
    event_data jsonb DEFAULT '{}'::jsonb NOT NULL,
    created_at timestamp with time zone DEFAULT now() NOT NULL
);


--
-- Name: user_events_2026_02; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.user_events_2026_02 (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    user_id uuid NOT NULL,
    event_type text NOT NULL,
    event_data jsonb DEFAULT '{}'::jsonb NOT NULL,
    created_at timestamp with time zone DEFAULT now() NOT NULL
);


--
-- Name: user_locale_preferences; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.user_locale_preferences (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    user_id uuid,
    locale character varying(10) DEFAULT 'en'::character varying NOT NULL,
    timezone character varying(50) DEFAULT 'UTC'::character varying,
    date_format character varying(20) DEFAULT 'YYYY-MM-DD'::character varying,
    number_format character varying(20) DEFAULT 'en-US'::character varying,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now()
);


--
-- Name: user_preferences; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.user_preferences (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    profile_id uuid NOT NULL,
    search_radius_km double precision DEFAULT 5.0,
    feed_view_mode text DEFAULT 'grid'::text,
    notifications_enabled boolean DEFAULT true,
    email_notifications boolean DEFAULT true,
    push_notifications boolean DEFAULT true,
    show_distance boolean DEFAULT true,
    preferred_categories integer[] DEFAULT '{}'::integer[],
    theme text DEFAULT 'system'::text,
    language text DEFAULT 'en'::text,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    CONSTRAINT user_preferences_feed_view_mode_check CHECK ((feed_view_mode = ANY (ARRAY['grid'::text, 'list'::text, 'map'::text]))),
    CONSTRAINT user_preferences_theme_check CHECK ((theme = ANY (ARRAY['system'::text, 'light'::text, 'dark'::text])))
);


--
-- Name: user_rate_limits; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.user_rate_limits (
    id bigint NOT NULL,
    user_id uuid NOT NULL,
    key text NOT NULL,
    count integer DEFAULT 0 NOT NULL,
    reset_at timestamp with time zone NOT NULL,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL
);


--
-- Name: TABLE user_rate_limits; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE public.user_rate_limits IS 'Rate limiting for image uploads (100/day per user)';


--
-- Name: user_rate_limits_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.user_rate_limits_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: user_rate_limits_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.user_rate_limits_id_seq OWNED BY public.user_rate_limits.id;


--
-- Name: user_roles; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.user_roles (
    profile_id uuid NOT NULL,
    role_id integer NOT NULL,
    granted_at timestamp with time zone DEFAULT now(),
    granted_by uuid
);


--
-- Name: TABLE user_roles; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE public.user_roles IS 'Many-to-many relationship between users and roles';


--
-- Name: views; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.views (
    id integer NOT NULL,
    post_id integer,
    profile_id uuid NOT NULL,
    forum_id bigint,
    challenge_id bigint,
    viewed_at timestamp with time zone DEFAULT now(),
    created_at timestamp with time zone DEFAULT now()
);


--
-- Name: TABLE views; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE public.views IS 'Unified views table for all entity types. Records individual view events.';


--
-- Name: views_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.views_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: views_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.views_id_seq OWNED BY public.views.id;


--
-- Name: whatsapp_rate_limits; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.whatsapp_rate_limits (
    phone_number character varying(20) NOT NULL,
    request_count integer DEFAULT 1,
    window_start timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now()
);


--
-- Name: whatsapp_user_states; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.whatsapp_user_states (
    phone_number character varying(20) NOT NULL,
    state jsonb NOT NULL,
    updated_at timestamp with time zone DEFAULT now(),
    expires_at timestamp with time zone NOT NULL
);


--
-- Name: user_events_2025_12; Type: TABLE ATTACH; Schema: public; Owner: -
--

ALTER TABLE ONLY public.user_events ATTACH PARTITION public.user_events_2025_12 FOR VALUES FROM ('2025-12-01 00:00:00-08') TO ('2026-01-01 00:00:00-08');


--
-- Name: user_events_2026_01; Type: TABLE ATTACH; Schema: public; Owner: -
--

ALTER TABLE ONLY public.user_events ATTACH PARTITION public.user_events_2026_01 FOR VALUES FROM ('2026-01-01 00:00:00-08') TO ('2026-02-01 00:00:00-08');


--
-- Name: user_events_2026_02; Type: TABLE ATTACH; Schema: public; Owner: -
--

ALTER TABLE ONLY public.user_events ATTACH PARTITION public.user_events_2026_02 FOR VALUES FROM ('2026-02-01 00:00:00-08') TO ('2026-03-01 00:00:00-08');


--
-- Name: bookmarks id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.bookmarks ALTER COLUMN id SET DEFAULT nextval('public.bookmarks_id_seq'::regclass);


--
-- Name: categories id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.categories ALTER COLUMN id SET DEFAULT nextval('public.categories_id_seq'::regclass);


--
-- Name: compressed_images id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.compressed_images ALTER COLUMN id SET DEFAULT nextval('public.compressed_images_id_seq'::regclass);


--
-- Name: email_health_events id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.email_health_events ALTER COLUMN id SET DEFAULT nextval('public.email_health_events_id_seq'::regclass);


--
-- Name: email_provider_metrics id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.email_provider_metrics ALTER COLUMN id SET DEFAULT nextval('public.email_provider_metrics_id_seq'::regclass);


--
-- Name: forum_activity_types id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.forum_activity_types ALTER COLUMN id SET DEFAULT nextval('public.forum_activity_types_id_seq'::regclass);


--
-- Name: forum_badges id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.forum_badges ALTER COLUMN id SET DEFAULT nextval('public.forum_badges_id_seq'::regclass);


--
-- Name: forum_categories id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.forum_categories ALTER COLUMN id SET DEFAULT nextval('public.forum_categories_id_seq'::regclass);


--
-- Name: forum_popular_searches id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.forum_popular_searches ALTER COLUMN id SET DEFAULT nextval('public.forum_popular_searches_id_seq'::regclass);


--
-- Name: forum_rate_limit_config id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.forum_rate_limit_config ALTER COLUMN id SET DEFAULT nextval('public.forum_rate_limit_config_id_seq'::regclass);


--
-- Name: forum_reputation_actions id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.forum_reputation_actions ALTER COLUMN id SET DEFAULT nextval('public.forum_reputation_actions_id_seq'::regclass);


--
-- Name: forum_tags id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.forum_tags ALTER COLUMN id SET DEFAULT nextval('public.forum_tags_id_seq'::regclass);


--
-- Name: image_upload_metrics id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.image_upload_metrics ALTER COLUMN id SET DEFAULT nextval('public.image_upload_metrics_id_seq'::regclass);


--
-- Name: location_update_queue id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.location_update_queue ALTER COLUMN id SET DEFAULT nextval('public.location_update_queue_id_seq'::regclass);


--
-- Name: orphaned_storage_cleanup id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.orphaned_storage_cleanup ALTER COLUMN id SET DEFAULT nextval('public.orphaned_storage_cleanup_id_seq'::regclass);


--
-- Name: reaction_types id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.reaction_types ALTER COLUMN id SET DEFAULT nextval('public.reaction_types_id_seq'::regclass);


--
-- Name: roles id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.roles ALTER COLUMN id SET DEFAULT nextval('public.roles_id_seq'::regclass);


--
-- Name: telegram_user_activity id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.telegram_user_activity ALTER COLUMN id SET DEFAULT nextval('public.user_activity_id_seq'::regclass);


--
-- Name: translation_service_usage id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.translation_service_usage ALTER COLUMN id SET DEFAULT nextval('public.translation_service_usage_id_seq'::regclass);


--
-- Name: user_rate_limits id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.user_rate_limits ALTER COLUMN id SET DEFAULT nextval('public.user_rate_limits_id_seq'::regclass);


--
-- Name: views id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.views ALTER COLUMN id SET DEFAULT nextval('public.views_id_seq'::regclass);


--
-- Name: forms Forms_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.forms
    ADD CONSTRAINT "Forms_pkey" PRIMARY KEY (id);


--
-- Name: address address_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.address
    ADD CONSTRAINT address_pkey PRIMARY KEY (profile_id);


--
-- Name: admin_audit_log admin_audit_log_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.admin_audit_log
    ADD CONSTRAINT admin_audit_log_pkey PRIMARY KEY (id);


--
-- Name: analytics_daily_stats analytics_daily_stats_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.analytics_daily_stats
    ADD CONSTRAINT analytics_daily_stats_pkey PRIMARY KEY (date);


--
-- Name: analytics_post_activity analytics_post_activity_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.analytics_post_activity
    ADD CONSTRAINT analytics_post_activity_pkey PRIMARY KEY (id);


--
-- Name: analytics_staging_favorites analytics_staging_favorites_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.analytics_staging_favorites
    ADD CONSTRAINT analytics_staging_favorites_pkey PRIMARY KEY (id);


--
-- Name: analytics_staging_listings analytics_staging_listings_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.analytics_staging_listings
    ADD CONSTRAINT analytics_staging_listings_pkey PRIMARY KEY (id);


--
-- Name: analytics_staging_reviews analytics_staging_reviews_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.analytics_staging_reviews
    ADD CONSTRAINT analytics_staging_reviews_pkey PRIMARY KEY (id);


--
-- Name: analytics_staging_rooms analytics_staging_rooms_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.analytics_staging_rooms
    ADD CONSTRAINT analytics_staging_rooms_pkey PRIMARY KEY (id);


--
-- Name: analytics_staging_users analytics_staging_users_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.analytics_staging_users
    ADD CONSTRAINT analytics_staging_users_pkey PRIMARY KEY (id);


--
-- Name: analytics_user_activity analytics_user_activity_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.analytics_user_activity
    ADD CONSTRAINT analytics_user_activity_pkey PRIMARY KEY (user_id);


--
-- Name: api_analytics api_analytics_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.api_analytics
    ADD CONSTRAINT api_analytics_pkey PRIMARY KEY (id);


--
-- Name: app_config app_config_key_platform_key; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.app_config
    ADD CONSTRAINT app_config_key_platform_key UNIQUE (key, platform);


--
-- Name: app_config app_config_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.app_config
    ADD CONSTRAINT app_config_pkey PRIMARY KEY (id);


--
-- Name: app_version_requirements app_version_requirements_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.app_version_requirements
    ADD CONSTRAINT app_version_requirements_pkey PRIMARY KEY (platform);


--
-- Name: audience_segments audience_segments_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.audience_segments
    ADD CONSTRAINT audience_segments_pkey PRIMARY KEY (id);


--
-- Name: audit_logs audit_logs_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.audit_logs
    ADD CONSTRAINT audit_logs_pkey PRIMARY KEY (id);


--
-- Name: automation_enrollments automation_enrollments_flow_id_profile_id_key; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.automation_enrollments
    ADD CONSTRAINT automation_enrollments_flow_id_profile_id_key UNIQUE (flow_id, profile_id);


--
-- Name: automation_enrollments automation_enrollments_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.automation_enrollments
    ADD CONSTRAINT automation_enrollments_pkey PRIMARY KEY (id);


--
-- Name: blocked_users blocked_users_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.blocked_users
    ADD CONSTRAINT blocked_users_pkey PRIMARY KEY (id);


--
-- Name: blocked_users blocked_users_user_id_blocked_user_id_key; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.blocked_users
    ADD CONSTRAINT blocked_users_user_id_blocked_user_id_key UNIQUE (user_id, blocked_user_id);


--
-- Name: bookmarks bookmarks_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.bookmarks
    ADD CONSTRAINT bookmarks_pkey PRIMARY KEY (id);


--
-- Name: campaign_recipients campaign_recipients_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.campaign_recipients
    ADD CONSTRAINT campaign_recipients_pkey PRIMARY KEY (id);


--
-- Name: categories categories_name_key; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.categories
    ADD CONSTRAINT categories_name_key UNIQUE (name);


--
-- Name: categories categories_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.categories
    ADD CONSTRAINT categories_pkey PRIMARY KEY (id);


--
-- Name: challenge_activities challenge_activities_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.challenge_activities
    ADD CONSTRAINT challenge_activities_pkey PRIMARY KEY (id);


--
-- Name: challenge_participants challenge_participants_challenge_id_profile_id_key; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.challenge_participants
    ADD CONSTRAINT challenge_participants_challenge_id_profile_id_key UNIQUE (challenge_id, profile_id);


--
-- Name: challenge_participants challenge_participants_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.challenge_participants
    ADD CONSTRAINT challenge_participants_pkey PRIMARY KEY (id);


--
-- Name: challenges challenges_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.challenges
    ADD CONSTRAINT challenges_pkey PRIMARY KEY (id);


--
-- Name: comments comments_firebase_id_key; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.comments
    ADD CONSTRAINT comments_firebase_id_key UNIQUE (firebase_id);


--
-- Name: comments comments_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.comments
    ADD CONSTRAINT comments_pkey PRIMARY KEY (id);


--
-- Name: community_fridges community_fridges_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.community_fridges
    ADD CONSTRAINT community_fridges_pkey PRIMARY KEY (id);


--
-- Name: compressed_images compressed_images_bucket_id_object_path_key; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.compressed_images
    ADD CONSTRAINT compressed_images_bucket_id_object_path_key UNIQUE (bucket_id, object_path);


--
-- Name: compressed_images compressed_images_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.compressed_images
    ADD CONSTRAINT compressed_images_pkey PRIMARY KEY (id);


--
-- Name: content_translations content_translations_content_type_content_id_field_name_sou_key; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.content_translations
    ADD CONSTRAINT content_translations_content_type_content_id_field_name_sou_key UNIQUE (content_type, content_id, field_name, source_locale, target_locale, source_text);


--
-- Name: content_translations content_translations_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.content_translations
    ADD CONSTRAINT content_translations_pkey PRIMARY KEY (id);


--
-- Name: countries countries_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.countries
    ADD CONSTRAINT countries_pkey PRIMARY KEY (id);


--
-- Name: crm_customer_notes crm_customer_notes_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.crm_customer_notes
    ADD CONSTRAINT crm_customer_notes_pkey PRIMARY KEY (id);


--
-- Name: crm_customer_tag_assignments crm_customer_tag_assignments_customer_id_tag_id_key; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.crm_customer_tag_assignments
    ADD CONSTRAINT crm_customer_tag_assignments_customer_id_tag_id_key UNIQUE (customer_id, tag_id);


--
-- Name: crm_customer_tag_assignments crm_customer_tag_assignments_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.crm_customer_tag_assignments
    ADD CONSTRAINT crm_customer_tag_assignments_pkey PRIMARY KEY (id);


--
-- Name: crm_customer_tags crm_customer_tags_name_key; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.crm_customer_tags
    ADD CONSTRAINT crm_customer_tags_name_key UNIQUE (name);


--
-- Name: crm_customer_tags crm_customer_tags_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.crm_customer_tags
    ADD CONSTRAINT crm_customer_tags_pkey PRIMARY KEY (id);


--
-- Name: crm_customers crm_customers_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.crm_customers
    ADD CONSTRAINT crm_customers_pkey PRIMARY KEY (id);


--
-- Name: crm_customers crm_customers_profile_id_key; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.crm_customers
    ADD CONSTRAINT crm_customers_profile_id_key UNIQUE (profile_id);


--
-- Name: daily_stats daily_stats_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.daily_stats
    ADD CONSTRAINT daily_stats_pkey PRIMARY KEY (date);


--
-- Name: device_attestations device_attestations_key_id_key; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.device_attestations
    ADD CONSTRAINT device_attestations_key_id_key UNIQUE (key_id);


--
-- Name: device_attestations device_attestations_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.device_attestations
    ADD CONSTRAINT device_attestations_pkey PRIMARY KEY (id);


--
-- Name: device_tokens device_tokens_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.device_tokens
    ADD CONSTRAINT device_tokens_pkey PRIMARY KEY (profile_id, platform);


--
-- Name: notification_digest_queue digest_queue_unique_pending; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.notification_digest_queue
    ADD CONSTRAINT digest_queue_unique_pending UNIQUE (user_id, notification_type, category, frequency, status) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: display_name_overrides display_name_overrides_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.display_name_overrides
    ADD CONSTRAINT display_name_overrides_pkey PRIMARY KEY (user_id);


--
-- Name: dynamic_content_translations dynamic_content_translations_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.dynamic_content_translations
    ADD CONSTRAINT dynamic_content_translations_pkey PRIMARY KEY (id);


--
-- Name: email_audit_log email_audit_log_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.email_audit_log
    ADD CONSTRAINT email_audit_log_pkey PRIMARY KEY (id);


--
-- Name: email_automation_flows email_automation_flows_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.email_automation_flows
    ADD CONSTRAINT email_automation_flows_pkey PRIMARY KEY (id);


--
-- Name: email_automation_queue email_automation_queue_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.email_automation_queue
    ADD CONSTRAINT email_automation_queue_pkey PRIMARY KEY (id);


--
-- Name: email_bounce_events email_bounce_events_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.email_bounce_events
    ADD CONSTRAINT email_bounce_events_pkey PRIMARY KEY (id);


--
-- Name: email_circuit_breaker_state email_circuit_breaker_state_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.email_circuit_breaker_state
    ADD CONSTRAINT email_circuit_breaker_state_pkey PRIMARY KEY (provider, organization_id);


--
-- Name: email_dead_letter_queue email_dead_letter_queue_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.email_dead_letter_queue
    ADD CONSTRAINT email_dead_letter_queue_pkey PRIMARY KEY (id);


--
-- Name: email_delivery_log email_delivery_log_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.email_delivery_log
    ADD CONSTRAINT email_delivery_log_pkey PRIMARY KEY (id);


--
-- Name: email_health_events email_health_events_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.email_health_events
    ADD CONSTRAINT email_health_events_pkey PRIMARY KEY (id);


--
-- Name: email_logs email_logs_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.email_logs
    ADD CONSTRAINT email_logs_pkey PRIMARY KEY (id);


--
-- Name: email_preferences email_preferences_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.email_preferences
    ADD CONSTRAINT email_preferences_pkey PRIMARY KEY (id);


--
-- Name: email_preferences email_preferences_profile_id_key; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.email_preferences
    ADD CONSTRAINT email_preferences_profile_id_key UNIQUE (profile_id);


--
-- Name: email_provider_health_history email_provider_health_history_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.email_provider_health_history
    ADD CONSTRAINT email_provider_health_history_pkey PRIMARY KEY (id);


--
-- Name: email_provider_health_metrics email_provider_health_metrics_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.email_provider_health_metrics
    ADD CONSTRAINT email_provider_health_metrics_pkey PRIMARY KEY (id);


--
-- Name: email_provider_health_metrics email_provider_health_metrics_provider_key; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.email_provider_health_metrics
    ADD CONSTRAINT email_provider_health_metrics_provider_key UNIQUE (provider);


--
-- Name: email_provider_metrics email_provider_metrics_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.email_provider_metrics
    ADD CONSTRAINT email_provider_metrics_pkey PRIMARY KEY (id);


--
-- Name: email_provider_metrics email_provider_metrics_provider_date_key; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.email_provider_metrics
    ADD CONSTRAINT email_provider_metrics_provider_date_key UNIQUE (provider, date);


--
-- Name: email_provider_monthly_quota email_provider_monthly_quota_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.email_provider_monthly_quota
    ADD CONSTRAINT email_provider_monthly_quota_pkey PRIMARY KEY (id);


--
-- Name: email_provider_monthly_quota email_provider_monthly_quota_provider_year_month_organizati_key; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.email_provider_monthly_quota
    ADD CONSTRAINT email_provider_monthly_quota_provider_year_month_organizati_key UNIQUE (provider, year_month, organization_id);


--
-- Name: email_provider_quota email_provider_quota_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.email_provider_quota
    ADD CONSTRAINT email_provider_quota_pkey PRIMARY KEY (id);


--
-- Name: email_provider_quota email_provider_quota_unique; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.email_provider_quota
    ADD CONSTRAINT email_provider_quota_unique UNIQUE (provider, date, organization_id);


--
-- Name: email_provider_stats email_provider_stats_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.email_provider_stats
    ADD CONSTRAINT email_provider_stats_pkey PRIMARY KEY (id);


--
-- Name: email_provider_stats email_provider_stats_provider_date_key; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.email_provider_stats
    ADD CONSTRAINT email_provider_stats_provider_date_key UNIQUE (provider, date);


--
-- Name: email_queue email_queue_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.email_queue
    ADD CONSTRAINT email_queue_pkey PRIMARY KEY (id);


--
-- Name: email_suppression_list email_suppression_list_email_key; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.email_suppression_list
    ADD CONSTRAINT email_suppression_list_email_key UNIQUE (email);


--
-- Name: email_suppression_list email_suppression_list_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.email_suppression_list
    ADD CONSTRAINT email_suppression_list_pkey PRIMARY KEY (id);


--
-- Name: email_suppressions email_suppressions_email_key; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.email_suppressions
    ADD CONSTRAINT email_suppressions_email_key UNIQUE (email);


--
-- Name: email_suppressions email_suppressions_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.email_suppressions
    ADD CONSTRAINT email_suppressions_pkey PRIMARY KEY (id);


--
-- Name: email_template_versions email_template_versions_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.email_template_versions
    ADD CONSTRAINT email_template_versions_pkey PRIMARY KEY (id);


--
-- Name: email_templates email_templates_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.email_templates
    ADD CONSTRAINT email_templates_pkey PRIMARY KEY (id);


--
-- Name: email_templates email_templates_slug_key; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.email_templates
    ADD CONSTRAINT email_templates_slug_key UNIQUE (slug);


--
-- Name: experiment_assignments experiment_assignments_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.experiment_assignments
    ADD CONSTRAINT experiment_assignments_pkey PRIMARY KEY (user_id, experiment_key);


--
-- Name: experiments experiments_key_key; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.experiments
    ADD CONSTRAINT experiments_key_key UNIQUE (key);


--
-- Name: experiments experiments_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.experiments
    ADD CONSTRAINT experiments_pkey PRIMARY KEY (id);


--
-- Name: feature_flag_overrides feature_flag_overrides_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.feature_flag_overrides
    ADD CONSTRAINT feature_flag_overrides_pkey PRIMARY KEY (user_id, flag_key);


--
-- Name: feature_flags feature_flags_flag_key_key; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.feature_flags
    ADD CONSTRAINT feature_flags_flag_key_key UNIQUE (flag_key);


--
-- Name: feature_flags feature_flags_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.feature_flags
    ADD CONSTRAINT feature_flags_pkey PRIMARY KEY (id);


--
-- Name: feedback feedback_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.feedback
    ADD CONSTRAINT feedback_pkey PRIMARY KEY (id);


--
-- Name: notifications ff_push_notifications_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.notifications
    ADD CONSTRAINT ff_push_notifications_pkey PRIMARY KEY (id);


--
-- Name: forum_activities forum_activities_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.forum_activities
    ADD CONSTRAINT forum_activities_pkey PRIMARY KEY (id);


--
-- Name: forum_activity_types forum_activity_types_name_key; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.forum_activity_types
    ADD CONSTRAINT forum_activity_types_name_key UNIQUE (name);


--
-- Name: forum_activity_types forum_activity_types_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.forum_activity_types
    ADD CONSTRAINT forum_activity_types_pkey PRIMARY KEY (id);


--
-- Name: forum_announcement_analytics forum_announcement_analytics_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.forum_announcement_analytics
    ADD CONSTRAINT forum_announcement_analytics_pkey PRIMARY KEY (id);


--
-- Name: forum_announcement_dismissals forum_announcement_dismissals_announcement_id_profile_id_key; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.forum_announcement_dismissals
    ADD CONSTRAINT forum_announcement_dismissals_announcement_id_profile_id_key UNIQUE (announcement_id, profile_id);


--
-- Name: forum_announcement_dismissals forum_announcement_dismissals_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.forum_announcement_dismissals
    ADD CONSTRAINT forum_announcement_dismissals_pkey PRIMARY KEY (id);


--
-- Name: forum_announcements forum_announcements_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.forum_announcements
    ADD CONSTRAINT forum_announcements_pkey PRIMARY KEY (id);


--
-- Name: forum_author_analytics forum_author_analytics_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.forum_author_analytics
    ADD CONSTRAINT forum_author_analytics_pkey PRIMARY KEY (id);


--
-- Name: forum_author_analytics forum_author_analytics_profile_id_date_key; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.forum_author_analytics
    ADD CONSTRAINT forum_author_analytics_profile_id_date_key UNIQUE (profile_id, date);


--
-- Name: forum_badges forum_badges_name_key; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.forum_badges
    ADD CONSTRAINT forum_badges_name_key UNIQUE (name);


--
-- Name: forum_badges forum_badges_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.forum_badges
    ADD CONSTRAINT forum_badges_pkey PRIMARY KEY (id);


--
-- Name: forum_badges forum_badges_slug_key; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.forum_badges
    ADD CONSTRAINT forum_badges_slug_key UNIQUE (slug);


--
-- Name: forum_bookmark_collections forum_bookmark_collections_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.forum_bookmark_collections
    ADD CONSTRAINT forum_bookmark_collections_pkey PRIMARY KEY (id);


--
-- Name: forum_bookmark_collections forum_bookmark_collections_profile_id_name_key; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.forum_bookmark_collections
    ADD CONSTRAINT forum_bookmark_collections_profile_id_name_key UNIQUE (profile_id, name);


--
-- Name: forum_categories forum_categories_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.forum_categories
    ADD CONSTRAINT forum_categories_pkey PRIMARY KEY (id);


--
-- Name: forum_categories forum_categories_slug_key; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.forum_categories
    ADD CONSTRAINT forum_categories_slug_key UNIQUE (slug);


--
-- Name: forum_comment_history forum_comment_history_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.forum_comment_history
    ADD CONSTRAINT forum_comment_history_pkey PRIMARY KEY (id);


--
-- Name: forum_comment_reactions forum_comment_reactions_comment_id_profile_id_reaction_type_key; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.forum_comment_reactions
    ADD CONSTRAINT forum_comment_reactions_comment_id_profile_id_reaction_type_key UNIQUE (comment_id, profile_id, reaction_type_id);


--
-- Name: forum_comment_reactions forum_comment_reactions_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.forum_comment_reactions
    ADD CONSTRAINT forum_comment_reactions_pkey PRIMARY KEY (id);


--
-- Name: forum_content_experiments forum_content_experiments_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.forum_content_experiments
    ADD CONSTRAINT forum_content_experiments_pkey PRIMARY KEY (id);


--
-- Name: forum_conversation_participants forum_conversation_participants_conversation_id_profile_id_key; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.forum_conversation_participants
    ADD CONSTRAINT forum_conversation_participants_conversation_id_profile_id_key UNIQUE (conversation_id, profile_id);


--
-- Name: forum_conversation_participants forum_conversation_participants_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.forum_conversation_participants
    ADD CONSTRAINT forum_conversation_participants_pkey PRIMARY KEY (id);


--
-- Name: forum_conversations forum_conversations_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.forum_conversations
    ADD CONSTRAINT forum_conversations_pkey PRIMARY KEY (id);


--
-- Name: forum_drafts forum_drafts_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.forum_drafts
    ADD CONSTRAINT forum_drafts_pkey PRIMARY KEY (id);


--
-- Name: forum_feed_preferences forum_feed_preferences_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.forum_feed_preferences
    ADD CONSTRAINT forum_feed_preferences_pkey PRIMARY KEY (id);


--
-- Name: forum_feed_preferences forum_feed_preferences_profile_id_key; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.forum_feed_preferences
    ADD CONSTRAINT forum_feed_preferences_profile_id_key UNIQUE (profile_id);


--
-- Name: forum_feed_read_status forum_feed_read_status_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.forum_feed_read_status
    ADD CONSTRAINT forum_feed_read_status_pkey PRIMARY KEY (id);


--
-- Name: forum_feed_read_status forum_feed_read_status_profile_id_activity_id_key; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.forum_feed_read_status
    ADD CONSTRAINT forum_feed_read_status_profile_id_activity_id_key UNIQUE (profile_id, activity_id);


--
-- Name: forum_mentions forum_mentions_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.forum_mentions
    ADD CONSTRAINT forum_mentions_pkey PRIMARY KEY (id);


--
-- Name: forum_message_reactions forum_message_reactions_message_id_profile_id_reaction_type_key; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.forum_message_reactions
    ADD CONSTRAINT forum_message_reactions_message_id_profile_id_reaction_type_key UNIQUE (message_id, profile_id, reaction_type_id);


--
-- Name: forum_message_reactions forum_message_reactions_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.forum_message_reactions
    ADD CONSTRAINT forum_message_reactions_pkey PRIMARY KEY (id);


--
-- Name: forum_message_read_receipts forum_message_read_receipts_message_id_profile_id_key; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.forum_message_read_receipts
    ADD CONSTRAINT forum_message_read_receipts_message_id_profile_id_key UNIQUE (message_id, profile_id);


--
-- Name: forum_message_read_receipts forum_message_read_receipts_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.forum_message_read_receipts
    ADD CONSTRAINT forum_message_read_receipts_pkey PRIMARY KEY (id);


--
-- Name: forum_messages forum_messages_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.forum_messages
    ADD CONSTRAINT forum_messages_pkey PRIMARY KEY (id);


--
-- Name: forum_moderation_notes forum_moderation_notes_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.forum_moderation_notes
    ADD CONSTRAINT forum_moderation_notes_pkey PRIMARY KEY (id);


--
-- Name: forum_moderation_queue forum_moderation_queue_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.forum_moderation_queue
    ADD CONSTRAINT forum_moderation_queue_pkey PRIMARY KEY (id);


--
-- Name: forum_moderation_stats forum_moderation_stats_moderator_id_date_key; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.forum_moderation_stats
    ADD CONSTRAINT forum_moderation_stats_moderator_id_date_key UNIQUE (moderator_id, date);


--
-- Name: forum_moderation_stats forum_moderation_stats_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.forum_moderation_stats
    ADD CONSTRAINT forum_moderation_stats_pkey PRIMARY KEY (id);


--
-- Name: forum_moderator_logs forum_moderator_logs_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.forum_moderator_logs
    ADD CONSTRAINT forum_moderator_logs_pkey PRIMARY KEY (id);


--
-- Name: forum_notifications forum_notifications_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.forum_notifications
    ADD CONSTRAINT forum_notifications_pkey PRIMARY KEY (id);


--
-- Name: forum forum_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.forum
    ADD CONSTRAINT forum_pkey PRIMARY KEY (id);


--
-- Name: forum_poll_options forum_poll_options_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.forum_poll_options
    ADD CONSTRAINT forum_poll_options_pkey PRIMARY KEY (id);


--
-- Name: forum_poll_votes forum_poll_votes_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.forum_poll_votes
    ADD CONSTRAINT forum_poll_votes_pkey PRIMARY KEY (id);


--
-- Name: forum_polls forum_polls_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.forum_polls
    ADD CONSTRAINT forum_polls_pkey PRIMARY KEY (id);


--
-- Name: forum_popular_searches forum_popular_searches_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.forum_popular_searches
    ADD CONSTRAINT forum_popular_searches_pkey PRIMARY KEY (id);


--
-- Name: forum_popular_searches forum_popular_searches_query_key; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.forum_popular_searches
    ADD CONSTRAINT forum_popular_searches_query_key UNIQUE (query);


--
-- Name: forum_post_analytics forum_post_analytics_forum_id_date_key; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.forum_post_analytics
    ADD CONSTRAINT forum_post_analytics_forum_id_date_key UNIQUE (forum_id, date);


--
-- Name: forum_post_analytics forum_post_analytics_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.forum_post_analytics
    ADD CONSTRAINT forum_post_analytics_pkey PRIMARY KEY (id);


--
-- Name: forum_post_history forum_post_history_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.forum_post_history
    ADD CONSTRAINT forum_post_history_pkey PRIMARY KEY (id);


--
-- Name: forum_post_tags forum_post_tags_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.forum_post_tags
    ADD CONSTRAINT forum_post_tags_pkey PRIMARY KEY (forum_id, tag_id);


--
-- Name: forum_publication_queue forum_publication_queue_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.forum_publication_queue
    ADD CONSTRAINT forum_publication_queue_pkey PRIMARY KEY (id);


--
-- Name: forum_rate_limit_config forum_rate_limit_config_action_type_key; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.forum_rate_limit_config
    ADD CONSTRAINT forum_rate_limit_config_action_type_key UNIQUE (action_type);


--
-- Name: forum_rate_limit_config forum_rate_limit_config_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.forum_rate_limit_config
    ADD CONSTRAINT forum_rate_limit_config_pkey PRIMARY KEY (id);


--
-- Name: forum_rate_limits forum_rate_limits_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.forum_rate_limits
    ADD CONSTRAINT forum_rate_limits_pkey PRIMARY KEY (id);


--
-- Name: forum_reactions forum_reactions_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.forum_reactions
    ADD CONSTRAINT forum_reactions_pkey PRIMARY KEY (id);


--
-- Name: forum_reading_history forum_reading_history_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.forum_reading_history
    ADD CONSTRAINT forum_reading_history_pkey PRIMARY KEY (id);


--
-- Name: forum_reading_progress forum_reading_progress_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.forum_reading_progress
    ADD CONSTRAINT forum_reading_progress_pkey PRIMARY KEY (id);


--
-- Name: forum_reading_progress forum_reading_progress_profile_id_forum_id_key; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.forum_reading_progress
    ADD CONSTRAINT forum_reading_progress_profile_id_forum_id_key UNIQUE (profile_id, forum_id);


--
-- Name: forum_recurring_posts forum_recurring_posts_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.forum_recurring_posts
    ADD CONSTRAINT forum_recurring_posts_pkey PRIMARY KEY (id);


--
-- Name: forum_reports forum_reports_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.forum_reports
    ADD CONSTRAINT forum_reports_pkey PRIMARY KEY (id);


--
-- Name: forum_reputation_actions forum_reputation_actions_action_key_key; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.forum_reputation_actions
    ADD CONSTRAINT forum_reputation_actions_action_key_key UNIQUE (action_key);


--
-- Name: forum_reputation_actions forum_reputation_actions_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.forum_reputation_actions
    ADD CONSTRAINT forum_reputation_actions_pkey PRIMARY KEY (id);


--
-- Name: forum_reputation_history forum_reputation_history_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.forum_reputation_history
    ADD CONSTRAINT forum_reputation_history_pkey PRIMARY KEY (id);


--
-- Name: forum_reputation_levels forum_reputation_levels_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.forum_reputation_levels
    ADD CONSTRAINT forum_reputation_levels_pkey PRIMARY KEY (level);


--
-- Name: forum_saved_searches forum_saved_searches_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.forum_saved_searches
    ADD CONSTRAINT forum_saved_searches_pkey PRIMARY KEY (id);


--
-- Name: forum_scheduled_posts forum_scheduled_posts_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.forum_scheduled_posts
    ADD CONSTRAINT forum_scheduled_posts_pkey PRIMARY KEY (id);


--
-- Name: forum_search_history forum_search_history_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.forum_search_history
    ADD CONSTRAINT forum_search_history_pkey PRIMARY KEY (id);


--
-- Name: forum_series forum_series_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.forum_series
    ADD CONSTRAINT forum_series_pkey PRIMARY KEY (id);


--
-- Name: forum_series_posts forum_series_posts_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.forum_series_posts
    ADD CONSTRAINT forum_series_posts_pkey PRIMARY KEY (id);


--
-- Name: forum_series_posts forum_series_posts_series_id_forum_id_key; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.forum_series_posts
    ADD CONSTRAINT forum_series_posts_series_id_forum_id_key UNIQUE (series_id, forum_id);


--
-- Name: forum_series_posts forum_series_posts_series_id_sort_order_key; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.forum_series_posts
    ADD CONSTRAINT forum_series_posts_series_id_sort_order_key UNIQUE (series_id, sort_order);


--
-- Name: forum_series forum_series_slug_key; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.forum_series
    ADD CONSTRAINT forum_series_slug_key UNIQUE (slug);


--
-- Name: forum_subscriptions forum_subscriptions_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.forum_subscriptions
    ADD CONSTRAINT forum_subscriptions_pkey PRIMARY KEY (id);


--
-- Name: forum_system_messages forum_system_messages_message_key_key; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.forum_system_messages
    ADD CONSTRAINT forum_system_messages_message_key_key UNIQUE (message_key);


--
-- Name: forum_system_messages forum_system_messages_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.forum_system_messages
    ADD CONSTRAINT forum_system_messages_pkey PRIMARY KEY (id);


--
-- Name: forum_tags forum_tags_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.forum_tags
    ADD CONSTRAINT forum_tags_pkey PRIMARY KEY (id);


--
-- Name: forum_tags forum_tags_slug_key; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.forum_tags
    ADD CONSTRAINT forum_tags_slug_key UNIQUE (slug);


--
-- Name: forum_trust_levels forum_trust_levels_name_key; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.forum_trust_levels
    ADD CONSTRAINT forum_trust_levels_name_key UNIQUE (name);


--
-- Name: forum_trust_levels forum_trust_levels_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.forum_trust_levels
    ADD CONSTRAINT forum_trust_levels_pkey PRIMARY KEY (level);


--
-- Name: forum_user_badges forum_user_badges_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.forum_user_badges
    ADD CONSTRAINT forum_user_badges_pkey PRIMARY KEY (id);


--
-- Name: forum_user_blocks forum_user_blocks_blocker_id_blocked_id_key; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.forum_user_blocks
    ADD CONSTRAINT forum_user_blocks_blocker_id_blocked_id_key UNIQUE (blocker_id, blocked_id);


--
-- Name: forum_user_blocks forum_user_blocks_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.forum_user_blocks
    ADD CONSTRAINT forum_user_blocks_pkey PRIMARY KEY (id);


--
-- Name: forum_user_follows forum_user_follows_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.forum_user_follows
    ADD CONSTRAINT forum_user_follows_pkey PRIMARY KEY (id);


--
-- Name: forum_user_reputation forum_user_reputation_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.forum_user_reputation
    ADD CONSTRAINT forum_user_reputation_pkey PRIMARY KEY (id);


--
-- Name: forum_user_reputation forum_user_reputation_profile_id_key; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.forum_user_reputation
    ADD CONSTRAINT forum_user_reputation_profile_id_key UNIQUE (profile_id);


--
-- Name: forum_user_stats forum_user_stats_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.forum_user_stats
    ADD CONSTRAINT forum_user_stats_pkey PRIMARY KEY (profile_id);


--
-- Name: forum_user_warnings forum_user_warnings_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.forum_user_warnings
    ADD CONSTRAINT forum_user_warnings_pkey PRIMARY KEY (id);


--
-- Name: grok_usage_logs grok_usage_logs_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.grok_usage_logs
    ADD CONSTRAINT grok_usage_logs_pkey PRIMARY KEY (id);


--
-- Name: handlers handlers_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.handlers
    ADD CONSTRAINT handlers_pkey PRIMARY KEY (id);


--
-- Name: image_compressions image_compressions_bucket_original_path_key; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.image_compressions
    ADD CONSTRAINT image_compressions_bucket_original_path_key UNIQUE (bucket, original_path);


--
-- Name: image_compressions image_compressions_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.image_compressions
    ADD CONSTRAINT image_compressions_pkey PRIMARY KEY (id);


--
-- Name: image_upload_metrics image_upload_metrics_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.image_upload_metrics
    ADD CONSTRAINT image_upload_metrics_pkey PRIMARY KEY (id);


--
-- Name: in_app_notifications in_app_notifications_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.in_app_notifications
    ADD CONSTRAINT in_app_notifications_pkey PRIMARY KEY (id);


--
-- Name: languages languages_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.languages
    ADD CONSTRAINT languages_pkey PRIMARY KEY (id);


--
-- Name: legal_documents legal_documents_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.legal_documents
    ADD CONSTRAINT legal_documents_pkey PRIMARY KEY (id);


--
-- Name: legal_documents legal_documents_type_locale_key; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.legal_documents
    ADD CONSTRAINT legal_documents_type_locale_key UNIQUE (type, locale);


--
-- Name: legal legal_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.legal
    ADD CONSTRAINT legal_pkey PRIMARY KEY (id);


--
-- Name: likes likes_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.likes
    ADD CONSTRAINT likes_pkey PRIMARY KEY (id);


--
-- Name: location_update_queue location_update_queue_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.location_update_queue
    ADD CONSTRAINT location_update_queue_pkey PRIMARY KEY (id);


--
-- Name: location_update_queue location_update_queue_post_id_key; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.location_update_queue
    ADD CONSTRAINT location_update_queue_post_id_key UNIQUE (post_id);


--
-- Name: mfa_configuration mfa_configuration_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.mfa_configuration
    ADD CONSTRAINT mfa_configuration_pkey PRIMARY KEY (id);


--
-- Name: mfa_configuration mfa_configuration_profile_id_key; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.mfa_configuration
    ADD CONSTRAINT mfa_configuration_profile_id_key UNIQUE (profile_id);


--
-- Name: mfa_rate_limits mfa_rate_limits_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.mfa_rate_limits
    ADD CONSTRAINT mfa_rate_limits_pkey PRIMARY KEY (id);


--
-- Name: mfa_rate_limits mfa_rate_limits_profile_id_ip_address_limit_type_window_sta_key; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.mfa_rate_limits
    ADD CONSTRAINT mfa_rate_limits_profile_id_ip_address_limit_type_window_sta_key UNIQUE (profile_id, ip_address, limit_type, window_start);


--
-- Name: mfa_sessions mfa_sessions_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.mfa_sessions
    ADD CONSTRAINT mfa_sessions_pkey PRIMARY KEY (id);


--
-- Name: mfa_verification_attempts mfa_verification_attempts_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.mfa_verification_attempts
    ADD CONSTRAINT mfa_verification_attempts_pkey PRIMARY KEY (id);


--
-- Name: moderation_queue moderation_queue_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.moderation_queue
    ADD CONSTRAINT moderation_queue_pkey PRIMARY KEY (id);


--
-- Name: newsletter_campaigns newsletter_campaigns_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.newsletter_campaigns
    ADD CONSTRAINT newsletter_campaigns_pkey PRIMARY KEY (id);


--
-- Name: newsletter_subscribers newsletter_subscribers_email_key; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.newsletter_subscribers
    ADD CONSTRAINT newsletter_subscribers_email_key UNIQUE (email);


--
-- Name: newsletter_subscribers newsletter_subscribers_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.newsletter_subscribers
    ADD CONSTRAINT newsletter_subscribers_pkey PRIMARY KEY (id);


--
-- Name: notification_delivery_log notification_delivery_log_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.notification_delivery_log
    ADD CONSTRAINT notification_delivery_log_pkey PRIMARY KEY (id);


--
-- Name: notification_digest_queue notification_digest_queue_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.notification_digest_queue
    ADD CONSTRAINT notification_digest_queue_pkey PRIMARY KEY (id);


--
-- Name: notification_preferences notification_preferences_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.notification_preferences
    ADD CONSTRAINT notification_preferences_pkey PRIMARY KEY (id);


--
-- Name: notification_preferences notification_preferences_user_id_category_channel_key; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.notification_preferences
    ADD CONSTRAINT notification_preferences_user_id_category_channel_key UNIQUE (user_id, category, channel);


--
-- Name: notification_priority_config notification_priority_config_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.notification_priority_config
    ADD CONSTRAINT notification_priority_config_pkey PRIMARY KEY (notification_type);


--
-- Name: notification_queue notification_queue_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.notification_queue
    ADD CONSTRAINT notification_queue_pkey PRIMARY KEY (id);


--
-- Name: notification_settings notification_settings_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.notification_settings
    ADD CONSTRAINT notification_settings_pkey PRIMARY KEY (user_id);


--
-- Name: forum_polls one_poll_per_post; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.forum_polls
    ADD CONSTRAINT one_poll_per_post UNIQUE (forum_id);


--
-- Name: organization_members organization_members_organization_id_user_id_key; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.organization_members
    ADD CONSTRAINT organization_members_organization_id_user_id_key UNIQUE (organization_id, user_id);


--
-- Name: organization_members organization_members_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.organization_members
    ADD CONSTRAINT organization_members_pkey PRIMARY KEY (id);


--
-- Name: organizations organizations_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.organizations
    ADD CONSTRAINT organizations_pkey PRIMARY KEY (id);


--
-- Name: organizations organizations_slug_key; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.organizations
    ADD CONSTRAINT organizations_slug_key UNIQUE (slug);


--
-- Name: orphaned_storage_cleanup orphaned_storage_cleanup_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.orphaned_storage_cleanup
    ADD CONSTRAINT orphaned_storage_cleanup_pkey PRIMARY KEY (id);


--
-- Name: pending_operations pending_operations_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.pending_operations
    ADD CONSTRAINT pending_operations_pkey PRIMARY KEY (id);


--
-- Name: post_activity_daily_stats post_activity_daily_stats_date_post_type_key; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.post_activity_daily_stats
    ADD CONSTRAINT post_activity_daily_stats_date_post_type_key UNIQUE (date, post_type);


--
-- Name: post_activity_daily_stats post_activity_daily_stats_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.post_activity_daily_stats
    ADD CONSTRAINT post_activity_daily_stats_pkey PRIMARY KEY (id);


--
-- Name: post_activity_logs post_activity_logs_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.post_activity_logs
    ADD CONSTRAINT post_activity_logs_pkey PRIMARY KEY (id);


--
-- Name: post_reports post_reports_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.post_reports
    ADD CONSTRAINT post_reports_pkey PRIMARY KEY (id);


--
-- Name: post_views post_views_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.post_views
    ADD CONSTRAINT post_views_pkey PRIMARY KEY (id);


--
-- Name: posts posts_fridge_id_key; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.posts
    ADD CONSTRAINT posts_fridge_id_key UNIQUE (fridge_id);


--
-- Name: posts_image_backup posts_image_backup_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.posts_image_backup
    ADD CONSTRAINT posts_image_backup_pkey PRIMARY KEY (id);


--
-- Name: posts posts_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.posts
    ADD CONSTRAINT posts_pkey PRIMARY KEY (id);


--
-- Name: precomputed_feed_cells precomputed_feed_cells_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.precomputed_feed_cells
    ADD CONSTRAINT precomputed_feed_cells_pkey PRIMARY KEY (cell_id);


--
-- Name: profile_stats profile_stats_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.profile_stats
    ADD CONSTRAINT profile_stats_pkey PRIMARY KEY (profile_id);


--
-- Name: profiles profiles_duplicate_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.profiles
    ADD CONSTRAINT profiles_duplicate_pkey PRIMARY KEY (id);


--
-- Name: profiles profiles_telegram_id_key; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.profiles
    ADD CONSTRAINT profiles_telegram_id_key UNIQUE (telegram_id);


--
-- Name: profiles profiles_whatsapp_phone_key; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.profiles
    ADD CONSTRAINT profiles_whatsapp_phone_key UNIQUE (whatsapp_phone);


--
-- Name: rate_limits rate_limits_identifier_key; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.rate_limits
    ADD CONSTRAINT rate_limits_identifier_key UNIQUE (identifier);


--
-- Name: rate_limits rate_limits_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.rate_limits
    ADD CONSTRAINT rate_limits_pkey PRIMARY KEY (id);


--
-- Name: reaction_types reaction_types_name_key; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.reaction_types
    ADD CONSTRAINT reaction_types_name_key UNIQUE (name);


--
-- Name: reaction_types reaction_types_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.reaction_types
    ADD CONSTRAINT reaction_types_pkey PRIMARY KEY (id);


--
-- Name: reports reports_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.reports
    ADD CONSTRAINT reports_pkey PRIMARY KEY (id);


--
-- Name: reviews reviews_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.reviews
    ADD CONSTRAINT reviews_pkey PRIMARY KEY (id);


--
-- Name: roles roles_name_key; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.roles
    ADD CONSTRAINT roles_name_key UNIQUE (name);


--
-- Name: roles roles_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.roles
    ADD CONSTRAINT roles_pkey PRIMARY KEY (id);


--
-- Name: room_participants room_participants_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.room_participants
    ADD CONSTRAINT room_participants_pkey PRIMARY KEY (id);


--
-- Name: rooms rooms_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.rooms
    ADD CONSTRAINT rooms_pkey PRIMARY KEY (id);


--
-- Name: sync_checkpoints sync_checkpoints_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.sync_checkpoints
    ADD CONSTRAINT sync_checkpoints_pkey PRIMARY KEY (user_id, table_name);


--
-- Name: telegram_rate_limits telegram_rate_limits_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.telegram_rate_limits
    ADD CONSTRAINT telegram_rate_limits_pkey PRIMARY KEY (user_id);


--
-- Name: telegram_user_states telegram_user_states_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.telegram_user_states
    ADD CONSTRAINT telegram_user_states_pkey PRIMARY KEY (user_id);


--
-- Name: translation_analytics translation_analytics_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.translation_analytics
    ADD CONSTRAINT translation_analytics_pkey PRIMARY KEY (id);


--
-- Name: translation_backfill_jobs translation_backfill_jobs_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.translation_backfill_jobs
    ADD CONSTRAINT translation_backfill_jobs_pkey PRIMARY KEY (id);


--
-- Name: translation_cache translation_cache_locale_platform_key; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.translation_cache
    ADD CONSTRAINT translation_cache_locale_platform_key UNIQUE (locale, platform);


--
-- Name: translation_cache translation_cache_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.translation_cache
    ADD CONSTRAINT translation_cache_pkey PRIMARY KEY (id);


--
-- Name: translation_change_log translation_change_log_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.translation_change_log
    ADD CONSTRAINT translation_change_log_pkey PRIMARY KEY (id);


--
-- Name: translation_errors translation_errors_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.translation_errors
    ADD CONSTRAINT translation_errors_pkey PRIMARY KEY (id);


--
-- Name: translation_platform_config translation_platform_config_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.translation_platform_config
    ADD CONSTRAINT translation_platform_config_pkey PRIMARY KEY (id);


--
-- Name: translation_platform_config translation_platform_config_platform_key; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.translation_platform_config
    ADD CONSTRAINT translation_platform_config_platform_key UNIQUE (platform);


--
-- Name: translation_queue translation_queue_content_type_field_name_source_text_targe_key; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.translation_queue
    ADD CONSTRAINT translation_queue_content_type_field_name_source_text_targe_key UNIQUE (content_type, field_name, source_text, target_locale);


--
-- Name: translation_queue translation_queue_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.translation_queue
    ADD CONSTRAINT translation_queue_pkey PRIMARY KEY (id);


--
-- Name: translation_service_usage translation_service_usage_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.translation_service_usage
    ADD CONSTRAINT translation_service_usage_pkey PRIMARY KEY (id);


--
-- Name: translation_service_usage translation_service_usage_service_name_month_year_key; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.translation_service_usage
    ADD CONSTRAINT translation_service_usage_service_name_month_year_key UNIQUE (service_name, month_year);


--
-- Name: translation_sync_status translation_sync_status_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.translation_sync_status
    ADD CONSTRAINT translation_sync_status_pkey PRIMARY KEY (id);


--
-- Name: translation_sync_status translation_sync_status_user_id_device_id_locale_key; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.translation_sync_status
    ADD CONSTRAINT translation_sync_status_user_id_device_id_locale_key UNIQUE (user_id, device_id, locale);


--
-- Name: translation_usage_analytics translation_usage_analytics_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.translation_usage_analytics
    ADD CONSTRAINT translation_usage_analytics_pkey PRIMARY KEY (id);


--
-- Name: translation_versions translation_versions_locale_version_key; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.translation_versions
    ADD CONSTRAINT translation_versions_locale_version_key UNIQUE (locale, version);


--
-- Name: translation_versions translation_versions_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.translation_versions
    ADD CONSTRAINT translation_versions_pkey PRIMARY KEY (id);


--
-- Name: translations translations_locale_key; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.translations
    ADD CONSTRAINT translations_locale_key UNIQUE (locale);


--
-- Name: translations translations_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.translations
    ADD CONSTRAINT translations_pkey PRIMARY KEY (id);


--
-- Name: forum_subscriptions unique_category_subscription; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.forum_subscriptions
    ADD CONSTRAINT unique_category_subscription UNIQUE (profile_id, category_id);


--
-- Name: forum_user_follows unique_follow; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.forum_user_follows
    ADD CONSTRAINT unique_follow UNIQUE (follower_id, following_id);


--
-- Name: forum_reactions unique_forum_reaction; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.forum_reactions
    ADD CONSTRAINT unique_forum_reaction UNIQUE (forum_id, profile_id, reaction_type_id);


--
-- Name: forum_subscriptions unique_forum_subscription; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.forum_subscriptions
    ADD CONSTRAINT unique_forum_subscription UNIQUE (profile_id, forum_id);


--
-- Name: likes unique_like; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.likes
    ADD CONSTRAINT unique_like UNIQUE (post_id, profile_id);


--
-- Name: forum_mentions unique_mention_comment; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.forum_mentions
    ADD CONSTRAINT unique_mention_comment UNIQUE (mentioned_profile_id, mentioner_profile_id, comment_id);


--
-- Name: forum_mentions unique_mention_forum; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.forum_mentions
    ADD CONSTRAINT unique_mention_forum UNIQUE (mentioned_profile_id, mentioner_profile_id, forum_id);


--
-- Name: forum_reports unique_report_comment; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.forum_reports
    ADD CONSTRAINT unique_report_comment UNIQUE (reporter_id, comment_id);


--
-- Name: forum_reports unique_report_forum; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.forum_reports
    ADD CONSTRAINT unique_report_forum UNIQUE (reporter_id, forum_id);


--
-- Name: post_reports unique_report_per_user_post; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.post_reports
    ADD CONSTRAINT unique_report_per_user_post UNIQUE (post_id, reporter_id);


--
-- Name: dynamic_content_translations unique_translation; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.dynamic_content_translations
    ADD CONSTRAINT unique_translation UNIQUE (content_hash, target_locale);


--
-- Name: forum_user_badges unique_user_badge; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.forum_user_badges
    ADD CONSTRAINT unique_user_badge UNIQUE (profile_id, badge_id);


--
-- Name: user_preferences unique_user_preferences; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.user_preferences
    ADD CONSTRAINT unique_user_preferences UNIQUE (profile_id);


--
-- Name: post_views unique_view_session; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.post_views
    ADD CONSTRAINT unique_view_session UNIQUE (post_id, session_id);


--
-- Name: forum_poll_votes unique_vote_single; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.forum_poll_votes
    ADD CONSTRAINT unique_vote_single UNIQUE (poll_id, profile_id, option_id);


--
-- Name: telegram_user_activity user_activity_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.telegram_user_activity
    ADD CONSTRAINT user_activity_pkey PRIMARY KEY (id);


--
-- Name: user_activity_summary user_activity_summary_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.user_activity_summary
    ADD CONSTRAINT user_activity_summary_pkey PRIMARY KEY (user_id);


--
-- Name: telegram_user_activity user_activity_user_id_key; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.telegram_user_activity
    ADD CONSTRAINT user_activity_user_id_key UNIQUE (user_id);


--
-- Name: user_addresses user_addresses_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.user_addresses
    ADD CONSTRAINT user_addresses_pkey PRIMARY KEY (id);


--
-- Name: user_addresses user_addresses_profile_id_key; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.user_addresses
    ADD CONSTRAINT user_addresses_profile_id_key UNIQUE (profile_id);


--
-- Name: user_events user_events_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.user_events
    ADD CONSTRAINT user_events_pkey PRIMARY KEY (id, created_at);


--
-- Name: user_events_2025_12 user_events_2025_12_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.user_events_2025_12
    ADD CONSTRAINT user_events_2025_12_pkey PRIMARY KEY (id, created_at);


--
-- Name: user_events_2026_01 user_events_2026_01_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.user_events_2026_01
    ADD CONSTRAINT user_events_2026_01_pkey PRIMARY KEY (id, created_at);


--
-- Name: user_events_2026_02 user_events_2026_02_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.user_events_2026_02
    ADD CONSTRAINT user_events_2026_02_pkey PRIMARY KEY (id, created_at);


--
-- Name: user_locale_preferences user_locale_preferences_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.user_locale_preferences
    ADD CONSTRAINT user_locale_preferences_pkey PRIMARY KEY (id);


--
-- Name: user_locale_preferences user_locale_preferences_user_id_key; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.user_locale_preferences
    ADD CONSTRAINT user_locale_preferences_user_id_key UNIQUE (user_id);


--
-- Name: user_notifications user_notifications_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.user_notifications
    ADD CONSTRAINT user_notifications_pkey PRIMARY KEY (id);


--
-- Name: user_preferences user_preferences_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.user_preferences
    ADD CONSTRAINT user_preferences_pkey PRIMARY KEY (id);


--
-- Name: user_rate_limits user_rate_limits_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.user_rate_limits
    ADD CONSTRAINT user_rate_limits_pkey PRIMARY KEY (id);


--
-- Name: user_rate_limits user_rate_limits_user_id_key_key; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.user_rate_limits
    ADD CONSTRAINT user_rate_limits_user_id_key_key UNIQUE (user_id, key);


--
-- Name: user_roles user_roles_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.user_roles
    ADD CONSTRAINT user_roles_pkey PRIMARY KEY (profile_id, role_id);


--
-- Name: views views_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.views
    ADD CONSTRAINT views_pkey PRIMARY KEY (id);


--
-- Name: whatsapp_rate_limits whatsapp_rate_limits_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.whatsapp_rate_limits
    ADD CONSTRAINT whatsapp_rate_limits_pkey PRIMARY KEY (phone_number);


--
-- Name: whatsapp_user_states whatsapp_user_states_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.whatsapp_user_states
    ADD CONSTRAINT whatsapp_user_states_pkey PRIMARY KEY (phone_number);


--
-- Name: idx_address_country_id; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_address_country_id ON public.address USING btree (country_id);


--
-- Name: idx_admin_audit_log_admin_id; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_admin_audit_log_admin_id ON public.admin_audit_log USING btree (admin_id);


--
-- Name: idx_analytics_daily_stats_sync; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_analytics_daily_stats_sync ON public.analytics_daily_stats USING btree (synced_to_motherduck) WHERE (NOT synced_to_motherduck);


--
-- Name: idx_analytics_post_activity_sync; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_analytics_post_activity_sync ON public.analytics_post_activity USING btree (synced_to_motherduck) WHERE (NOT synced_to_motherduck);


--
-- Name: idx_analytics_user_activity_sync; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_analytics_user_activity_sync ON public.analytics_user_activity USING btree (synced_to_motherduck) WHERE (NOT synced_to_motherduck);


--
-- Name: idx_announcement_dismissals_profile; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_announcement_dismissals_profile ON public.forum_announcement_dismissals USING btree (profile_id);


--
-- Name: idx_app_config_category; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_app_config_category ON public.app_config USING btree (category);


--
-- Name: idx_app_config_platform; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_app_config_platform ON public.app_config USING btree (platform);


--
-- Name: idx_audit_logs_created_at; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_audit_logs_created_at ON public.audit_logs USING btree (created_at DESC);


--
-- Name: idx_audit_logs_user_id; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_audit_logs_user_id ON public.audit_logs USING btree (user_id);


--
-- Name: idx_automation_queue_scheduled; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_automation_queue_scheduled ON public.email_automation_queue USING btree (scheduled_for) WHERE (status = 'pending'::text);


--
-- Name: idx_automation_queue_status; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_automation_queue_status ON public.email_automation_queue USING btree (status, scheduled_for);


--
-- Name: idx_backfill_jobs_started; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_backfill_jobs_started ON public.translation_backfill_jobs USING btree (started_at DESC);


--
-- Name: idx_backfill_jobs_type_status; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_backfill_jobs_type_status ON public.translation_backfill_jobs USING btree (job_type, status);


--
-- Name: idx_blocked_users_blocked_at; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_blocked_users_blocked_at ON public.blocked_users USING btree (blocked_at DESC);


--
-- Name: idx_blocked_users_blocked_user_id; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_blocked_users_blocked_user_id ON public.blocked_users USING btree (blocked_user_id);


--
-- Name: idx_blocked_users_user_id; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_blocked_users_user_id ON public.blocked_users USING btree (user_id);


--
-- Name: idx_bookmarks_forum; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_bookmarks_forum ON public.bookmarks USING btree (forum_id, profile_id) WHERE ((forum_id > 0) AND (post_id = 0));


--
-- Name: idx_bookmarks_post; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_bookmarks_post ON public.bookmarks USING btree (post_id, profile_id) WHERE ((post_id > 0) AND (forum_id = 0));


--
-- Name: idx_bookmarks_user_forum; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_bookmarks_user_forum ON public.bookmarks USING btree (profile_id, created_at DESC) WHERE ((forum_id > 0) AND (post_id = 0));


--
-- Name: idx_bookmarks_user_posts; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_bookmarks_user_posts ON public.bookmarks USING btree (profile_id, created_at DESC) WHERE ((post_id > 0) AND (forum_id = 0));


--
-- Name: idx_bounce_events_created; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_bounce_events_created ON public.email_bounce_events USING btree (created_at DESC);


--
-- Name: idx_bounce_events_type; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_bounce_events_type ON public.email_bounce_events USING btree (event_type);


--
-- Name: idx_challenge_activities_challenge_id; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_challenge_activities_challenge_id ON public.challenge_activities USING btree (challenge_id);


--
-- Name: idx_challenges_profile_id; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_challenges_profile_id ON public.challenges USING btree (profile_id);


--
-- Name: idx_comments_forum_depth; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_comments_forum_depth ON public.comments USING btree (forum_id, depth, comment_created_at);


--
-- Name: idx_comments_parent_id; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_comments_parent_id ON public.comments USING btree (parent_id);


--
-- Name: idx_comments_user_id_fk; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_comments_user_id_fk ON public.comments USING btree (user_id);


--
-- Name: INDEX idx_comments_user_id_fk; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON INDEX public.idx_comments_user_id_fk IS 'Index for comments.user_id FK - improves user comment lookups';


--
-- Name: idx_crm_customers_lifecycle_stage; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_crm_customers_lifecycle_stage ON public.crm_customers USING btree (lifecycle_stage);


--
-- Name: idx_dct_content_type; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_dct_content_type ON public.dynamic_content_translations USING btree (content_type);


--
-- Name: idx_dct_expires; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_dct_expires ON public.dynamic_content_translations USING btree (expires_at);


--
-- Name: idx_dct_hash_locale; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_dct_hash_locale ON public.dynamic_content_translations USING btree (content_hash, target_locale);


--
-- Name: idx_device_tokens_profile_platform; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_device_tokens_profile_platform ON public.device_tokens USING btree (profile_id, platform);


--
-- Name: idx_device_tokens_token; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_device_tokens_token ON public.device_tokens USING btree (token);


--
-- Name: idx_digest_queue_pending; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_digest_queue_pending ON public.notification_digest_queue USING btree (scheduled_for, status) WHERE (status = 'pending'::text);


--
-- Name: idx_digest_queue_user; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_digest_queue_user ON public.notification_digest_queue USING btree (user_id, status);


--
-- Name: idx_display_name_overrides_expires; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_display_name_overrides_expires ON public.display_name_overrides USING btree (expires_at) WHERE (expires_at IS NOT NULL);


--
-- Name: idx_email_audit_log_created_at; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_email_audit_log_created_at ON public.email_audit_log USING btree (created_at DESC);


--
-- Name: idx_email_audit_log_details; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_email_audit_log_details ON public.email_audit_log USING gin (details);


--
-- Name: idx_email_audit_log_event_type; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_email_audit_log_event_type ON public.email_audit_log USING btree (event_type, created_at DESC);


--
-- Name: idx_email_audit_log_request_id; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_email_audit_log_request_id ON public.email_audit_log USING btree (request_id) WHERE (request_id IS NOT NULL);


--
-- Name: idx_email_audit_log_severity; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_email_audit_log_severity ON public.email_audit_log USING btree (severity, created_at DESC) WHERE (severity = ANY (ARRAY['warning'::text, 'critical'::text]));


--
-- Name: idx_email_audit_log_target_email; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_email_audit_log_target_email ON public.email_audit_log USING btree (target_email, created_at DESC) WHERE (target_email IS NOT NULL);


--
-- Name: idx_email_audit_log_user_id; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_email_audit_log_user_id ON public.email_audit_log USING btree (user_id, created_at DESC);


--
-- Name: idx_email_delivery_campaign_status; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_email_delivery_campaign_status ON public.email_delivery_log USING btree (campaign_id, status) WHERE (campaign_id IS NOT NULL);


--
-- Name: idx_email_delivery_message_id; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_email_delivery_message_id ON public.email_delivery_log USING btree (message_id) WHERE (message_id IS NOT NULL);


--
-- Name: idx_email_delivery_provider; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_email_delivery_provider ON public.email_delivery_log USING btree (provider, sent_at DESC) WHERE (provider IS NOT NULL);


--
-- Name: idx_email_delivery_status_queued; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_email_delivery_status_queued ON public.email_delivery_log USING btree (status, queued_at) WHERE (status = ANY (ARRAY['queued'::text, 'sent'::text]));


--
-- Name: idx_email_delivery_undelivered; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_email_delivery_undelivered ON public.email_delivery_log USING btree (user_id) WHERE (status <> ALL (ARRAY['delivered'::text, 'opened'::text, 'clicked'::text]));


--
-- Name: idx_email_delivery_user_queued; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_email_delivery_user_queued ON public.email_delivery_log USING btree (user_id, queued_at DESC);


--
-- Name: idx_email_logs_recipient_id; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_email_logs_recipient_id ON public.email_logs USING btree (recipient_id);


--
-- Name: idx_email_preferences_profile_id; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_email_preferences_profile_id ON public.email_preferences USING btree (profile_id);


--
-- Name: idx_email_provider_health_provider; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_email_provider_health_provider ON public.email_provider_health_metrics USING btree (provider);


--
-- Name: idx_email_provider_stats_provider_date; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_email_provider_stats_provider_date ON public.email_provider_stats USING btree (provider, date DESC);


--
-- Name: idx_email_queue_recipient_id; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_email_queue_recipient_id ON public.email_queue USING btree (recipient_id);


--
-- Name: idx_email_suppressions_email; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_email_suppressions_email ON public.email_suppressions USING btree (email);


--
-- Name: idx_email_suppressions_expires_at; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_email_suppressions_expires_at ON public.email_suppressions USING btree (expires_at) WHERE (expires_at IS NOT NULL);


--
-- Name: idx_email_templates_active; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_email_templates_active ON public.email_templates USING btree (is_active) WHERE (is_active = true);


--
-- Name: idx_email_templates_category; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_email_templates_category ON public.email_templates USING btree (category);


--
-- Name: idx_email_templates_slug; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_email_templates_slug ON public.email_templates USING btree (slug);


--
-- Name: idx_email_templates_updated; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_email_templates_updated ON public.email_templates USING btree (updated_at DESC);


--
-- Name: idx_follows_follower; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_follows_follower ON public.forum_user_follows USING btree (follower_id);


--
-- Name: idx_follows_following; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_follows_following ON public.forum_user_follows USING btree (following_id);


--
-- Name: idx_forum_activities_profile_id; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_forum_activities_profile_id ON public.forum_activities USING btree (profile_id);


--
-- Name: idx_forum_activities_target_comment_id; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_forum_activities_target_comment_id ON public.forum_activities USING btree (target_comment_id);


--
-- Name: idx_forum_activities_target_profile; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_forum_activities_target_profile ON public.forum_activities USING btree (target_profile_id) WHERE (target_profile_id IS NOT NULL);


--
-- Name: idx_forum_announcement_analytics_profile_id; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_forum_announcement_analytics_profile_id ON public.forum_announcement_analytics USING btree (profile_id);


--
-- Name: idx_forum_author_analytics_profile; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_forum_author_analytics_profile ON public.forum_author_analytics USING btree (profile_id);


--
-- Name: idx_forum_best_answer_id_fk; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_forum_best_answer_id_fk ON public.forum USING btree (best_answer_id);


--
-- Name: INDEX idx_forum_best_answer_id_fk; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON INDEX public.idx_forum_best_answer_id_fk IS 'Index for forum.best_answer_id FK - improves best answer lookups';


--
-- Name: idx_forum_bookmark_collections_profile; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_forum_bookmark_collections_profile ON public.forum_bookmark_collections USING btree (profile_id);


--
-- Name: idx_forum_category_id; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_forum_category_id ON public.forum USING btree (category_id);


--
-- Name: idx_forum_comment_history_editor_id; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_forum_comment_history_editor_id ON public.forum_comment_history USING btree (editor_id);


--
-- Name: idx_forum_comment_reactions_profile; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_forum_comment_reactions_profile ON public.forum_comment_reactions USING btree (profile_id);


--
-- Name: idx_forum_conversation_participants_profile; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_forum_conversation_participants_profile ON public.forum_conversation_participants USING btree (profile_id);


--
-- Name: idx_forum_conversations_created_by; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_forum_conversations_created_by ON public.forum_conversations USING btree (created_by);


--
-- Name: idx_forum_featured_by; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_forum_featured_by ON public.forum USING btree (featured_by);


--
-- Name: idx_forum_feed_read_status_profile; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_forum_feed_read_status_profile ON public.forum_feed_read_status USING btree (profile_id);


--
-- Name: idx_forum_mentions_mentioner_profile_id; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_forum_mentions_mentioner_profile_id ON public.forum_mentions USING btree (mentioner_profile_id);


--
-- Name: idx_forum_message_reactions_profile_id; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_forum_message_reactions_profile_id ON public.forum_message_reactions USING btree (profile_id);


--
-- Name: idx_forum_message_read_receipts_profile; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_forum_message_read_receipts_profile ON public.forum_message_read_receipts USING btree (profile_id);


--
-- Name: idx_forum_messages_sender; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_forum_messages_sender ON public.forum_messages USING btree (sender_id);


--
-- Name: idx_forum_moderation_notes_moderator_id; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_forum_moderation_notes_moderator_id ON public.forum_moderation_notes USING btree (moderator_id);


--
-- Name: idx_forum_notifications_actor_id; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_forum_notifications_actor_id ON public.forum_notifications USING btree (actor_id);


--
-- Name: idx_forum_notifications_comment_id; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_forum_notifications_comment_id ON public.forum_notifications USING btree (comment_id);


--
-- Name: idx_forum_notifications_forum_id; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_forum_notifications_forum_id ON public.forum_notifications USING btree (forum_id);


--
-- Name: idx_forum_notifications_recipient_created; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_forum_notifications_recipient_created ON public.forum_notifications USING btree (recipient_id, created_at DESC);


--
-- Name: idx_forum_pinned; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_forum_pinned ON public.forum USING btree (is_pinned DESC, last_activity_at DESC) WHERE (forum_published = true);


--
-- Name: idx_forum_post_history_editor_id; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_forum_post_history_editor_id ON public.forum_post_history USING btree (editor_id);


--
-- Name: idx_forum_post_tags_forum; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_forum_post_tags_forum ON public.forum_post_tags USING btree (forum_id);


--
-- Name: idx_forum_profile_id; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_forum_profile_id ON public.forum USING btree (profile_id);


--
-- Name: idx_forum_published_date; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_forum_published_date ON public.forum USING btree (forum_published, forum_post_created_at DESC, id) WHERE (forum_published = true);


--
-- Name: idx_forum_rate_limits_lookup; Type: INDEX; Schema: public; Owner: -
--

CREATE UNIQUE INDEX idx_forum_rate_limits_lookup ON public.forum_rate_limits USING btree (profile_id, action_type, window_start);


--
-- Name: idx_forum_reactions_profile; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_forum_reactions_profile ON public.forum_reactions USING btree (profile_id);


--
-- Name: idx_forum_reactions_reaction_type_id; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_forum_reactions_reaction_type_id ON public.forum_reactions USING btree (reaction_type_id);


--
-- Name: idx_forum_reading_progress_forum_id; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_forum_reading_progress_forum_id ON public.forum_reading_progress USING btree (forum_id);


--
-- Name: idx_forum_reputation_history_source_profile_id; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_forum_reputation_history_source_profile_id ON public.forum_reputation_history USING btree (source_profile_id);


--
-- Name: idx_forum_series_id; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_forum_series_id ON public.forum USING btree (series_id);


--
-- Name: idx_forum_slug_unique; Type: INDEX; Schema: public; Owner: -
--

CREATE UNIQUE INDEX idx_forum_slug_unique ON public.forum USING btree (slug) WHERE (slug IS NOT NULL);


--
-- Name: idx_forum_subscriptions_forum_id; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_forum_subscriptions_forum_id ON public.forum_subscriptions USING btree (forum_id);


--
-- Name: idx_forum_user_badges_awarded_by; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_forum_user_badges_awarded_by ON public.forum_user_badges USING btree (awarded_by);


--
-- Name: idx_forum_user_blocks_blocked; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_forum_user_blocks_blocked ON public.forum_user_blocks USING btree (blocked_id);


--
-- Name: idx_forum_user_blocks_blocker; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_forum_user_blocks_blocker ON public.forum_user_blocks USING btree (blocker_id);


--
-- Name: idx_forum_user_warnings_ban_lifted_by; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_forum_user_warnings_ban_lifted_by ON public.forum_user_warnings USING btree (ban_lifted_by);


--
-- Name: idx_forum_user_warnings_moderator_id; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_forum_user_warnings_moderator_id ON public.forum_user_warnings USING btree (moderator_id);


--
-- Name: idx_health_events_created; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_health_events_created ON public.email_health_events USING btree (created_at DESC);


--
-- Name: idx_image_compressions_bucket; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_image_compressions_bucket ON public.image_compressions USING btree (bucket);


--
-- Name: idx_image_compressions_status; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_image_compressions_status ON public.image_compressions USING btree (status);


--
-- Name: idx_image_metrics_bucket; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_image_metrics_bucket ON public.image_upload_metrics USING btree (bucket);


--
-- Name: idx_image_metrics_uploaded; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_image_metrics_uploaded ON public.image_upload_metrics USING btree (uploaded_at DESC);


--
-- Name: idx_image_metrics_user; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_image_metrics_user ON public.image_upload_metrics USING btree (user_id);


--
-- Name: idx_image_upload_metrics_storage; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_image_upload_metrics_storage ON public.image_upload_metrics USING btree (storage);


--
-- Name: idx_in_app_notifications_category; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_in_app_notifications_category ON public.in_app_notifications USING btree (category);


--
-- Name: idx_in_app_notifications_created_at; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_in_app_notifications_created_at ON public.in_app_notifications USING btree (created_at DESC);


--
-- Name: idx_in_app_notifications_user_id; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_in_app_notifications_user_id ON public.in_app_notifications USING btree (user_id);


--
-- Name: idx_in_app_notifications_user_id_unread; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_in_app_notifications_user_id_unread ON public.in_app_notifications USING btree (user_id) WHERE (read_at IS NULL);


--
-- Name: idx_legal_documents_type_locale; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_legal_documents_type_locale ON public.legal_documents USING btree (type, locale);


--
-- Name: idx_likes_challenge; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_likes_challenge ON public.likes USING btree (challenge_id, profile_id) WHERE ((challenge_id > 0) AND (post_id = 0) AND (forum_id = 0) AND (comment_id = 0));


--
-- Name: idx_likes_challenge_count; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_likes_challenge_count ON public.likes USING btree (challenge_id) WHERE (challenge_id > 0);


--
-- Name: idx_likes_comment; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_likes_comment ON public.likes USING btree (comment_id, profile_id) WHERE ((comment_id > 0) AND (post_id = 0) AND (forum_id = 0) AND (challenge_id = 0));


--
-- Name: idx_likes_comment_count; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_likes_comment_count ON public.likes USING btree (comment_id) WHERE (comment_id > 0);


--
-- Name: idx_likes_forum; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_likes_forum ON public.likes USING btree (forum_id, profile_id) WHERE ((forum_id > 0) AND (post_id = 0) AND (challenge_id = 0) AND (comment_id = 0));


--
-- Name: idx_likes_forum_count; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_likes_forum_count ON public.likes USING btree (forum_id) WHERE (forum_id > 0);


--
-- Name: idx_likes_post; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_likes_post ON public.likes USING btree (post_id, profile_id) WHERE ((post_id > 0) AND (forum_id = 0) AND (challenge_id = 0) AND (comment_id = 0));


--
-- Name: idx_likes_post_count; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_likes_post_count ON public.likes USING btree (post_id) WHERE ((challenge_id = 0) AND (forum_id = 0));


--
-- Name: idx_likes_post_profile_type; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_likes_post_profile_type ON public.likes USING btree (post_id, profile_id) WHERE ((challenge_id = 0) AND (forum_id = 0));


--
-- Name: idx_likes_user_post_composite; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_likes_user_post_composite ON public.likes USING btree (profile_id, post_id);


--
-- Name: idx_mentions_comment; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_mentions_comment ON public.forum_mentions USING btree (comment_id) WHERE (comment_id IS NOT NULL);


--
-- Name: idx_mentions_mentioned_profile; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_mentions_mentioned_profile ON public.forum_mentions USING btree (mentioned_profile_id);


--
-- Name: idx_mfa_attempts_profile; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_mfa_attempts_profile ON public.mfa_verification_attempts USING btree (profile_id, created_at DESC);


--
-- Name: idx_mfa_config_profile; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_mfa_config_profile ON public.mfa_configuration USING btree (profile_id);


--
-- Name: idx_mfa_rate_limits_profile; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_mfa_rate_limits_profile ON public.mfa_rate_limits USING btree (profile_id, limit_type);


--
-- Name: idx_moderation_queue_created_at; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_moderation_queue_created_at ON public.moderation_queue USING btree (created_at DESC);


--
-- Name: idx_moderation_queue_item_type; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_moderation_queue_item_type ON public.moderation_queue USING btree (item_type);


--
-- Name: idx_moderation_queue_reporter; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_moderation_queue_reporter ON public.moderation_queue USING btree (reporter_id);


--
-- Name: idx_moderation_queue_status; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_moderation_queue_status ON public.moderation_queue USING btree (status) WHERE (status = 'pending'::text);


--
-- Name: idx_monthly_quota_lookup; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_monthly_quota_lookup ON public.email_provider_monthly_quota USING btree (provider, year_month, organization_id);


--
-- Name: idx_mv_user_stats_user_id; Type: INDEX; Schema: public; Owner: -
--

CREATE UNIQUE INDEX idx_mv_user_stats_user_id ON public.mv_user_stats USING btree (user_id);


--
-- Name: idx_newsletter_campaigns_status; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_newsletter_campaigns_status ON public.newsletter_campaigns USING btree (status);


--
-- Name: idx_newsletter_subscribers_status; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_newsletter_subscribers_status ON public.newsletter_subscribers USING btree (status);


--
-- Name: idx_notification_delivery_log_created_at; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_notification_delivery_log_created_at ON public.notification_delivery_log USING btree (created_at DESC);


--
-- Name: idx_notification_delivery_log_notification_id; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_notification_delivery_log_notification_id ON public.notification_delivery_log USING btree (notification_id);


--
-- Name: idx_notification_delivery_log_status; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_notification_delivery_log_status ON public.notification_delivery_log USING btree (status);


--
-- Name: idx_notification_delivery_log_type; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_notification_delivery_log_type ON public.notification_delivery_log USING btree (type);


--
-- Name: idx_notification_delivery_log_user_id; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_notification_delivery_log_user_id ON public.notification_delivery_log USING btree (user_id);


--
-- Name: idx_notification_digest_queue_frequency_status; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_notification_digest_queue_frequency_status ON public.notification_digest_queue USING btree (frequency, status);


--
-- Name: idx_notification_digest_queue_scheduled_for; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_notification_digest_queue_scheduled_for ON public.notification_digest_queue USING btree (scheduled_for) WHERE (status = 'pending'::text);


--
-- Name: idx_notification_digest_queue_user_id; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_notification_digest_queue_user_id ON public.notification_digest_queue USING btree (user_id);


--
-- Name: idx_notification_prefs_user; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_notification_prefs_user ON public.notification_preferences USING btree (user_id);


--
-- Name: idx_notification_prefs_user_category; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_notification_prefs_user_category ON public.notification_preferences USING btree (user_id, category);


--
-- Name: idx_notification_queue_created_at; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_notification_queue_created_at ON public.notification_queue USING btree (created_at DESC);


--
-- Name: idx_notification_queue_scheduled_for; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_notification_queue_scheduled_for ON public.notification_queue USING btree (scheduled_for) WHERE (status = 'pending'::text);


--
-- Name: idx_notification_queue_status; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_notification_queue_status ON public.notification_queue USING btree (status);


--
-- Name: idx_notification_queue_user_id; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_notification_queue_user_id ON public.notification_queue USING btree (user_id);


--
-- Name: idx_notifications_profile_id; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_notifications_profile_id ON public.notifications USING btree (profile_id);


--
-- Name: idx_org_members_user; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_org_members_user ON public.organization_members USING btree (user_id);


--
-- Name: idx_poll_votes_profile; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_poll_votes_profile ON public.forum_poll_votes USING btree (profile_id);


--
-- Name: idx_post_activity_logs_post_id; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_post_activity_logs_post_id ON public.post_activity_logs USING btree (post_id);


--
-- Name: idx_post_reports_post_id; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_post_reports_post_id ON public.post_reports USING btree (post_id);


--
-- Name: idx_post_reports_reporter_id; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_post_reports_reporter_id ON public.post_reports USING btree (reporter_id);


--
-- Name: idx_post_views_post_id; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_post_views_post_id ON public.post_views USING btree (post_id);


--
-- Name: idx_post_views_viewer_id; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_post_views_viewer_id ON public.post_views USING btree (viewer_id);


--
-- Name: idx_posts_category_id; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_posts_category_id ON public.posts USING btree (category_id);


--
-- Name: idx_posts_global_feed; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_posts_global_feed ON public.posts USING btree (created_at DESC, id, profile_id) WHERE (is_active = true);


--
-- Name: idx_posts_location_gist; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_posts_location_gist ON public.posts USING gist (location);


--
-- Name: INDEX idx_posts_location_gist; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON INDEX public.idx_posts_location_gist IS 'Spatial index on posts.location for efficient PostGIS geo-queries (ST_DWithin, bounding box).';


--
-- Name: idx_posts_post_arranged_to; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_posts_post_arranged_to ON public.posts USING btree (post_arranged_to);


--
-- Name: idx_posts_profile_id; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_posts_profile_id ON public.posts USING btree (profile_id);


--
-- Name: idx_posts_type_active_composite; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_posts_type_active_composite ON public.posts USING btree (post_type, is_active) WHERE (is_active = true);


--
-- Name: idx_posts_unsynced; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_posts_unsynced ON public.posts USING btree (synced_to_motherduck) WHERE (NOT synced_to_motherduck);


--
-- Name: idx_profiles_location_gist; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_profiles_location_gist ON public.profiles USING gist (location);


--
-- Name: idx_profiles_unsynced; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_profiles_unsynced ON public.profiles USING btree (synced_to_motherduck) WHERE (NOT synced_to_motherduck);


--
-- Name: idx_profiles_visibility; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_profiles_visibility ON public.profiles USING btree (profile_visibility);


--
-- Name: idx_provider_metrics_date; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_provider_metrics_date ON public.email_provider_metrics USING btree (date DESC);


--
-- Name: idx_reading_history_cleanup; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_reading_history_cleanup ON public.forum_reading_history USING btree (profile_id, viewed_at);


--
-- Name: idx_reading_progress_profile; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_reading_progress_profile ON public.forum_reading_progress USING btree (profile_id);


--
-- Name: idx_reports_comment; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_reports_comment ON public.forum_reports USING btree (comment_id) WHERE (comment_id IS NOT NULL);


--
-- Name: idx_reputation_history_profile; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_reputation_history_profile ON public.forum_reputation_history USING btree (profile_id);


--
-- Name: idx_reviews_post_id; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_reviews_post_id ON public.reviews USING btree (post_id);


--
-- Name: idx_reviews_profile_id; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_reviews_profile_id ON public.reviews USING btree (profile_id);


--
-- Name: idx_room_participants_profile_id; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_room_participants_profile_id ON public.room_participants USING btree (profile_id);


--
-- Name: idx_room_participants_room_id; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_room_participants_room_id ON public.room_participants USING btree (room_id);


--
-- Name: idx_rooms_post_id; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_rooms_post_id ON public.rooms USING btree (post_id);


--
-- Name: idx_rooms_requester; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_rooms_requester ON public.rooms USING btree (requester);


--
-- Name: idx_rooms_sharer; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_rooms_sharer ON public.rooms USING btree (sharer);


--
-- Name: idx_saved_searches_profile; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_saved_searches_profile ON public.forum_saved_searches USING btree (profile_id);


--
-- Name: idx_search_history_profile; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_search_history_profile ON public.forum_search_history USING btree (profile_id, searched_at DESC);


--
-- Name: idx_staging_listings_synced; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_staging_listings_synced ON public.analytics_staging_listings USING btree (synced_to_motherduck);


--
-- Name: idx_staging_users_synced; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_staging_users_synced ON public.analytics_staging_users USING btree (synced_to_motherduck);


--
-- Name: idx_subscriptions_profile; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_subscriptions_profile ON public.forum_subscriptions USING btree (profile_id);


--
-- Name: idx_suppression_email; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_suppression_email ON public.email_suppression_list USING btree (email);


--
-- Name: idx_template_versions_changed_at; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_template_versions_changed_at ON public.email_template_versions USING btree (changed_at DESC);


--
-- Name: idx_template_versions_template; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_template_versions_template ON public.email_template_versions USING btree (template_id);


--
-- Name: idx_translation_queue_completed; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_translation_queue_completed ON public.translation_queue USING btree (status, processed_at) WHERE (status = 'completed'::text);


--
-- Name: idx_translation_queue_pending; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_translation_queue_pending ON public.translation_queue USING btree (status, created_at) WHERE (status = 'pending'::text);


--
-- Name: idx_translation_queue_processing; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_translation_queue_processing ON public.translation_queue USING btree (status, created_at) WHERE (status = 'processing'::text);


--
-- Name: idx_translation_usage_service_month; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_translation_usage_service_month ON public.translation_service_usage USING btree (service_name, month_year);


--
-- Name: idx_translations_locale; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_translations_locale ON public.content_translations USING btree (target_locale, created_at DESC);


--
-- Name: idx_translations_popular; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_translations_popular ON public.content_translations USING btree (hit_count DESC) WHERE (hit_count > 10);


--
-- Name: idx_tua_locale; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_tua_locale ON public.translation_usage_analytics USING btree (target_locale, created_at);


--
-- Name: idx_tua_user_date; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_tua_user_date ON public.translation_usage_analytics USING btree (user_id, created_at);


--
-- Name: idx_user_addresses_location; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_user_addresses_location ON public.user_addresses USING btree (latitude, longitude) WHERE (latitude IS NOT NULL);


--
-- Name: idx_user_addresses_profile; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_user_addresses_profile ON public.user_addresses USING btree (profile_id);


--
-- Name: idx_user_badges_profile; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_user_badges_profile ON public.forum_user_badges USING btree (profile_id);


--
-- Name: idx_user_email_health_delivery_rate; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_user_email_health_delivery_rate ON public.user_email_health USING btree (delivery_rate DESC NULLS LAST);


--
-- Name: idx_user_email_health_user_id; Type: INDEX; Schema: public; Owner: -
--

CREATE UNIQUE INDEX idx_user_email_health_user_id ON public.user_email_health USING btree (user_id);


--
-- Name: idx_user_events_type; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_user_events_type ON ONLY public.user_events USING btree (event_type, created_at DESC);


--
-- Name: idx_user_events_user_type; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_user_events_user_type ON ONLY public.user_events USING btree (user_id, event_type, created_at DESC);


--
-- Name: idx_user_notifications_actor_id; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_user_notifications_actor_id ON public.user_notifications USING btree (actor_id);


--
-- Name: idx_user_notifications_post_id; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_user_notifications_post_id ON public.user_notifications USING btree (post_id);


--
-- Name: idx_user_notifications_recipient_id; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_user_notifications_recipient_id ON public.user_notifications USING btree (recipient_id);


--
-- Name: idx_user_notifications_room; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_user_notifications_room ON public.user_notifications USING btree (room_id) WHERE (room_id IS NOT NULL);


--
-- Name: idx_user_rate_limits_reset; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_user_rate_limits_reset ON public.user_rate_limits USING btree (reset_at);


--
-- Name: idx_user_rate_limits_user_key; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_user_rate_limits_user_key ON public.user_rate_limits USING btree (user_id, key);


--
-- Name: idx_user_roles_granted_by; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_user_roles_granted_by ON public.user_roles USING btree (granted_by);


--
-- Name: idx_user_roles_profile_id; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_user_roles_profile_id ON public.user_roles USING btree (profile_id);


--
-- Name: idx_user_roles_role_id; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_user_roles_role_id ON public.user_roles USING btree (role_id);


--
-- Name: idx_user_warnings_profile; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_user_warnings_profile ON public.forum_user_warnings USING btree (profile_id);


--
-- Name: idx_views_challenge; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_views_challenge ON public.views USING btree (challenge_id, profile_id) WHERE (challenge_id > 0);


--
-- Name: idx_views_challenge_count; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_views_challenge_count ON public.views USING btree (challenge_id) WHERE (challenge_id > 0);


--
-- Name: idx_views_forum; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_views_forum ON public.views USING btree (forum_id, profile_id) WHERE (forum_id > 0);


--
-- Name: idx_views_forum_count; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_views_forum_count ON public.views USING btree (forum_id) WHERE (forum_id > 0);


--
-- Name: idx_views_post; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_views_post ON public.views USING btree (post_id, profile_id) WHERE (post_id > 0);


--
-- Name: idx_views_post_count; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_views_post_count ON public.views USING btree (post_id) WHERE (post_id > 0);


--
-- Name: idx_views_post_id; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_views_post_id ON public.views USING btree (post_id);


--
-- Name: idx_views_profile_id; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_views_profile_id ON public.views USING btree (profile_id);


--
-- Name: uniq_bookmarks_forum; Type: INDEX; Schema: public; Owner: -
--

CREATE UNIQUE INDEX uniq_bookmarks_forum ON public.bookmarks USING btree (forum_id, profile_id) WHERE ((forum_id > 0) AND (post_id = 0));


--
-- Name: uniq_bookmarks_post; Type: INDEX; Schema: public; Owner: -
--

CREATE UNIQUE INDEX uniq_bookmarks_post ON public.bookmarks USING btree (post_id, profile_id) WHERE ((post_id > 0) AND (forum_id = 0));


--
-- Name: uniq_likes_challenge; Type: INDEX; Schema: public; Owner: -
--

CREATE UNIQUE INDEX uniq_likes_challenge ON public.likes USING btree (challenge_id, profile_id) WHERE ((challenge_id > 0) AND (post_id = 0) AND (forum_id = 0) AND (comment_id = 0));


--
-- Name: uniq_likes_comment; Type: INDEX; Schema: public; Owner: -
--

CREATE UNIQUE INDEX uniq_likes_comment ON public.likes USING btree (comment_id, profile_id) WHERE ((comment_id > 0) AND (post_id = 0) AND (forum_id = 0) AND (challenge_id = 0));


--
-- Name: uniq_likes_forum; Type: INDEX; Schema: public; Owner: -
--

CREATE UNIQUE INDEX uniq_likes_forum ON public.likes USING btree (forum_id, profile_id) WHERE ((forum_id > 0) AND (post_id = 0) AND (challenge_id = 0) AND (comment_id = 0));


--
-- Name: uniq_likes_post; Type: INDEX; Schema: public; Owner: -
--

CREATE UNIQUE INDEX uniq_likes_post ON public.likes USING btree (post_id, profile_id) WHERE ((post_id > 0) AND (forum_id = 0) AND (challenge_id = 0) AND (comment_id = 0));


--
-- Name: user_events_2025_12_event_type_created_at_idx; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX user_events_2025_12_event_type_created_at_idx ON public.user_events_2025_12 USING btree (event_type, created_at DESC);


--
-- Name: user_events_2025_12_user_id_event_type_created_at_idx; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX user_events_2025_12_user_id_event_type_created_at_idx ON public.user_events_2025_12 USING btree (user_id, event_type, created_at DESC);


--
-- Name: user_events_2026_01_event_type_created_at_idx; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX user_events_2026_01_event_type_created_at_idx ON public.user_events_2026_01 USING btree (event_type, created_at DESC);


--
-- Name: user_events_2026_01_user_id_event_type_created_at_idx; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX user_events_2026_01_user_id_event_type_created_at_idx ON public.user_events_2026_01 USING btree (user_id, event_type, created_at DESC);


--
-- Name: user_events_2026_02_event_type_created_at_idx; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX user_events_2026_02_event_type_created_at_idx ON public.user_events_2026_02 USING btree (event_type, created_at DESC);


--
-- Name: user_events_2026_02_user_id_event_type_created_at_idx; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX user_events_2026_02_user_id_event_type_created_at_idx ON public.user_events_2026_02 USING btree (user_id, event_type, created_at DESC);


--
-- Name: user_events_2025_12_event_type_created_at_idx; Type: INDEX ATTACH; Schema: public; Owner: -
--

ALTER INDEX public.idx_user_events_type ATTACH PARTITION public.user_events_2025_12_event_type_created_at_idx;


--
-- Name: user_events_2025_12_pkey; Type: INDEX ATTACH; Schema: public; Owner: -
--

ALTER INDEX public.user_events_pkey ATTACH PARTITION public.user_events_2025_12_pkey;


--
-- Name: user_events_2025_12_user_id_event_type_created_at_idx; Type: INDEX ATTACH; Schema: public; Owner: -
--

ALTER INDEX public.idx_user_events_user_type ATTACH PARTITION public.user_events_2025_12_user_id_event_type_created_at_idx;


--
-- Name: user_events_2026_01_event_type_created_at_idx; Type: INDEX ATTACH; Schema: public; Owner: -
--

ALTER INDEX public.idx_user_events_type ATTACH PARTITION public.user_events_2026_01_event_type_created_at_idx;


--
-- Name: user_events_2026_01_pkey; Type: INDEX ATTACH; Schema: public; Owner: -
--

ALTER INDEX public.user_events_pkey ATTACH PARTITION public.user_events_2026_01_pkey;


--
-- Name: user_events_2026_01_user_id_event_type_created_at_idx; Type: INDEX ATTACH; Schema: public; Owner: -
--

ALTER INDEX public.idx_user_events_user_type ATTACH PARTITION public.user_events_2026_01_user_id_event_type_created_at_idx;


--
-- Name: user_events_2026_02_event_type_created_at_idx; Type: INDEX ATTACH; Schema: public; Owner: -
--

ALTER INDEX public.idx_user_events_type ATTACH PARTITION public.user_events_2026_02_event_type_created_at_idx;


--
-- Name: user_events_2026_02_pkey; Type: INDEX ATTACH; Schema: public; Owner: -
--

ALTER INDEX public.user_events_pkey ATTACH PARTITION public.user_events_2026_02_pkey;


--
-- Name: user_events_2026_02_user_id_event_type_created_at_idx; Type: INDEX ATTACH; Schema: public; Owner: -
--

ALTER INDEX public.idx_user_events_user_type ATTACH PARTITION public.user_events_2026_02_user_id_event_type_created_at_idx;


--
-- Name: posts AirtableLAFridges; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER "AirtableLAFridges" AFTER INSERT OR UPDATE ON public.posts FOR EACH ROW EXECUTE FUNCTION supabase_functions.http_request('https://api.airtable.com/v0/appxQQHeIXAeUI0wI/Fridges/', 'GET', '{"Content-type":"application/json","Authorization":"Bearer keyzsyWyKuVhC4Q5m"}', '{"Status":"Active"}', '1000');


--
-- Name: rooms N8N Resend Webhook; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER "N8N Resend Webhook" AFTER INSERT OR UPDATE ON public.rooms FOR EACH ROW EXECUTE FUNCTION supabase_functions.http_request('https://n8n.foodshare.club/webhook/resend', 'POST', '{"Content-type":"application/json"}', '{}', '1000');


--
-- Name: app_config app_config_updated_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER app_config_updated_at BEFORE UPDATE ON public.app_config FOR EACH ROW EXECUTE FUNCTION public.update_app_config_updated_at();


--
-- Name: device_tokens audit_device_tokens; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER audit_device_tokens AFTER INSERT OR DELETE ON public.device_tokens FOR EACH ROW EXECUTE FUNCTION audit.log_changes();


--
-- Name: posts audit_post_changes; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER audit_post_changes AFTER INSERT OR DELETE OR UPDATE ON public.posts FOR EACH ROW EXECUTE FUNCTION audit.log_post_change();


--
-- Name: posts audit_posts; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER audit_posts AFTER INSERT OR DELETE OR UPDATE ON public.posts FOR EACH ROW EXECUTE FUNCTION audit.log_changes();


--
-- Name: profiles audit_profiles; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER audit_profiles AFTER DELETE OR UPDATE ON public.profiles FOR EACH ROW EXECUTE FUNCTION audit.log_changes();


--
-- Name: rooms audit_rooms; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER audit_rooms AFTER INSERT OR DELETE OR UPDATE ON public.rooms FOR EACH ROW EXECUTE FUNCTION audit.log_changes();


--
-- Name: forum auto_subscribe_post_author_trigger; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER auto_subscribe_post_author_trigger AFTER INSERT ON public.forum FOR EACH ROW EXECUTE FUNCTION public.auto_subscribe_post_author();


--
-- Name: challenges challenges_translation_trigger; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER challenges_translation_trigger AFTER INSERT OR UPDATE OF challenge_title, challenge_description ON public.challenges FOR EACH ROW WHEN (((new.challenge_title IS NOT NULL) OR (new.challenge_description IS NOT NULL))) EXECUTE FUNCTION public.trigger_translate_challenge();


--
-- Name: forum_user_stats check_badges_on_stats_update; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER check_badges_on_stats_update AFTER UPDATE ON public.forum_user_stats FOR EACH ROW EXECUTE FUNCTION public.trigger_check_badges();


--
-- Name: profiles create_address_on_profile_creation; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER create_address_on_profile_creation AFTER INSERT ON public.profiles FOR EACH ROW EXECUTE FUNCTION public.create_default_address();


--
-- Name: TRIGGER create_address_on_profile_creation ON profiles; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TRIGGER create_address_on_profile_creation ON public.profiles IS 'Automatically creates an empty address record for each new user signup';


--
-- Name: profiles create_email_preferences_on_profile_creation; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER create_email_preferences_on_profile_creation AFTER INSERT ON public.profiles FOR EACH ROW EXECUTE FUNCTION public.create_default_email_preferences();


--
-- Name: device_tokens device_tokens_updated_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER device_tokens_updated_at BEFORE UPDATE ON public.device_tokens FOR EACH ROW EXECUTE FUNCTION public.update_device_tokens_updated_at();


--
-- Name: email_templates email_template_version_on_update; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER email_template_version_on_update BEFORE UPDATE ON public.email_templates FOR EACH ROW EXECUTE FUNCTION public.email_template_version_trigger();


--
-- Name: forum_drafts enforce_max_drafts_trigger; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER enforce_max_drafts_trigger BEFORE INSERT ON public.forum_drafts FOR EACH ROW EXECUTE FUNCTION public.enforce_max_drafts();


--
-- Name: forum forum_post_telegram_notification; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER forum_post_telegram_notification AFTER INSERT ON public.forum FOR EACH ROW EXECUTE FUNCTION public.notify_forum_post_telegram();


--
-- Name: forum forum_translation_trigger; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER forum_translation_trigger AFTER INSERT OR UPDATE OF forum_post_name, forum_post_description ON public.forum FOR EACH ROW WHEN (((new.forum_post_name IS NOT NULL) OR (new.forum_post_description IS NOT NULL))) EXECUTE FUNCTION public.trigger_translate_forum_post();


--
-- Name: forum generate_forum_slug_trigger; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER generate_forum_slug_trigger BEFORE INSERT ON public.forum FOR EACH ROW EXECUTE FUNCTION public.generate_forum_slug();


--
-- Name: comments handle_comment_delete_trigger; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER handle_comment_delete_trigger BEFORE DELETE ON public.comments FOR EACH ROW EXECUTE FUNCTION public.handle_comment_delete();


--
-- Name: comments handle_comment_insert_trigger; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER handle_comment_insert_trigger BEFORE INSERT ON public.comments FOR EACH ROW EXECUTE FUNCTION public.handle_comment_insert();


--
-- Name: posts log_post_changes_delete; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER log_post_changes_delete BEFORE DELETE ON public.posts FOR EACH ROW EXECUTE FUNCTION public.trigger_log_post_changes();


--
-- Name: posts log_post_changes_insert_update; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER log_post_changes_insert_update AFTER INSERT OR UPDATE ON public.posts FOR EACH ROW EXECUTE FUNCTION public.trigger_log_post_changes();


--
-- Name: comments notify_on_forum_comment_trigger; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER notify_on_forum_comment_trigger AFTER INSERT ON public.comments FOR EACH ROW EXECUTE FUNCTION public.notify_on_forum_comment();


--
-- Name: forum_mentions notify_on_forum_mention_trigger; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER notify_on_forum_mention_trigger AFTER INSERT ON public.forum_mentions FOR EACH ROW EXECUTE FUNCTION public.notify_on_forum_mention();


--
-- Name: forum_reactions notify_on_forum_reaction_trigger; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER notify_on_forum_reaction_trigger AFTER INSERT ON public.forum_reactions FOR EACH ROW EXECUTE FUNCTION public.notify_on_forum_reaction();


--
-- Name: forum_reports on_forum_report_created; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER on_forum_report_created AFTER INSERT ON public.forum_reports FOR EACH ROW EXECUTE FUNCTION public.notify_new_report();


--
-- Name: posts on_new_post_notify; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER on_new_post_notify AFTER INSERT ON public.posts FOR EACH ROW EXECUTE FUNCTION public.notify_new_post();


--
-- Name: profiles on_new_user_notify; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER on_new_user_notify AFTER INSERT ON public.profiles FOR EACH ROW EXECUTE FUNCTION public.notify_new_user();


--
-- Name: post_reports on_post_report_created; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER on_post_report_created AFTER INSERT ON public.post_reports FOR EACH ROW EXECUTE FUNCTION public.notify_new_report();


--
-- Name: profiles on_profile_created; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER on_profile_created AFTER INSERT ON public.profiles FOR EACH ROW EXECUTE FUNCTION public.create_profile_stats();


--
-- Name: profiles on_profile_insert_create_stats; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER on_profile_insert_create_stats AFTER INSERT ON public.profiles FOR EACH ROW EXECUTE FUNCTION public.create_profile_stats_on_profile_insert();


--
-- Name: reports on_report_created; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER on_report_created AFTER INSERT ON public.reports FOR EACH ROW EXECUTE FUNCTION public.notify_new_report();


--
-- Name: posts post_address_strip_trigger; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER post_address_strip_trigger BEFORE INSERT OR UPDATE ON public.posts FOR EACH ROW EXECUTE FUNCTION public.strip_address();


--
-- Name: post_reports post_reports_updated_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER post_reports_updated_at BEFORE UPDATE ON public.post_reports FOR EACH ROW EXECUTE FUNCTION public.update_post_reports_updated_at();


--
-- Name: posts posts_activity_log_trigger; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER posts_activity_log_trigger AFTER INSERT OR DELETE OR UPDATE ON public.posts FOR EACH ROW EXECUTE FUNCTION public.trigger_log_post_changes();


--
-- Name: posts posts_translation_trigger; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER posts_translation_trigger AFTER INSERT OR UPDATE OF post_name, post_description ON public.posts FOR EACH ROW WHEN (((new.post_name IS NOT NULL) OR (new.post_description IS NOT NULL))) EXECUTE FUNCTION public.trigger_translate_post();


--
-- Name: posts queue_location_update_trigger; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER queue_location_update_trigger AFTER INSERT OR UPDATE ON public.posts FOR EACH ROW EXECUTE FUNCTION public.queue_location_update();


--
-- Name: comments track_comment_edit_trigger; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER track_comment_edit_trigger BEFORE UPDATE ON public.comments FOR EACH ROW EXECUTE FUNCTION public.track_comment_edit();


--
-- Name: forum track_forum_edit_trigger; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER track_forum_edit_trigger BEFORE UPDATE ON public.forum FOR EACH ROW EXECUTE FUNCTION public.track_forum_edit();


--
-- Name: translations track_translation_changes_trigger; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER track_translation_changes_trigger AFTER UPDATE ON public.translations FOR EACH ROW EXECUTE FUNCTION public.track_translation_changes();


--
-- Name: forum_user_badges trg_forum_badge_activity; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_forum_badge_activity AFTER INSERT ON public.forum_user_badges FOR EACH ROW EXECUTE FUNCTION public.trg_record_badge_activity();


--
-- Name: comments trg_forum_comment_activity; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_forum_comment_activity AFTER INSERT ON public.comments FOR EACH ROW EXECUTE FUNCTION public.trg_record_comment_activity();


--
-- Name: comments trg_forum_comment_reputation; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_forum_comment_reputation AFTER INSERT ON public.comments FOR EACH ROW EXECUTE FUNCTION public.trg_award_comment_reputation();


--
-- Name: forum_user_follows trg_forum_follow_activity; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_forum_follow_activity AFTER INSERT ON public.forum_user_follows FOR EACH ROW EXECUTE FUNCTION public.trg_record_follow_activity();


--
-- Name: likes trg_forum_like_reputation; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_forum_like_reputation AFTER INSERT ON public.likes FOR EACH ROW EXECUTE FUNCTION public.trg_award_like_reputation();


--
-- Name: notifications trg_notifications_sync_version; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_notifications_sync_version BEFORE INSERT OR UPDATE ON public.notifications FOR EACH ROW EXECUTE FUNCTION public.update_sync_version();


--
-- Name: posts trg_posts_sync_version; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_posts_sync_version BEFORE INSERT OR UPDATE ON public.posts FOR EACH ROW EXECUTE FUNCTION public.update_sync_version();


--
-- Name: forum_user_stats trg_recalculate_trust; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_recalculate_trust AFTER UPDATE OF posts_count, comments_count, likes_given, likes_received, topics_read, posts_read, time_spent_minutes ON public.forum_user_stats FOR EACH ROW EXECUTE FUNCTION public.trigger_recalculate_trust_level();


--
-- Name: forum_reports trg_report_to_queue; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_report_to_queue AFTER INSERT ON public.forum_reports FOR EACH ROW EXECUTE FUNCTION public.trg_add_report_to_queue();


--
-- Name: rooms trg_rooms_sync_version; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_rooms_sync_version BEFORE INSERT OR UPDATE ON public.rooms FOR EACH ROW EXECUTE FUNCTION public.update_sync_version();


--
-- Name: forum_announcements trg_update_announcements_timestamp; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_update_announcements_timestamp BEFORE UPDATE ON public.forum_announcements FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();


--
-- Name: forum_comment_reactions trg_update_comment_reactions_count; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_update_comment_reactions_count AFTER INSERT OR DELETE ON public.forum_comment_reactions FOR EACH ROW EXECUTE FUNCTION public.update_comment_reactions_count();


--
-- Name: forum trg_update_hot_score; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_update_hot_score BEFORE INSERT OR UPDATE OF forum_likes_counter, forum_comments_counter, reactions_count, views_count ON public.forum FOR EACH ROW EXECUTE FUNCTION public.update_post_hot_score();


--
-- Name: forum_recurring_posts trg_update_recurring_posts_timestamp; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_update_recurring_posts_timestamp BEFORE UPDATE ON public.forum_recurring_posts FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();


--
-- Name: forum_scheduled_posts trg_update_scheduled_posts_timestamp; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_update_scheduled_posts_timestamp BEFORE UPDATE ON public.forum_scheduled_posts FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();


--
-- Name: forum_series_posts trg_update_series_stats; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_update_series_stats AFTER INSERT OR DELETE OR UPDATE ON public.forum_series_posts FOR EACH ROW EXECUTE FUNCTION public.update_series_stats();


--
-- Name: display_name_overrides trigger_audit_display_name_overrides; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trigger_audit_display_name_overrides AFTER INSERT OR DELETE OR UPDATE ON public.display_name_overrides FOR EACH ROW EXECUTE FUNCTION public.audit_display_name_override_changes();


--
-- Name: device_attestations trigger_device_attestations_updated_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trigger_device_attestations_updated_at BEFORE UPDATE ON public.device_attestations FOR EACH ROW EXECUTE FUNCTION public.update_device_attestations_updated_at();


--
-- Name: display_name_overrides trigger_display_name_override_updated_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trigger_display_name_override_updated_at BEFORE UPDATE ON public.display_name_overrides FOR EACH ROW EXECUTE FUNCTION public.update_display_name_override_updated_at();


--
-- Name: email_delivery_log trigger_email_delivery_log_updated_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trigger_email_delivery_log_updated_at BEFORE UPDATE ON public.email_delivery_log FOR EACH ROW EXECUTE FUNCTION public.update_email_delivery_log_updated_at();


--
-- Name: feature_flags trigger_feature_flags_updated_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trigger_feature_flags_updated_at BEFORE UPDATE ON public.feature_flags FOR EACH ROW EXECUTE FUNCTION public.update_feature_flags_updated_at();


--
-- Name: location_update_queue trigger_location_queue_updated_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trigger_location_queue_updated_at BEFORE UPDATE ON public.location_update_queue FOR EACH ROW EXECUTE FUNCTION public.update_location_queue_updated_at();


--
-- Name: email_queue trigger_move_to_dlq; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trigger_move_to_dlq AFTER UPDATE ON public.email_queue FOR EACH ROW WHEN ((new.status = 'failed'::text)) EXECUTE FUNCTION public.move_failed_email_to_dlq();


--
-- Name: room_participants trigger_notify_new_chat_message; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trigger_notify_new_chat_message AFTER INSERT ON public.room_participants FOR EACH ROW EXECUTE FUNCTION public.notify_new_chat_message();


--
-- Name: feedback trigger_notify_new_feedback; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trigger_notify_new_feedback AFTER INSERT ON public.feedback FOR EACH ROW EXECUTE FUNCTION public.notify_new_feedback();


--
-- Name: rooms trigger_notify_new_interest; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trigger_notify_new_interest AFTER INSERT ON public.rooms FOR EACH ROW WHEN ((new.post_id IS NOT NULL)) EXECUTE FUNCTION public.notify_new_interest();


--
-- Name: room_participants trigger_notify_new_message; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trigger_notify_new_message AFTER INSERT ON public.room_participants FOR EACH ROW EXECUTE FUNCTION public.notify_new_message();


--
-- Name: posts trigger_notify_new_post_on_insert; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trigger_notify_new_post_on_insert AFTER INSERT ON public.posts FOR EACH ROW EXECUTE FUNCTION public.trigger_notify_new_post();


--
-- Name: TRIGGER trigger_notify_new_post_on_insert ON posts; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TRIGGER trigger_notify_new_post_on_insert ON public.posts IS 'Triggers admin notification via Edge Function when posts are inserted';


--
-- Name: reviews trigger_notify_new_review; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trigger_notify_new_review AFTER INSERT ON public.reviews FOR EACH ROW EXECUTE FUNCTION public.notify_new_review();


--
-- Name: rooms trigger_notify_new_room_message; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trigger_notify_new_room_message AFTER UPDATE OF last_message ON public.rooms FOR EACH ROW WHEN (((new.last_message IS DISTINCT FROM old.last_message) AND (new.last_message IS NOT NULL))) EXECUTE FUNCTION public.notify_new_room_message();


--
-- Name: posts trigger_notify_post_arranged; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trigger_notify_post_arranged AFTER UPDATE OF is_arranged ON public.posts FOR EACH ROW WHEN (((new.is_arranged = true) AND (old.is_arranged = false))) EXECUTE FUNCTION public.notify_post_arranged();


--
-- Name: reviews trigger_notify_review_received; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trigger_notify_review_received AFTER INSERT ON public.reviews FOR EACH ROW EXECUTE FUNCTION public.notify_review_received();


--
-- Name: blocked_users trigger_notify_user_blocked; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trigger_notify_user_blocked AFTER INSERT ON public.blocked_users FOR EACH ROW EXECUTE FUNCTION public.notify_user_blocked();


--
-- Name: email_queue trigger_process_email_queue; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trigger_process_email_queue AFTER INSERT ON public.email_queue FOR EACH ROW EXECUTE FUNCTION public.on_email_queued();


--
-- Name: posts trigger_queue_location_update; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trigger_queue_location_update BEFORE INSERT OR UPDATE OF post_address ON public.posts FOR EACH ROW EXECUTE FUNCTION public.queue_location_update();


--
-- Name: TRIGGER trigger_queue_location_update ON posts; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TRIGGER trigger_queue_location_update ON public.posts IS 'Automatically queues posts for geocoding when created or address changes';


--
-- Name: moderation_queue trigger_update_moderation_queue_updated_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trigger_update_moderation_queue_updated_at BEFORE UPDATE ON public.moderation_queue FOR EACH ROW EXECUTE FUNCTION public.update_moderation_queue_updated_at();


--
-- Name: forum update_category_count_trigger; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER update_category_count_trigger AFTER INSERT OR DELETE OR UPDATE OF category_id ON public.forum FOR EACH ROW EXECUTE FUNCTION public.update_category_posts_count();


--
-- Name: email_preferences update_email_preferences_timestamp; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER update_email_preferences_timestamp BEFORE UPDATE ON public.email_preferences FOR EACH ROW EXECUTE FUNCTION public.update_email_preferences_updated_at();


--
-- Name: email_provider_quota update_email_provider_quota_timestamp; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER update_email_provider_quota_timestamp BEFORE UPDATE ON public.email_provider_quota FOR EACH ROW EXECUTE FUNCTION public.update_email_provider_quota_updated_at();


--
-- Name: email_queue update_email_queue_timestamp; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER update_email_queue_timestamp BEFORE UPDATE ON public.email_queue FOR EACH ROW EXECUTE FUNCTION public.update_email_queue_updated_at();


--
-- Name: email_templates update_email_templates_updated_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER update_email_templates_updated_at BEFORE UPDATE ON public.email_templates FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();


--
-- Name: feedback update_feedback_timestamp; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER update_feedback_timestamp BEFORE UPDATE ON public.feedback FOR EACH ROW EXECUTE FUNCTION public.update_feedback_updated_at();


--
-- Name: forum_user_follows update_follow_counts_trigger; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER update_follow_counts_trigger AFTER INSERT OR DELETE ON public.forum_user_follows FOR EACH ROW EXECUTE FUNCTION public.update_follow_counts();


--
-- Name: comments update_forum_activity_on_comment; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER update_forum_activity_on_comment AFTER INSERT ON public.comments FOR EACH ROW WHEN ((new.forum_id IS NOT NULL)) EXECUTE FUNCTION public.update_forum_last_activity();


--
-- Name: forum_categories update_forum_categories_updated_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER update_forum_categories_updated_at BEFORE UPDATE ON public.forum_categories FOR EACH ROW EXECUTE FUNCTION public.update_feedback_updated_at();


--
-- Name: forum_reactions update_forum_reactions_count_trigger; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER update_forum_reactions_count_trigger AFTER INSERT OR DELETE ON public.forum_reactions FOR EACH ROW EXECUTE FUNCTION public.update_forum_reactions_count();


--
-- Name: forum update_forum_search_trigger; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER update_forum_search_trigger BEFORE INSERT OR UPDATE OF forum_post_name, forum_post_description ON public.forum FOR EACH ROW EXECUTE FUNCTION public.update_forum_search_vector();


--
-- Name: notification_delivery_log update_notification_delivery_log_updated_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER update_notification_delivery_log_updated_at BEFORE UPDATE ON public.notification_delivery_log FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();


--
-- Name: notification_queue update_notification_queue_updated_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER update_notification_queue_updated_at BEFORE UPDATE ON public.notification_queue FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();


--
-- Name: forum_reports update_report_counts_trigger; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER update_report_counts_trigger AFTER INSERT ON public.forum_reports FOR EACH ROW EXECUTE FUNCTION public.update_report_counts();


--
-- Name: forum_reports update_report_timestamp_trigger; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER update_report_timestamp_trigger BEFORE UPDATE ON public.forum_reports FOR EACH ROW EXECUTE FUNCTION public.update_report_timestamp();


--
-- Name: forum_post_tags update_tag_usage_on_delete; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER update_tag_usage_on_delete AFTER DELETE ON public.forum_post_tags FOR EACH ROW EXECUTE FUNCTION public.update_tag_usage_count();


--
-- Name: forum_post_tags update_tag_usage_on_insert; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER update_tag_usage_on_insert AFTER INSERT ON public.forum_post_tags FOR EACH ROW EXECUTE FUNCTION public.update_tag_usage_count();


--
-- Name: translations update_translations_updated_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER update_translations_updated_at BEFORE UPDATE ON public.translations FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();


--
-- Name: user_addresses update_user_addresses_updated_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER update_user_addresses_updated_at BEFORE UPDATE ON public.user_addresses FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();


--
-- Name: user_locale_preferences update_user_locale_updated_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER update_user_locale_updated_at BEFORE UPDATE ON public.user_locale_preferences FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();


--
-- Name: comments update_user_stats_on_comment_trigger; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER update_user_stats_on_comment_trigger AFTER INSERT OR DELETE ON public.comments FOR EACH ROW EXECUTE FUNCTION public.update_user_stats_on_comment();


--
-- Name: forum_reactions update_user_stats_on_reaction_trigger; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER update_user_stats_on_reaction_trigger AFTER INSERT OR DELETE ON public.forum_reactions FOR EACH ROW EXECUTE FUNCTION public.update_user_stats_on_reaction();


--
-- Name: user_notifications user_notifications_updated_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER user_notifications_updated_at BEFORE UPDATE ON public.user_notifications FOR EACH ROW EXECUTE FUNCTION public.update_user_notifications_updated_at();


--
-- Name: address address_country_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.address
    ADD CONSTRAINT address_country_id_fkey FOREIGN KEY (country_id) REFERENCES public.countries(id) ON DELETE CASCADE;


--
-- Name: admin_audit_log admin_audit_log_admin_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.admin_audit_log
    ADD CONSTRAINT admin_audit_log_admin_id_fkey FOREIGN KEY (admin_id) REFERENCES public.profiles(id);


--
-- Name: api_analytics api_analytics_user_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.api_analytics
    ADD CONSTRAINT api_analytics_user_id_fkey FOREIGN KEY (user_id) REFERENCES public.profiles(id) ON DELETE SET NULL;


--
-- Name: audience_segments audience_segments_created_by_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.audience_segments
    ADD CONSTRAINT audience_segments_created_by_fkey FOREIGN KEY (created_by) REFERENCES public.profiles(id);


--
-- Name: audit_logs audit_logs_user_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.audit_logs
    ADD CONSTRAINT audit_logs_user_id_fkey FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE SET NULL;


--
-- Name: automation_enrollments automation_enrollments_flow_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.automation_enrollments
    ADD CONSTRAINT automation_enrollments_flow_id_fkey FOREIGN KEY (flow_id) REFERENCES public.email_automation_flows(id) ON DELETE CASCADE;


--
-- Name: automation_enrollments automation_enrollments_profile_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.automation_enrollments
    ADD CONSTRAINT automation_enrollments_profile_id_fkey FOREIGN KEY (profile_id) REFERENCES public.profiles(id);


--
-- Name: blocked_users blocked_users_blocked_user_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.blocked_users
    ADD CONSTRAINT blocked_users_blocked_user_id_fkey FOREIGN KEY (blocked_user_id) REFERENCES auth.users(id) ON DELETE CASCADE;


--
-- Name: blocked_users blocked_users_user_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.blocked_users
    ADD CONSTRAINT blocked_users_user_id_fkey FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE CASCADE;


--
-- Name: bookmarks bookmarks_profile_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.bookmarks
    ADD CONSTRAINT bookmarks_profile_id_fkey FOREIGN KEY (profile_id) REFERENCES public.profiles(id) ON DELETE CASCADE;


--
-- Name: campaign_recipients campaign_recipients_campaign_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.campaign_recipients
    ADD CONSTRAINT campaign_recipients_campaign_id_fkey FOREIGN KEY (campaign_id) REFERENCES public.newsletter_campaigns(id) ON DELETE CASCADE;


--
-- Name: campaign_recipients campaign_recipients_profile_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.campaign_recipients
    ADD CONSTRAINT campaign_recipients_profile_id_fkey FOREIGN KEY (profile_id) REFERENCES public.profiles(id);


--
-- Name: campaign_recipients campaign_recipients_subscriber_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.campaign_recipients
    ADD CONSTRAINT campaign_recipients_subscriber_id_fkey FOREIGN KEY (subscriber_id) REFERENCES public.newsletter_subscribers(id);


--
-- Name: challenge_activities challenge_activities_challenge_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.challenge_activities
    ADD CONSTRAINT challenge_activities_challenge_id_fkey FOREIGN KEY (challenge_id) REFERENCES public.challenges(id) ON DELETE CASCADE;


--
-- Name: challenge_activities challenge_activities_user_accepted_challenge_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.challenge_activities
    ADD CONSTRAINT challenge_activities_user_accepted_challenge_fkey FOREIGN KEY (user_accepted_challenge) REFERENCES auth.users(id) ON DELETE CASCADE;


--
-- Name: challenge_activities challenge_activities_user_completed_challenge_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.challenge_activities
    ADD CONSTRAINT challenge_activities_user_completed_challenge_fkey FOREIGN KEY (user_completed_challenge) REFERENCES auth.users(id) ON DELETE CASCADE;


--
-- Name: challenge_activities challenge_activities_user_rejected_challenge_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.challenge_activities
    ADD CONSTRAINT challenge_activities_user_rejected_challenge_fkey FOREIGN KEY (user_rejected_challenge) REFERENCES auth.users(id) ON DELETE CASCADE;


--
-- Name: challenge_participants challenge_participants_challenge_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.challenge_participants
    ADD CONSTRAINT challenge_participants_challenge_id_fkey FOREIGN KEY (challenge_id) REFERENCES public.challenges(id) ON DELETE CASCADE;


--
-- Name: challenge_participants challenge_participants_profile_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.challenge_participants
    ADD CONSTRAINT challenge_participants_profile_id_fkey FOREIGN KEY (profile_id) REFERENCES auth.users(id) ON DELETE CASCADE;


--
-- Name: challenges challenges_profile_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.challenges
    ADD CONSTRAINT challenges_profile_id_fkey FOREIGN KEY (profile_id) REFERENCES auth.users(id) ON DELETE CASCADE;


--
-- Name: comments comments_forum_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.comments
    ADD CONSTRAINT comments_forum_id_fkey FOREIGN KEY (forum_id) REFERENCES public.forum(id) ON DELETE CASCADE;


--
-- Name: comments comments_parent_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.comments
    ADD CONSTRAINT comments_parent_id_fkey FOREIGN KEY (parent_id) REFERENCES public.comments(id) ON DELETE CASCADE;


--
-- Name: comments comments_user_id_profiles_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.comments
    ADD CONSTRAINT comments_user_id_profiles_fkey FOREIGN KEY (user_id) REFERENCES public.profiles(id) ON DELETE CASCADE;


--
-- Name: crm_customer_notes crm_customer_notes_admin_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.crm_customer_notes
    ADD CONSTRAINT crm_customer_notes_admin_id_fkey FOREIGN KEY (admin_id) REFERENCES public.profiles(id);


--
-- Name: crm_customer_notes crm_customer_notes_customer_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.crm_customer_notes
    ADD CONSTRAINT crm_customer_notes_customer_id_fkey FOREIGN KEY (customer_id) REFERENCES public.crm_customers(id) ON DELETE CASCADE;


--
-- Name: crm_customer_tag_assignments crm_customer_tag_assignments_customer_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.crm_customer_tag_assignments
    ADD CONSTRAINT crm_customer_tag_assignments_customer_id_fkey FOREIGN KEY (customer_id) REFERENCES public.crm_customers(id) ON DELETE CASCADE;


--
-- Name: crm_customer_tag_assignments crm_customer_tag_assignments_tag_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.crm_customer_tag_assignments
    ADD CONSTRAINT crm_customer_tag_assignments_tag_id_fkey FOREIGN KEY (tag_id) REFERENCES public.crm_customer_tags(id) ON DELETE CASCADE;


--
-- Name: crm_customers crm_customers_profile_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.crm_customers
    ADD CONSTRAINT crm_customers_profile_id_fkey FOREIGN KEY (profile_id) REFERENCES public.profiles(id) ON DELETE CASCADE;


--
-- Name: device_attestations device_attestations_user_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.device_attestations
    ADD CONSTRAINT device_attestations_user_id_fkey FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE SET NULL;


--
-- Name: device_tokens device_tokens_profile_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.device_tokens
    ADD CONSTRAINT device_tokens_profile_id_fkey FOREIGN KEY (profile_id) REFERENCES public.profiles(id) ON DELETE CASCADE;


--
-- Name: display_name_overrides display_name_overrides_overridden_by_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.display_name_overrides
    ADD CONSTRAINT display_name_overrides_overridden_by_fkey FOREIGN KEY (overridden_by) REFERENCES public.profiles(id) ON DELETE SET NULL;


--
-- Name: display_name_overrides display_name_overrides_user_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.display_name_overrides
    ADD CONSTRAINT display_name_overrides_user_id_fkey FOREIGN KEY (user_id) REFERENCES public.profiles(id) ON DELETE CASCADE;


--
-- Name: email_audit_log email_audit_log_target_user_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.email_audit_log
    ADD CONSTRAINT email_audit_log_target_user_id_fkey FOREIGN KEY (target_user_id) REFERENCES auth.users(id) ON DELETE SET NULL;


--
-- Name: email_audit_log email_audit_log_user_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.email_audit_log
    ADD CONSTRAINT email_audit_log_user_id_fkey FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE SET NULL;


--
-- Name: email_automation_flows email_automation_flows_created_by_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.email_automation_flows
    ADD CONSTRAINT email_automation_flows_created_by_fkey FOREIGN KEY (created_by) REFERENCES public.profiles(id);


--
-- Name: email_automation_queue email_automation_queue_enrollment_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.email_automation_queue
    ADD CONSTRAINT email_automation_queue_enrollment_id_fkey FOREIGN KEY (enrollment_id) REFERENCES public.automation_enrollments(id) ON DELETE CASCADE;


--
-- Name: email_automation_queue email_automation_queue_flow_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.email_automation_queue
    ADD CONSTRAINT email_automation_queue_flow_id_fkey FOREIGN KEY (flow_id) REFERENCES public.email_automation_flows(id) ON DELETE CASCADE;


--
-- Name: email_automation_queue email_automation_queue_profile_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.email_automation_queue
    ADD CONSTRAINT email_automation_queue_profile_id_fkey FOREIGN KEY (profile_id) REFERENCES public.profiles(id) ON DELETE CASCADE;


--
-- Name: email_circuit_breaker_state email_circuit_breaker_state_organization_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.email_circuit_breaker_state
    ADD CONSTRAINT email_circuit_breaker_state_organization_id_fkey FOREIGN KEY (organization_id) REFERENCES public.organizations(id);


--
-- Name: email_dead_letter_queue email_dead_letter_queue_recipient_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.email_dead_letter_queue
    ADD CONSTRAINT email_dead_letter_queue_recipient_id_fkey FOREIGN KEY (recipient_id) REFERENCES public.profiles(id) ON DELETE SET NULL;


--
-- Name: email_delivery_log email_delivery_log_campaign_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.email_delivery_log
    ADD CONSTRAINT email_delivery_log_campaign_id_fkey FOREIGN KEY (campaign_id) REFERENCES public.newsletter_campaigns(id) ON DELETE SET NULL;


--
-- Name: email_delivery_log email_delivery_log_user_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.email_delivery_log
    ADD CONSTRAINT email_delivery_log_user_id_fkey FOREIGN KEY (user_id) REFERENCES public.profiles(id) ON DELETE CASCADE;


--
-- Name: email_logs email_logs_recipient_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.email_logs
    ADD CONSTRAINT email_logs_recipient_id_fkey FOREIGN KEY (recipient_id) REFERENCES public.profiles(id) ON DELETE SET NULL;


--
-- Name: email_preferences email_preferences_profile_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.email_preferences
    ADD CONSTRAINT email_preferences_profile_id_fkey FOREIGN KEY (profile_id) REFERENCES public.profiles(id) ON DELETE CASCADE;


--
-- Name: email_provider_monthly_quota email_provider_monthly_quota_organization_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.email_provider_monthly_quota
    ADD CONSTRAINT email_provider_monthly_quota_organization_id_fkey FOREIGN KEY (organization_id) REFERENCES public.organizations(id);


--
-- Name: email_provider_quota email_provider_quota_organization_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.email_provider_quota
    ADD CONSTRAINT email_provider_quota_organization_id_fkey FOREIGN KEY (organization_id) REFERENCES public.organizations(id);


--
-- Name: email_queue email_queue_recipient_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.email_queue
    ADD CONSTRAINT email_queue_recipient_id_fkey FOREIGN KEY (recipient_id) REFERENCES public.profiles(id) ON DELETE SET NULL;


--
-- Name: email_template_versions email_template_versions_changed_by_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.email_template_versions
    ADD CONSTRAINT email_template_versions_changed_by_fkey FOREIGN KEY (changed_by) REFERENCES auth.users(id);


--
-- Name: email_template_versions email_template_versions_template_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.email_template_versions
    ADD CONSTRAINT email_template_versions_template_id_fkey FOREIGN KEY (template_id) REFERENCES public.email_templates(id) ON DELETE CASCADE;


--
-- Name: email_templates email_templates_created_by_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.email_templates
    ADD CONSTRAINT email_templates_created_by_fkey FOREIGN KEY (created_by) REFERENCES public.profiles(id);


--
-- Name: email_templates email_templates_updated_by_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.email_templates
    ADD CONSTRAINT email_templates_updated_by_fkey FOREIGN KEY (updated_by) REFERENCES auth.users(id);


--
-- Name: experiment_assignments experiment_assignments_experiment_key_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.experiment_assignments
    ADD CONSTRAINT experiment_assignments_experiment_key_fkey FOREIGN KEY (experiment_key) REFERENCES public.experiments(key) ON DELETE CASCADE;


--
-- Name: experiment_assignments experiment_assignments_user_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.experiment_assignments
    ADD CONSTRAINT experiment_assignments_user_id_fkey FOREIGN KEY (user_id) REFERENCES public.profiles(id) ON DELETE CASCADE;


--
-- Name: feature_flag_overrides feature_flag_overrides_user_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.feature_flag_overrides
    ADD CONSTRAINT feature_flag_overrides_user_id_fkey FOREIGN KEY (user_id) REFERENCES public.profiles(id) ON DELETE CASCADE;


--
-- Name: feature_flags feature_flags_created_by_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.feature_flags
    ADD CONSTRAINT feature_flags_created_by_fkey FOREIGN KEY (created_by) REFERENCES auth.users(id);


--
-- Name: feedback feedback_profile_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.feedback
    ADD CONSTRAINT feedback_profile_id_fkey FOREIGN KEY (profile_id) REFERENCES public.profiles(id) ON DELETE SET NULL;


--
-- Name: address fk_address_profiles; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.address
    ADD CONSTRAINT fk_address_profiles FOREIGN KEY (profile_id) REFERENCES public.profiles(id);


--
-- Name: views fk_views_post_id; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.views
    ADD CONSTRAINT fk_views_post_id FOREIGN KEY (post_id) REFERENCES public.posts(id) ON DELETE SET NULL;


--
-- Name: views fk_views_profile_id; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.views
    ADD CONSTRAINT fk_views_profile_id FOREIGN KEY (profile_id) REFERENCES public.profiles(id);


--
-- Name: forum_activities forum_activities_profile_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.forum_activities
    ADD CONSTRAINT forum_activities_profile_id_fkey FOREIGN KEY (profile_id) REFERENCES public.profiles(id) ON DELETE CASCADE;


--
-- Name: forum_activities forum_activities_target_badge_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.forum_activities
    ADD CONSTRAINT forum_activities_target_badge_id_fkey FOREIGN KEY (target_badge_id) REFERENCES public.forum_badges(id) ON DELETE SET NULL;


--
-- Name: forum_activities forum_activities_target_comment_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.forum_activities
    ADD CONSTRAINT forum_activities_target_comment_id_fkey FOREIGN KEY (target_comment_id) REFERENCES public.comments(id) ON DELETE CASCADE;


--
-- Name: forum_activities forum_activities_target_forum_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.forum_activities
    ADD CONSTRAINT forum_activities_target_forum_id_fkey FOREIGN KEY (target_forum_id) REFERENCES public.forum(id) ON DELETE CASCADE;


--
-- Name: forum_activities forum_activities_target_profile_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.forum_activities
    ADD CONSTRAINT forum_activities_target_profile_id_fkey FOREIGN KEY (target_profile_id) REFERENCES public.profiles(id) ON DELETE CASCADE;


--
-- Name: forum_activities forum_activities_target_series_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.forum_activities
    ADD CONSTRAINT forum_activities_target_series_id_fkey FOREIGN KEY (target_series_id) REFERENCES public.forum_series(id) ON DELETE CASCADE;


--
-- Name: forum_announcement_analytics forum_announcement_analytics_announcement_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.forum_announcement_analytics
    ADD CONSTRAINT forum_announcement_analytics_announcement_id_fkey FOREIGN KEY (announcement_id) REFERENCES public.forum_announcements(id) ON DELETE CASCADE;


--
-- Name: forum_announcement_analytics forum_announcement_analytics_profile_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.forum_announcement_analytics
    ADD CONSTRAINT forum_announcement_analytics_profile_id_fkey FOREIGN KEY (profile_id) REFERENCES public.profiles(id) ON DELETE SET NULL;


--
-- Name: forum_announcement_dismissals forum_announcement_dismissals_announcement_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.forum_announcement_dismissals
    ADD CONSTRAINT forum_announcement_dismissals_announcement_id_fkey FOREIGN KEY (announcement_id) REFERENCES public.forum_announcements(id) ON DELETE CASCADE;


--
-- Name: forum_announcement_dismissals forum_announcement_dismissals_profile_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.forum_announcement_dismissals
    ADD CONSTRAINT forum_announcement_dismissals_profile_id_fkey FOREIGN KEY (profile_id) REFERENCES public.profiles(id) ON DELETE CASCADE;


--
-- Name: forum_announcements forum_announcements_created_by_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.forum_announcements
    ADD CONSTRAINT forum_announcements_created_by_fkey FOREIGN KEY (created_by) REFERENCES public.profiles(id) ON DELETE SET NULL;


--
-- Name: forum_announcements forum_announcements_target_category_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.forum_announcements
    ADD CONSTRAINT forum_announcements_target_category_id_fkey FOREIGN KEY (target_category_id) REFERENCES public.forum_categories(id) ON DELETE CASCADE;


--
-- Name: forum_announcements forum_announcements_updated_by_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.forum_announcements
    ADD CONSTRAINT forum_announcements_updated_by_fkey FOREIGN KEY (updated_by) REFERENCES public.profiles(id) ON DELETE SET NULL;


--
-- Name: forum_author_analytics forum_author_analytics_profile_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.forum_author_analytics
    ADD CONSTRAINT forum_author_analytics_profile_id_fkey FOREIGN KEY (profile_id) REFERENCES public.profiles(id) ON DELETE CASCADE;


--
-- Name: forum_author_analytics forum_author_analytics_top_post_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.forum_author_analytics
    ADD CONSTRAINT forum_author_analytics_top_post_id_fkey FOREIGN KEY (top_post_id) REFERENCES public.forum(id) ON DELETE SET NULL;


--
-- Name: forum forum_best_answer_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.forum
    ADD CONSTRAINT forum_best_answer_id_fkey FOREIGN KEY (best_answer_id) REFERENCES public.comments(id) ON DELETE SET NULL;


--
-- Name: forum_bookmark_collections forum_bookmark_collections_profile_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.forum_bookmark_collections
    ADD CONSTRAINT forum_bookmark_collections_profile_id_fkey FOREIGN KEY (profile_id) REFERENCES public.profiles(id) ON DELETE CASCADE;


--
-- Name: forum forum_category_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.forum
    ADD CONSTRAINT forum_category_id_fkey FOREIGN KEY (category_id) REFERENCES public.forum_categories(id) ON DELETE SET NULL;


--
-- Name: forum_comment_history forum_comment_history_comment_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.forum_comment_history
    ADD CONSTRAINT forum_comment_history_comment_id_fkey FOREIGN KEY (comment_id) REFERENCES public.comments(id) ON DELETE CASCADE;


--
-- Name: forum_comment_history forum_comment_history_editor_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.forum_comment_history
    ADD CONSTRAINT forum_comment_history_editor_id_fkey FOREIGN KEY (editor_id) REFERENCES public.profiles(id) ON DELETE SET NULL;


--
-- Name: forum_comment_reactions forum_comment_reactions_comment_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.forum_comment_reactions
    ADD CONSTRAINT forum_comment_reactions_comment_id_fkey FOREIGN KEY (comment_id) REFERENCES public.comments(id) ON DELETE CASCADE;


--
-- Name: forum_comment_reactions forum_comment_reactions_profile_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.forum_comment_reactions
    ADD CONSTRAINT forum_comment_reactions_profile_id_fkey FOREIGN KEY (profile_id) REFERENCES public.profiles(id) ON DELETE CASCADE;


--
-- Name: forum_comment_reactions forum_comment_reactions_reaction_type_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.forum_comment_reactions
    ADD CONSTRAINT forum_comment_reactions_reaction_type_id_fkey FOREIGN KEY (reaction_type_id) REFERENCES public.reaction_types(id) ON DELETE CASCADE;


--
-- Name: forum_content_experiments forum_content_experiments_forum_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.forum_content_experiments
    ADD CONSTRAINT forum_content_experiments_forum_id_fkey FOREIGN KEY (forum_id) REFERENCES public.forum(id) ON DELETE CASCADE;


--
-- Name: forum_conversation_participants forum_conversation_participants_conversation_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.forum_conversation_participants
    ADD CONSTRAINT forum_conversation_participants_conversation_id_fkey FOREIGN KEY (conversation_id) REFERENCES public.forum_conversations(id) ON DELETE CASCADE;


--
-- Name: forum_conversation_participants forum_conversation_participants_profile_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.forum_conversation_participants
    ADD CONSTRAINT forum_conversation_participants_profile_id_fkey FOREIGN KEY (profile_id) REFERENCES public.profiles(id) ON DELETE CASCADE;


--
-- Name: forum_conversations forum_conversations_created_by_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.forum_conversations
    ADD CONSTRAINT forum_conversations_created_by_fkey FOREIGN KEY (created_by) REFERENCES public.profiles(id) ON DELETE SET NULL;


--
-- Name: forum_drafts forum_drafts_category_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.forum_drafts
    ADD CONSTRAINT forum_drafts_category_id_fkey FOREIGN KEY (category_id) REFERENCES public.forum_categories(id) ON DELETE SET NULL;


--
-- Name: forum_drafts forum_drafts_profile_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.forum_drafts
    ADD CONSTRAINT forum_drafts_profile_id_fkey FOREIGN KEY (profile_id) REFERENCES public.profiles(id) ON DELETE CASCADE;


--
-- Name: forum forum_featured_by_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.forum
    ADD CONSTRAINT forum_featured_by_fkey FOREIGN KEY (featured_by) REFERENCES public.profiles(id);


--
-- Name: forum_feed_preferences forum_feed_preferences_profile_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.forum_feed_preferences
    ADD CONSTRAINT forum_feed_preferences_profile_id_fkey FOREIGN KEY (profile_id) REFERENCES public.profiles(id) ON DELETE CASCADE;


--
-- Name: forum_feed_read_status forum_feed_read_status_activity_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.forum_feed_read_status
    ADD CONSTRAINT forum_feed_read_status_activity_id_fkey FOREIGN KEY (activity_id) REFERENCES public.forum_activities(id) ON DELETE CASCADE;


--
-- Name: forum_feed_read_status forum_feed_read_status_profile_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.forum_feed_read_status
    ADD CONSTRAINT forum_feed_read_status_profile_id_fkey FOREIGN KEY (profile_id) REFERENCES public.profiles(id) ON DELETE CASCADE;


--
-- Name: forum_mentions forum_mentions_comment_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.forum_mentions
    ADD CONSTRAINT forum_mentions_comment_id_fkey FOREIGN KEY (comment_id) REFERENCES public.comments(id) ON DELETE CASCADE;


--
-- Name: forum_mentions forum_mentions_forum_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.forum_mentions
    ADD CONSTRAINT forum_mentions_forum_id_fkey FOREIGN KEY (forum_id) REFERENCES public.forum(id) ON DELETE CASCADE;


--
-- Name: forum_mentions forum_mentions_mentioned_profile_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.forum_mentions
    ADD CONSTRAINT forum_mentions_mentioned_profile_id_fkey FOREIGN KEY (mentioned_profile_id) REFERENCES public.profiles(id) ON DELETE CASCADE;


--
-- Name: forum_mentions forum_mentions_mentioner_profile_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.forum_mentions
    ADD CONSTRAINT forum_mentions_mentioner_profile_id_fkey FOREIGN KEY (mentioner_profile_id) REFERENCES public.profiles(id) ON DELETE CASCADE;


--
-- Name: forum_message_reactions forum_message_reactions_message_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.forum_message_reactions
    ADD CONSTRAINT forum_message_reactions_message_id_fkey FOREIGN KEY (message_id) REFERENCES public.forum_messages(id) ON DELETE CASCADE;


--
-- Name: forum_message_reactions forum_message_reactions_profile_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.forum_message_reactions
    ADD CONSTRAINT forum_message_reactions_profile_id_fkey FOREIGN KEY (profile_id) REFERENCES public.profiles(id) ON DELETE CASCADE;


--
-- Name: forum_message_reactions forum_message_reactions_reaction_type_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.forum_message_reactions
    ADD CONSTRAINT forum_message_reactions_reaction_type_id_fkey FOREIGN KEY (reaction_type_id) REFERENCES public.reaction_types(id) ON DELETE CASCADE;


--
-- Name: forum_message_read_receipts forum_message_read_receipts_message_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.forum_message_read_receipts
    ADD CONSTRAINT forum_message_read_receipts_message_id_fkey FOREIGN KEY (message_id) REFERENCES public.forum_messages(id) ON DELETE CASCADE;


--
-- Name: forum_message_read_receipts forum_message_read_receipts_profile_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.forum_message_read_receipts
    ADD CONSTRAINT forum_message_read_receipts_profile_id_fkey FOREIGN KEY (profile_id) REFERENCES public.profiles(id) ON DELETE CASCADE;


--
-- Name: forum_messages forum_messages_conversation_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.forum_messages
    ADD CONSTRAINT forum_messages_conversation_id_fkey FOREIGN KEY (conversation_id) REFERENCES public.forum_conversations(id) ON DELETE CASCADE;


--
-- Name: forum_messages forum_messages_reply_to_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.forum_messages
    ADD CONSTRAINT forum_messages_reply_to_id_fkey FOREIGN KEY (reply_to_id) REFERENCES public.forum_messages(id) ON DELETE SET NULL;


--
-- Name: forum_messages forum_messages_sender_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.forum_messages
    ADD CONSTRAINT forum_messages_sender_id_fkey FOREIGN KEY (sender_id) REFERENCES public.profiles(id) ON DELETE SET NULL;


--
-- Name: forum_moderation_notes forum_moderation_notes_moderator_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.forum_moderation_notes
    ADD CONSTRAINT forum_moderation_notes_moderator_id_fkey FOREIGN KEY (moderator_id) REFERENCES public.profiles(id) ON DELETE CASCADE;


--
-- Name: forum_moderation_notes forum_moderation_notes_queue_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.forum_moderation_notes
    ADD CONSTRAINT forum_moderation_notes_queue_id_fkey FOREIGN KEY (queue_id) REFERENCES public.forum_moderation_queue(id) ON DELETE CASCADE;


--
-- Name: forum_moderation_queue forum_moderation_queue_assigned_to_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.forum_moderation_queue
    ADD CONSTRAINT forum_moderation_queue_assigned_to_fkey FOREIGN KEY (assigned_to) REFERENCES public.profiles(id) ON DELETE SET NULL;


--
-- Name: forum_moderation_queue forum_moderation_queue_comment_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.forum_moderation_queue
    ADD CONSTRAINT forum_moderation_queue_comment_id_fkey FOREIGN KEY (comment_id) REFERENCES public.comments(id) ON DELETE CASCADE;


--
-- Name: forum_moderation_queue forum_moderation_queue_forum_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.forum_moderation_queue
    ADD CONSTRAINT forum_moderation_queue_forum_id_fkey FOREIGN KEY (forum_id) REFERENCES public.forum(id) ON DELETE CASCADE;


--
-- Name: forum_moderation_queue forum_moderation_queue_message_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.forum_moderation_queue
    ADD CONSTRAINT forum_moderation_queue_message_id_fkey FOREIGN KEY (message_id) REFERENCES public.forum_messages(id) ON DELETE CASCADE;


--
-- Name: forum_moderation_queue forum_moderation_queue_profile_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.forum_moderation_queue
    ADD CONSTRAINT forum_moderation_queue_profile_id_fkey FOREIGN KEY (profile_id) REFERENCES public.profiles(id) ON DELETE CASCADE;


--
-- Name: forum_moderation_queue forum_moderation_queue_report_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.forum_moderation_queue
    ADD CONSTRAINT forum_moderation_queue_report_id_fkey FOREIGN KEY (report_id) REFERENCES public.forum_reports(id) ON DELETE SET NULL;


--
-- Name: forum_moderation_queue forum_moderation_queue_reporter_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.forum_moderation_queue
    ADD CONSTRAINT forum_moderation_queue_reporter_id_fkey FOREIGN KEY (reporter_id) REFERENCES public.profiles(id) ON DELETE SET NULL;


--
-- Name: forum_moderation_queue forum_moderation_queue_resolved_by_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.forum_moderation_queue
    ADD CONSTRAINT forum_moderation_queue_resolved_by_fkey FOREIGN KEY (resolved_by) REFERENCES public.profiles(id) ON DELETE SET NULL;


--
-- Name: forum_moderation_stats forum_moderation_stats_moderator_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.forum_moderation_stats
    ADD CONSTRAINT forum_moderation_stats_moderator_id_fkey FOREIGN KEY (moderator_id) REFERENCES public.profiles(id) ON DELETE CASCADE;


--
-- Name: forum_moderator_logs forum_moderator_logs_moderator_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.forum_moderator_logs
    ADD CONSTRAINT forum_moderator_logs_moderator_id_fkey FOREIGN KEY (moderator_id) REFERENCES public.profiles(id) ON DELETE SET NULL;


--
-- Name: forum_moderator_logs forum_moderator_logs_target_profile_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.forum_moderator_logs
    ADD CONSTRAINT forum_moderator_logs_target_profile_id_fkey FOREIGN KEY (target_profile_id) REFERENCES public.profiles(id) ON DELETE SET NULL;


--
-- Name: forum_notifications forum_notifications_actor_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.forum_notifications
    ADD CONSTRAINT forum_notifications_actor_id_fkey FOREIGN KEY (actor_id) REFERENCES public.profiles(id) ON DELETE SET NULL;


--
-- Name: forum_notifications forum_notifications_comment_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.forum_notifications
    ADD CONSTRAINT forum_notifications_comment_id_fkey FOREIGN KEY (comment_id) REFERENCES public.comments(id) ON DELETE CASCADE;


--
-- Name: forum_notifications forum_notifications_forum_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.forum_notifications
    ADD CONSTRAINT forum_notifications_forum_id_fkey FOREIGN KEY (forum_id) REFERENCES public.forum(id) ON DELETE CASCADE;


--
-- Name: forum_notifications forum_notifications_recipient_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.forum_notifications
    ADD CONSTRAINT forum_notifications_recipient_id_fkey FOREIGN KEY (recipient_id) REFERENCES public.profiles(id) ON DELETE CASCADE;


--
-- Name: forum_poll_options forum_poll_options_poll_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.forum_poll_options
    ADD CONSTRAINT forum_poll_options_poll_id_fkey FOREIGN KEY (poll_id) REFERENCES public.forum_polls(id) ON DELETE CASCADE;


--
-- Name: forum_poll_votes forum_poll_votes_option_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.forum_poll_votes
    ADD CONSTRAINT forum_poll_votes_option_id_fkey FOREIGN KEY (option_id) REFERENCES public.forum_poll_options(id) ON DELETE CASCADE;


--
-- Name: forum_poll_votes forum_poll_votes_poll_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.forum_poll_votes
    ADD CONSTRAINT forum_poll_votes_poll_id_fkey FOREIGN KEY (poll_id) REFERENCES public.forum_polls(id) ON DELETE CASCADE;


--
-- Name: forum_poll_votes forum_poll_votes_profile_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.forum_poll_votes
    ADD CONSTRAINT forum_poll_votes_profile_id_fkey FOREIGN KEY (profile_id) REFERENCES public.profiles(id) ON DELETE CASCADE;


--
-- Name: forum_polls forum_polls_forum_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.forum_polls
    ADD CONSTRAINT forum_polls_forum_id_fkey FOREIGN KEY (forum_id) REFERENCES public.forum(id) ON DELETE CASCADE;


--
-- Name: forum_post_analytics forum_post_analytics_forum_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.forum_post_analytics
    ADD CONSTRAINT forum_post_analytics_forum_id_fkey FOREIGN KEY (forum_id) REFERENCES public.forum(id) ON DELETE CASCADE;


--
-- Name: forum_post_history forum_post_history_editor_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.forum_post_history
    ADD CONSTRAINT forum_post_history_editor_id_fkey FOREIGN KEY (editor_id) REFERENCES public.profiles(id) ON DELETE SET NULL;


--
-- Name: forum_post_history forum_post_history_forum_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.forum_post_history
    ADD CONSTRAINT forum_post_history_forum_id_fkey FOREIGN KEY (forum_id) REFERENCES public.forum(id) ON DELETE CASCADE;


--
-- Name: forum_post_tags forum_post_tags_forum_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.forum_post_tags
    ADD CONSTRAINT forum_post_tags_forum_id_fkey FOREIGN KEY (forum_id) REFERENCES public.forum(id) ON DELETE CASCADE;


--
-- Name: forum_post_tags forum_post_tags_tag_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.forum_post_tags
    ADD CONSTRAINT forum_post_tags_tag_id_fkey FOREIGN KEY (tag_id) REFERENCES public.forum_tags(id) ON DELETE CASCADE;


--
-- Name: forum forum_profile_id_profiles_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.forum
    ADD CONSTRAINT forum_profile_id_profiles_fkey FOREIGN KEY (profile_id) REFERENCES public.profiles(id) ON DELETE CASCADE;


--
-- Name: forum_publication_queue forum_publication_queue_recurring_post_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.forum_publication_queue
    ADD CONSTRAINT forum_publication_queue_recurring_post_id_fkey FOREIGN KEY (recurring_post_id) REFERENCES public.forum_recurring_posts(id) ON DELETE CASCADE;


--
-- Name: forum_publication_queue forum_publication_queue_scheduled_post_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.forum_publication_queue
    ADD CONSTRAINT forum_publication_queue_scheduled_post_id_fkey FOREIGN KEY (scheduled_post_id) REFERENCES public.forum_scheduled_posts(id) ON DELETE CASCADE;


--
-- Name: forum_rate_limits forum_rate_limits_profile_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.forum_rate_limits
    ADD CONSTRAINT forum_rate_limits_profile_id_fkey FOREIGN KEY (profile_id) REFERENCES public.profiles(id) ON DELETE CASCADE;


--
-- Name: forum_reactions forum_reactions_forum_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.forum_reactions
    ADD CONSTRAINT forum_reactions_forum_id_fkey FOREIGN KEY (forum_id) REFERENCES public.forum(id) ON DELETE CASCADE;


--
-- Name: forum_reactions forum_reactions_profile_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.forum_reactions
    ADD CONSTRAINT forum_reactions_profile_id_fkey FOREIGN KEY (profile_id) REFERENCES public.profiles(id) ON DELETE CASCADE;


--
-- Name: forum_reactions forum_reactions_reaction_type_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.forum_reactions
    ADD CONSTRAINT forum_reactions_reaction_type_id_fkey FOREIGN KEY (reaction_type_id) REFERENCES public.reaction_types(id) ON DELETE CASCADE;


--
-- Name: forum_reading_history forum_reading_history_forum_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.forum_reading_history
    ADD CONSTRAINT forum_reading_history_forum_id_fkey FOREIGN KEY (forum_id) REFERENCES public.forum(id) ON DELETE CASCADE;


--
-- Name: forum_reading_history forum_reading_history_profile_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.forum_reading_history
    ADD CONSTRAINT forum_reading_history_profile_id_fkey FOREIGN KEY (profile_id) REFERENCES public.profiles(id) ON DELETE CASCADE;


--
-- Name: forum_reading_progress forum_reading_progress_forum_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.forum_reading_progress
    ADD CONSTRAINT forum_reading_progress_forum_id_fkey FOREIGN KEY (forum_id) REFERENCES public.forum(id) ON DELETE CASCADE;


--
-- Name: forum_reading_progress forum_reading_progress_last_read_comment_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.forum_reading_progress
    ADD CONSTRAINT forum_reading_progress_last_read_comment_id_fkey FOREIGN KEY (last_read_comment_id) REFERENCES public.comments(id) ON DELETE SET NULL;


--
-- Name: forum_reading_progress forum_reading_progress_profile_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.forum_reading_progress
    ADD CONSTRAINT forum_reading_progress_profile_id_fkey FOREIGN KEY (profile_id) REFERENCES public.profiles(id) ON DELETE CASCADE;


--
-- Name: forum_recurring_posts forum_recurring_posts_category_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.forum_recurring_posts
    ADD CONSTRAINT forum_recurring_posts_category_id_fkey FOREIGN KEY (category_id) REFERENCES public.forum_categories(id) ON DELETE SET NULL;


--
-- Name: forum_recurring_posts forum_recurring_posts_profile_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.forum_recurring_posts
    ADD CONSTRAINT forum_recurring_posts_profile_id_fkey FOREIGN KEY (profile_id) REFERENCES public.profiles(id) ON DELETE CASCADE;


--
-- Name: forum_reports forum_reports_comment_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.forum_reports
    ADD CONSTRAINT forum_reports_comment_id_fkey FOREIGN KEY (comment_id) REFERENCES public.comments(id) ON DELETE CASCADE;


--
-- Name: forum_reports forum_reports_forum_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.forum_reports
    ADD CONSTRAINT forum_reports_forum_id_fkey FOREIGN KEY (forum_id) REFERENCES public.forum(id) ON DELETE CASCADE;


--
-- Name: forum_reports forum_reports_moderator_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.forum_reports
    ADD CONSTRAINT forum_reports_moderator_id_fkey FOREIGN KEY (moderator_id) REFERENCES public.profiles(id) ON DELETE SET NULL;


--
-- Name: forum_reports forum_reports_reported_profile_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.forum_reports
    ADD CONSTRAINT forum_reports_reported_profile_id_fkey FOREIGN KEY (reported_profile_id) REFERENCES public.profiles(id) ON DELETE SET NULL;


--
-- Name: forum_reports forum_reports_reporter_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.forum_reports
    ADD CONSTRAINT forum_reports_reporter_id_fkey FOREIGN KEY (reporter_id) REFERENCES public.profiles(id) ON DELETE CASCADE;


--
-- Name: forum_reputation_history forum_reputation_history_profile_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.forum_reputation_history
    ADD CONSTRAINT forum_reputation_history_profile_id_fkey FOREIGN KEY (profile_id) REFERENCES public.profiles(id) ON DELETE CASCADE;


--
-- Name: forum_reputation_history forum_reputation_history_source_comment_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.forum_reputation_history
    ADD CONSTRAINT forum_reputation_history_source_comment_id_fkey FOREIGN KEY (source_comment_id) REFERENCES public.comments(id) ON DELETE SET NULL;


--
-- Name: forum_reputation_history forum_reputation_history_source_forum_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.forum_reputation_history
    ADD CONSTRAINT forum_reputation_history_source_forum_id_fkey FOREIGN KEY (source_forum_id) REFERENCES public.forum(id) ON DELETE SET NULL;


--
-- Name: forum_reputation_history forum_reputation_history_source_profile_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.forum_reputation_history
    ADD CONSTRAINT forum_reputation_history_source_profile_id_fkey FOREIGN KEY (source_profile_id) REFERENCES public.profiles(id) ON DELETE SET NULL;


--
-- Name: forum_saved_searches forum_saved_searches_profile_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.forum_saved_searches
    ADD CONSTRAINT forum_saved_searches_profile_id_fkey FOREIGN KEY (profile_id) REFERENCES public.profiles(id) ON DELETE CASCADE;


--
-- Name: forum_scheduled_posts forum_scheduled_posts_category_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.forum_scheduled_posts
    ADD CONSTRAINT forum_scheduled_posts_category_id_fkey FOREIGN KEY (category_id) REFERENCES public.forum_categories(id) ON DELETE SET NULL;


--
-- Name: forum_scheduled_posts forum_scheduled_posts_profile_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.forum_scheduled_posts
    ADD CONSTRAINT forum_scheduled_posts_profile_id_fkey FOREIGN KEY (profile_id) REFERENCES public.profiles(id) ON DELETE CASCADE;


--
-- Name: forum_scheduled_posts forum_scheduled_posts_published_forum_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.forum_scheduled_posts
    ADD CONSTRAINT forum_scheduled_posts_published_forum_id_fkey FOREIGN KEY (published_forum_id) REFERENCES public.forum(id) ON DELETE SET NULL;


--
-- Name: forum_scheduled_posts forum_scheduled_posts_series_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.forum_scheduled_posts
    ADD CONSTRAINT forum_scheduled_posts_series_id_fkey FOREIGN KEY (series_id) REFERENCES public.forum_series(id) ON DELETE SET NULL;


--
-- Name: forum_search_history forum_search_history_profile_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.forum_search_history
    ADD CONSTRAINT forum_search_history_profile_id_fkey FOREIGN KEY (profile_id) REFERENCES public.profiles(id) ON DELETE CASCADE;


--
-- Name: forum_series forum_series_category_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.forum_series
    ADD CONSTRAINT forum_series_category_id_fkey FOREIGN KEY (category_id) REFERENCES public.forum_categories(id) ON DELETE SET NULL;


--
-- Name: forum forum_series_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.forum
    ADD CONSTRAINT forum_series_id_fkey FOREIGN KEY (series_id) REFERENCES public.forum_series(id) ON DELETE SET NULL;


--
-- Name: forum_series_posts forum_series_posts_forum_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.forum_series_posts
    ADD CONSTRAINT forum_series_posts_forum_id_fkey FOREIGN KEY (forum_id) REFERENCES public.forum(id) ON DELETE CASCADE;


--
-- Name: forum_series_posts forum_series_posts_series_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.forum_series_posts
    ADD CONSTRAINT forum_series_posts_series_id_fkey FOREIGN KEY (series_id) REFERENCES public.forum_series(id) ON DELETE CASCADE;


--
-- Name: forum_series forum_series_profile_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.forum_series
    ADD CONSTRAINT forum_series_profile_id_fkey FOREIGN KEY (profile_id) REFERENCES public.profiles(id) ON DELETE CASCADE;


--
-- Name: forum_subscriptions forum_subscriptions_category_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.forum_subscriptions
    ADD CONSTRAINT forum_subscriptions_category_id_fkey FOREIGN KEY (category_id) REFERENCES public.forum_categories(id) ON DELETE CASCADE;


--
-- Name: forum_subscriptions forum_subscriptions_forum_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.forum_subscriptions
    ADD CONSTRAINT forum_subscriptions_forum_id_fkey FOREIGN KEY (forum_id) REFERENCES public.forum(id) ON DELETE CASCADE;


--
-- Name: forum_subscriptions forum_subscriptions_profile_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.forum_subscriptions
    ADD CONSTRAINT forum_subscriptions_profile_id_fkey FOREIGN KEY (profile_id) REFERENCES public.profiles(id) ON DELETE CASCADE;


--
-- Name: forum_user_badges forum_user_badges_awarded_by_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.forum_user_badges
    ADD CONSTRAINT forum_user_badges_awarded_by_fkey FOREIGN KEY (awarded_by) REFERENCES public.profiles(id) ON DELETE SET NULL;


--
-- Name: forum_user_badges forum_user_badges_badge_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.forum_user_badges
    ADD CONSTRAINT forum_user_badges_badge_id_fkey FOREIGN KEY (badge_id) REFERENCES public.forum_badges(id) ON DELETE CASCADE;


--
-- Name: forum_user_badges forum_user_badges_profile_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.forum_user_badges
    ADD CONSTRAINT forum_user_badges_profile_id_fkey FOREIGN KEY (profile_id) REFERENCES public.profiles(id) ON DELETE CASCADE;


--
-- Name: forum_user_blocks forum_user_blocks_blocked_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.forum_user_blocks
    ADD CONSTRAINT forum_user_blocks_blocked_id_fkey FOREIGN KEY (blocked_id) REFERENCES public.profiles(id) ON DELETE CASCADE;


--
-- Name: forum_user_blocks forum_user_blocks_blocker_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.forum_user_blocks
    ADD CONSTRAINT forum_user_blocks_blocker_id_fkey FOREIGN KEY (blocker_id) REFERENCES public.profiles(id) ON DELETE CASCADE;


--
-- Name: forum_user_follows forum_user_follows_follower_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.forum_user_follows
    ADD CONSTRAINT forum_user_follows_follower_id_fkey FOREIGN KEY (follower_id) REFERENCES public.profiles(id) ON DELETE CASCADE;


--
-- Name: forum_user_follows forum_user_follows_following_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.forum_user_follows
    ADD CONSTRAINT forum_user_follows_following_id_fkey FOREIGN KEY (following_id) REFERENCES public.profiles(id) ON DELETE CASCADE;


--
-- Name: forum_user_reputation forum_user_reputation_profile_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.forum_user_reputation
    ADD CONSTRAINT forum_user_reputation_profile_id_fkey FOREIGN KEY (profile_id) REFERENCES public.profiles(id) ON DELETE CASCADE;


--
-- Name: forum_user_stats forum_user_stats_profile_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.forum_user_stats
    ADD CONSTRAINT forum_user_stats_profile_id_fkey FOREIGN KEY (profile_id) REFERENCES public.profiles(id) ON DELETE CASCADE;


--
-- Name: forum_user_stats forum_user_stats_trust_level_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.forum_user_stats
    ADD CONSTRAINT forum_user_stats_trust_level_fkey FOREIGN KEY (trust_level) REFERENCES public.forum_trust_levels(level);


--
-- Name: forum_user_warnings forum_user_warnings_ban_lifted_by_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.forum_user_warnings
    ADD CONSTRAINT forum_user_warnings_ban_lifted_by_fkey FOREIGN KEY (ban_lifted_by) REFERENCES public.profiles(id) ON DELETE SET NULL;


--
-- Name: forum_user_warnings forum_user_warnings_moderator_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.forum_user_warnings
    ADD CONSTRAINT forum_user_warnings_moderator_id_fkey FOREIGN KEY (moderator_id) REFERENCES public.profiles(id) ON DELETE SET NULL;


--
-- Name: forum_user_warnings forum_user_warnings_profile_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.forum_user_warnings
    ADD CONSTRAINT forum_user_warnings_profile_id_fkey FOREIGN KEY (profile_id) REFERENCES public.profiles(id) ON DELETE CASCADE;


--
-- Name: forum_user_warnings forum_user_warnings_queue_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.forum_user_warnings
    ADD CONSTRAINT forum_user_warnings_queue_id_fkey FOREIGN KEY (queue_id) REFERENCES public.forum_moderation_queue(id) ON DELETE SET NULL;


--
-- Name: handlers handlers_profile_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.handlers
    ADD CONSTRAINT handlers_profile_id_fkey FOREIGN KEY (profile_id) REFERENCES auth.users(id) ON DELETE CASCADE;


--
-- Name: image_upload_metrics image_upload_metrics_user_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.image_upload_metrics
    ADD CONSTRAINT image_upload_metrics_user_id_fkey FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE SET NULL;


--
-- Name: in_app_notifications in_app_notifications_user_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.in_app_notifications
    ADD CONSTRAINT in_app_notifications_user_id_fkey FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE CASCADE;


--
-- Name: likes likes_profile_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.likes
    ADD CONSTRAINT likes_profile_id_fkey FOREIGN KEY (profile_id) REFERENCES public.profiles(id) ON DELETE CASCADE;


--
-- Name: mfa_configuration mfa_configuration_profile_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.mfa_configuration
    ADD CONSTRAINT mfa_configuration_profile_id_fkey FOREIGN KEY (profile_id) REFERENCES public.profiles(id) ON DELETE CASCADE;


--
-- Name: mfa_rate_limits mfa_rate_limits_profile_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.mfa_rate_limits
    ADD CONSTRAINT mfa_rate_limits_profile_id_fkey FOREIGN KEY (profile_id) REFERENCES public.profiles(id) ON DELETE CASCADE;


--
-- Name: mfa_sessions mfa_sessions_profile_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.mfa_sessions
    ADD CONSTRAINT mfa_sessions_profile_id_fkey FOREIGN KEY (profile_id) REFERENCES public.profiles(id) ON DELETE CASCADE;


--
-- Name: mfa_verification_attempts mfa_verification_attempts_profile_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.mfa_verification_attempts
    ADD CONSTRAINT mfa_verification_attempts_profile_id_fkey FOREIGN KEY (profile_id) REFERENCES public.profiles(id) ON DELETE CASCADE;


--
-- Name: moderation_queue moderation_queue_reporter_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.moderation_queue
    ADD CONSTRAINT moderation_queue_reporter_id_fkey FOREIGN KEY (reporter_id) REFERENCES auth.users(id) ON DELETE SET NULL;


--
-- Name: moderation_queue moderation_queue_reviewed_by_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.moderation_queue
    ADD CONSTRAINT moderation_queue_reviewed_by_fkey FOREIGN KEY (reviewed_by) REFERENCES auth.users(id) ON DELETE SET NULL;


--
-- Name: newsletter_campaigns newsletter_campaigns_created_by_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.newsletter_campaigns
    ADD CONSTRAINT newsletter_campaigns_created_by_fkey FOREIGN KEY (created_by) REFERENCES public.profiles(id);


--
-- Name: notification_delivery_log notification_delivery_log_user_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.notification_delivery_log
    ADD CONSTRAINT notification_delivery_log_user_id_fkey FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE CASCADE;


--
-- Name: notification_digest_queue notification_digest_queue_user_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.notification_digest_queue
    ADD CONSTRAINT notification_digest_queue_user_id_fkey FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE CASCADE;


--
-- Name: notification_preferences notification_preferences_user_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.notification_preferences
    ADD CONSTRAINT notification_preferences_user_id_fkey FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE CASCADE;


--
-- Name: notification_queue notification_queue_user_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.notification_queue
    ADD CONSTRAINT notification_queue_user_id_fkey FOREIGN KEY (user_id) REFERENCES public.profiles(id) ON DELETE CASCADE;


--
-- Name: notification_settings notification_settings_user_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.notification_settings
    ADD CONSTRAINT notification_settings_user_id_fkey FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE CASCADE;


--
-- Name: notifications notifications_profile_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.notifications
    ADD CONSTRAINT notifications_profile_id_fkey FOREIGN KEY (profile_id) REFERENCES public.profiles(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: organization_members organization_members_organization_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.organization_members
    ADD CONSTRAINT organization_members_organization_id_fkey FOREIGN KEY (organization_id) REFERENCES public.organizations(id) ON DELETE CASCADE;


--
-- Name: organization_members organization_members_user_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.organization_members
    ADD CONSTRAINT organization_members_user_id_fkey FOREIGN KEY (user_id) REFERENCES public.profiles(id) ON DELETE CASCADE;


--
-- Name: pending_operations pending_operations_user_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.pending_operations
    ADD CONSTRAINT pending_operations_user_id_fkey FOREIGN KEY (user_id) REFERENCES public.profiles(id) ON DELETE CASCADE;


--
-- Name: post_activity_logs post_activity_logs_actor_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.post_activity_logs
    ADD CONSTRAINT post_activity_logs_actor_id_fkey FOREIGN KEY (actor_id) REFERENCES public.profiles(id) ON DELETE SET NULL;


--
-- Name: post_activity_logs post_activity_logs_post_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.post_activity_logs
    ADD CONSTRAINT post_activity_logs_post_id_fkey FOREIGN KEY (post_id) REFERENCES public.posts(id) ON DELETE SET NULL;


--
-- Name: post_activity_logs post_activity_logs_related_post_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.post_activity_logs
    ADD CONSTRAINT post_activity_logs_related_post_id_fkey FOREIGN KEY (related_post_id) REFERENCES public.posts(id) ON DELETE SET NULL;


--
-- Name: post_activity_logs post_activity_logs_related_profile_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.post_activity_logs
    ADD CONSTRAINT post_activity_logs_related_profile_id_fkey FOREIGN KEY (related_profile_id) REFERENCES public.profiles(id) ON DELETE SET NULL;


--
-- Name: post_activity_logs post_activity_logs_related_room_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.post_activity_logs
    ADD CONSTRAINT post_activity_logs_related_room_id_fkey FOREIGN KEY (related_room_id) REFERENCES public.rooms(id) ON DELETE SET NULL;


--
-- Name: post_reports post_reports_moderator_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.post_reports
    ADD CONSTRAINT post_reports_moderator_id_fkey FOREIGN KEY (moderator_id) REFERENCES public.profiles(id);


--
-- Name: post_reports post_reports_post_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.post_reports
    ADD CONSTRAINT post_reports_post_id_fkey FOREIGN KEY (post_id) REFERENCES public.posts(id) ON DELETE CASCADE;


--
-- Name: post_reports post_reports_reporter_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.post_reports
    ADD CONSTRAINT post_reports_reporter_id_fkey FOREIGN KEY (reporter_id) REFERENCES public.profiles(id) ON DELETE CASCADE;


--
-- Name: post_views post_views_post_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.post_views
    ADD CONSTRAINT post_views_post_id_fkey FOREIGN KEY (post_id) REFERENCES public.posts(id) ON DELETE CASCADE;


--
-- Name: post_views post_views_viewer_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.post_views
    ADD CONSTRAINT post_views_viewer_id_fkey FOREIGN KEY (viewer_id) REFERENCES public.profiles(id) ON DELETE SET NULL;


--
-- Name: posts posts_category_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.posts
    ADD CONSTRAINT posts_category_id_fkey FOREIGN KEY (category_id) REFERENCES public.categories(id);


--
-- Name: posts posts_post_arranged_to_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.posts
    ADD CONSTRAINT posts_post_arranged_to_fkey FOREIGN KEY (post_arranged_to) REFERENCES public.profiles(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: posts posts_profile_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.posts
    ADD CONSTRAINT posts_profile_id_fkey FOREIGN KEY (profile_id) REFERENCES public.profiles(id) ON DELETE CASCADE;


--
-- Name: profile_stats profile_stats_profile_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.profile_stats
    ADD CONSTRAINT profile_stats_profile_id_fkey FOREIGN KEY (profile_id) REFERENCES public.profiles(id) ON DELETE CASCADE;


--
-- Name: profiles profiles_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.profiles
    ADD CONSTRAINT profiles_id_fkey FOREIGN KEY (id) REFERENCES auth.users(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: reports reports_profile_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.reports
    ADD CONSTRAINT reports_profile_id_fkey FOREIGN KEY (profile_id) REFERENCES public.profiles(id) ON DELETE CASCADE;


--
-- Name: reviews reviews_challenge_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.reviews
    ADD CONSTRAINT reviews_challenge_id_fkey FOREIGN KEY (challenge_id) REFERENCES public.challenges(id) ON DELETE CASCADE;


--
-- Name: reviews reviews_forum_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.reviews
    ADD CONSTRAINT reviews_forum_id_fkey FOREIGN KEY (forum_id) REFERENCES public.forum(id) ON DELETE CASCADE;


--
-- Name: reviews reviews_post_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.reviews
    ADD CONSTRAINT reviews_post_id_fkey FOREIGN KEY (post_id) REFERENCES public.posts(id) ON DELETE SET NULL;


--
-- Name: reviews reviews_profile_id_profiles_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.reviews
    ADD CONSTRAINT reviews_profile_id_profiles_fkey FOREIGN KEY (profile_id) REFERENCES public.profiles(id) ON DELETE CASCADE;


--
-- Name: CONSTRAINT reviews_profile_id_profiles_fkey ON reviews; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON CONSTRAINT reviews_profile_id_profiles_fkey ON public.reviews IS 'Links reviews to the profile who created them (enables PostgREST embedding)';


--
-- Name: room_participants room_participants_profile_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.room_participants
    ADD CONSTRAINT room_participants_profile_id_fkey FOREIGN KEY (profile_id) REFERENCES public.profiles(id) ON DELETE CASCADE;


--
-- Name: room_participants room_participants_room_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.room_participants
    ADD CONSTRAINT room_participants_room_id_fkey FOREIGN KEY (room_id) REFERENCES public.rooms(id) ON DELETE CASCADE;


--
-- Name: rooms rooms_last_message_seen_by_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.rooms
    ADD CONSTRAINT rooms_last_message_seen_by_fkey FOREIGN KEY (last_message_seen_by) REFERENCES public.profiles(id);


--
-- Name: rooms rooms_last_message_sent_by_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.rooms
    ADD CONSTRAINT rooms_last_message_sent_by_fkey FOREIGN KEY (last_message_sent_by) REFERENCES public.profiles(id);


--
-- Name: rooms rooms_post_arranged_to_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.rooms
    ADD CONSTRAINT rooms_post_arranged_to_fkey FOREIGN KEY (post_arranged_to) REFERENCES public.profiles(id) ON DELETE CASCADE;


--
-- Name: rooms rooms_post_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.rooms
    ADD CONSTRAINT rooms_post_id_fkey FOREIGN KEY (post_id) REFERENCES public.posts(id) ON DELETE SET NULL;


--
-- Name: rooms rooms_requester_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.rooms
    ADD CONSTRAINT rooms_requester_fkey FOREIGN KEY (requester) REFERENCES public.profiles(id) ON DELETE CASCADE;


--
-- Name: rooms rooms_sharer_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.rooms
    ADD CONSTRAINT rooms_sharer_fkey FOREIGN KEY (sharer) REFERENCES public.profiles(id) ON DELETE CASCADE;


--
-- Name: sync_checkpoints sync_checkpoints_user_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.sync_checkpoints
    ADD CONSTRAINT sync_checkpoints_user_id_fkey FOREIGN KEY (user_id) REFERENCES public.profiles(id) ON DELETE CASCADE;


--
-- Name: translation_analytics translation_analytics_user_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.translation_analytics
    ADD CONSTRAINT translation_analytics_user_id_fkey FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE SET NULL;


--
-- Name: translation_change_log translation_change_log_changed_by_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.translation_change_log
    ADD CONSTRAINT translation_change_log_changed_by_fkey FOREIGN KEY (changed_by) REFERENCES auth.users(id);


--
-- Name: translation_errors translation_errors_user_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.translation_errors
    ADD CONSTRAINT translation_errors_user_id_fkey FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE SET NULL;


--
-- Name: translation_sync_status translation_sync_status_user_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.translation_sync_status
    ADD CONSTRAINT translation_sync_status_user_id_fkey FOREIGN KEY (user_id) REFERENCES auth.users(id);


--
-- Name: translation_usage_analytics translation_usage_analytics_user_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.translation_usage_analytics
    ADD CONSTRAINT translation_usage_analytics_user_id_fkey FOREIGN KEY (user_id) REFERENCES auth.users(id);


--
-- Name: user_activity_summary user_activity_summary_user_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.user_activity_summary
    ADD CONSTRAINT user_activity_summary_user_id_fkey FOREIGN KEY (user_id) REFERENCES public.profiles(id) ON DELETE CASCADE;


--
-- Name: user_addresses user_addresses_profile_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.user_addresses
    ADD CONSTRAINT user_addresses_profile_id_fkey FOREIGN KEY (profile_id) REFERENCES public.profiles(id) ON DELETE CASCADE;


--
-- Name: user_locale_preferences user_locale_preferences_user_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.user_locale_preferences
    ADD CONSTRAINT user_locale_preferences_user_id_fkey FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE CASCADE;


--
-- Name: user_notifications user_notifications_actor_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.user_notifications
    ADD CONSTRAINT user_notifications_actor_id_fkey FOREIGN KEY (actor_id) REFERENCES public.profiles(id) ON DELETE SET NULL;


--
-- Name: user_notifications user_notifications_post_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.user_notifications
    ADD CONSTRAINT user_notifications_post_id_fkey FOREIGN KEY (post_id) REFERENCES public.posts(id) ON DELETE CASCADE;


--
-- Name: user_notifications user_notifications_recipient_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.user_notifications
    ADD CONSTRAINT user_notifications_recipient_id_fkey FOREIGN KEY (recipient_id) REFERENCES public.profiles(id) ON DELETE CASCADE;


--
-- Name: user_notifications user_notifications_review_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.user_notifications
    ADD CONSTRAINT user_notifications_review_id_fkey FOREIGN KEY (review_id) REFERENCES public.reviews(id) ON DELETE CASCADE;


--
-- Name: user_notifications user_notifications_room_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.user_notifications
    ADD CONSTRAINT user_notifications_room_id_fkey FOREIGN KEY (room_id) REFERENCES public.rooms(id) ON DELETE CASCADE;


--
-- Name: user_preferences user_preferences_profile_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.user_preferences
    ADD CONSTRAINT user_preferences_profile_id_fkey FOREIGN KEY (profile_id) REFERENCES public.profiles(id) ON DELETE CASCADE;


--
-- Name: user_rate_limits user_rate_limits_user_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.user_rate_limits
    ADD CONSTRAINT user_rate_limits_user_id_fkey FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE CASCADE;


--
-- Name: user_roles user_roles_granted_by_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.user_roles
    ADD CONSTRAINT user_roles_granted_by_fkey FOREIGN KEY (granted_by) REFERENCES public.profiles(id);


--
-- Name: user_roles user_roles_profile_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.user_roles
    ADD CONSTRAINT user_roles_profile_id_fkey FOREIGN KEY (profile_id) REFERENCES public.profiles(id) ON DELETE CASCADE;


--
-- Name: user_roles user_roles_role_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.user_roles
    ADD CONSTRAINT user_roles_role_id_fkey FOREIGN KEY (role_id) REFERENCES public.roles(id) ON DELETE CASCADE;


--
-- Name: email_templates Admin full access to email templates; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Admin full access to email templates" ON public.email_templates USING ((EXISTS ( SELECT 1
   FROM (public.user_roles ur
     JOIN public.roles r ON ((ur.role_id = r.id)))
  WHERE ((ur.profile_id = auth.uid()) AND (r.name = ANY (ARRAY['admin'::text, 'superadmin'::text]))))));


--
-- Name: email_template_versions Admin read email template versions; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Admin read email template versions" ON public.email_template_versions FOR SELECT USING ((EXISTS ( SELECT 1
   FROM (public.user_roles ur
     JOIN public.roles r ON ((ur.role_id = r.id)))
  WHERE ((ur.profile_id = auth.uid()) AND (r.name = ANY (ARRAY['admin'::text, 'superadmin'::text]))))));


--
-- Name: crm_customers Admins can manage CRM customers; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Admins can manage CRM customers" ON public.crm_customers USING (public.is_admin());


--
-- Name: crm_customer_notes Admins can manage CRM notes; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Admins can manage CRM notes" ON public.crm_customer_notes USING (public.is_admin());


--
-- Name: crm_customer_tag_assignments Admins can manage CRM tag assignments; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Admins can manage CRM tag assignments" ON public.crm_customer_tag_assignments USING (public.is_admin());


--
-- Name: crm_customer_tags Admins can manage CRM tags; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Admins can manage CRM tags" ON public.crm_customer_tags USING (public.is_admin());


--
-- Name: email_automation_flows Admins can manage automations; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Admins can manage automations" ON public.email_automation_flows USING (public.is_admin());


--
-- Name: newsletter_campaigns Admins can manage campaigns; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Admins can manage campaigns" ON public.newsletter_campaigns USING (public.is_admin());


--
-- Name: compressed_images Admins can manage compressed_images; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Admins can manage compressed_images" ON public.compressed_images TO authenticated USING (public.is_admin()) WITH CHECK (public.is_admin());


--
-- Name: automation_enrollments Admins can manage enrollments; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Admins can manage enrollments" ON public.automation_enrollments USING (public.is_admin());


--
-- Name: feature_flags Admins can manage feature flags; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Admins can manage feature flags" ON public.feature_flags TO service_role USING (true) WITH CHECK (true);


--
-- Name: image_compressions Admins can manage image_compressions; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Admins can manage image_compressions" ON public.image_compressions TO authenticated USING (public.is_admin()) WITH CHECK (public.is_admin());


--
-- Name: campaign_recipients Admins can manage recipients; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Admins can manage recipients" ON public.campaign_recipients USING (public.is_admin());


--
-- Name: audience_segments Admins can manage segments; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Admins can manage segments" ON public.audience_segments USING (public.is_admin());


--
-- Name: newsletter_subscribers Admins can manage subscribers; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Admins can manage subscribers" ON public.newsletter_subscribers USING (public.is_admin());


--
-- Name: mfa_rate_limits Admins can read MFA rate limits; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Admins can read MFA rate limits" ON public.mfa_rate_limits FOR SELECT USING (public.is_admin_jsonb());


--
-- Name: admin_audit_log Admins can read audit logs; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Admins can read audit logs" ON public.admin_audit_log FOR SELECT USING (public.is_admin_jsonb());


--
-- Name: email_audit_log Admins can read audit logs; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Admins can read audit logs" ON public.email_audit_log FOR SELECT TO authenticated USING ((EXISTS ( SELECT 1
   FROM (public.user_roles ur
     JOIN public.roles r ON ((r.id = ur.role_id)))
  WHERE ((ur.profile_id = auth.uid()) AND (r.name = ANY (ARRAY['admin'::text, 'superadmin'::text]))))));


--
-- Name: email_provider_quota Admins can read quota data; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Admins can read quota data" ON public.email_provider_quota FOR SELECT USING ((EXISTS ( SELECT 1
   FROM public.profiles
  WHERE (profiles.id = ( SELECT auth.uid() AS uid)))));


--
-- Name: feedback Admins can update feedback; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Admins can update feedback" ON public.feedback FOR UPDATE TO authenticated USING (public.is_admin());


--
-- Name: moderation_queue Admins can update moderation items; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Admins can update moderation items" ON public.moderation_queue FOR UPDATE USING ((EXISTS ( SELECT 1
   FROM (public.user_roles ur
     JOIN public.roles r ON ((ur.role_id = r.id)))
  WHERE ((ur.profile_id = auth.uid()) AND (r.name = ANY (ARRAY['admin'::text, 'moderator'::text]))))));


--
-- Name: post_reports Admins can update reports; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Admins can update reports" ON public.post_reports FOR UPDATE TO authenticated USING (public.is_admin());


--
-- Name: moderation_queue Admins can view all moderation items; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Admins can view all moderation items" ON public.moderation_queue FOR SELECT USING ((EXISTS ( SELECT 1
   FROM (public.user_roles ur
     JOIN public.roles r ON ((ur.role_id = r.id)))
  WHERE ((ur.profile_id = auth.uid()) AND (r.name = ANY (ARRAY['admin'::text, 'moderator'::text]))))));


--
-- Name: email_provider_health_metrics Admins can view email provider health metrics; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Admins can view email provider health metrics" ON public.email_provider_health_metrics FOR SELECT TO authenticated USING ((EXISTS ( SELECT 1
   FROM (public.user_roles ur
     JOIN public.roles r ON ((r.id = ur.role_id)))
  WHERE ((ur.profile_id = auth.uid()) AND (r.name = ANY (ARRAY['admin'::text, 'superadmin'::text]))))));


--
-- Name: email_provider_stats Admins can view email provider stats; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Admins can view email provider stats" ON public.email_provider_stats FOR SELECT TO authenticated USING ((EXISTS ( SELECT 1
   FROM (public.user_roles ur
     JOIN public.roles r ON ((r.id = ur.role_id)))
  WHERE ((ur.profile_id = auth.uid()) AND (r.name = ANY (ARRAY['admin'::text, 'superadmin'::text]))))));


--
-- Name: email_queue Admins can view email queue; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Admins can view email queue" ON public.email_queue FOR SELECT USING ((EXISTS ( SELECT 1
   FROM public.profiles
  WHERE (profiles.id = ( SELECT auth.uid() AS uid)))));


--
-- Name: email_provider_health_history Admins can view health history; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Admins can view health history" ON public.email_provider_health_history FOR SELECT USING (public.is_admin_jsonb());


--
-- Name: grok_usage_logs Allow all operations on grok usage logs; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Allow all operations on grok usage logs" ON public.grok_usage_logs USING (true) WITH CHECK (true);


--
-- Name: profiles Allow public read access to profiles; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Allow public read access to profiles" ON public.profiles FOR SELECT USING (true);


--
-- Name: translation_cache Allow public read on translation_cache; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Allow public read on translation_cache" ON public.translation_cache FOR SELECT USING (true);


--
-- Name: translation_platform_config Allow public read on translation_platform_config; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Allow public read on translation_platform_config" ON public.translation_platform_config FOR SELECT USING (true);


--
-- Name: translation_versions Allow public read on translation_versions; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Allow public read on translation_versions" ON public.translation_versions FOR SELECT USING (true);


--
-- Name: profiles Allow users to delete their own profiles; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Allow users to delete their own profiles" ON public.profiles FOR DELETE USING ((id = ( SELECT auth.uid() AS uid)));


--
-- Name: profiles Allow users to insert their own profiles; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Allow users to insert their own profiles" ON public.profiles FOR INSERT WITH CHECK ((id = ( SELECT auth.uid() AS uid)));


--
-- Name: profiles Allow users to update their own profiles; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Allow users to update their own profiles" ON public.profiles FOR UPDATE USING ((id = ( SELECT auth.uid() AS uid)));


--
-- Name: translation_analytics Analytics readable by authenticated users; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Analytics readable by authenticated users" ON public.translation_analytics FOR SELECT USING ((( SELECT auth.uid() AS uid) IS NOT NULL));


--
-- Name: feedback Anonymous users can read unassigned feedback; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Anonymous users can read unassigned feedback" ON public.feedback FOR SELECT TO anon USING ((profile_id IS NULL));


--
-- Name: app_config Anyone can read config; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Anyone can read config" ON public.app_config FOR SELECT USING (true);


--
-- Name: feature_flags Anyone can read feature flags; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Anyone can read feature flags" ON public.feature_flags FOR SELECT TO authenticated, anon USING (true);


--
-- Name: forum_reactions Anyone can read forum reactions; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Anyone can read forum reactions" ON public.forum_reactions FOR SELECT USING (true);


--
-- Name: legal_documents Anyone can read legal documents; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Anyone can read legal documents" ON public.legal_documents FOR SELECT USING (true);


--
-- Name: forum_mentions Anyone can read mentions; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Anyone can read mentions" ON public.forum_mentions FOR SELECT USING (true);


--
-- Name: reaction_types Anyone can read reaction types; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Anyone can read reaction types" ON public.reaction_types FOR SELECT USING (true);


--
-- Name: feedback Anyone can submit feedback; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Anyone can submit feedback" ON public.feedback FOR INSERT TO authenticated, anon WITH CHECK (true);


--
-- Name: post_views Anyone can track views; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Anyone can track views" ON public.post_views FOR INSERT WITH CHECK (true);


--
-- Name: forum_activity_types Anyone can view activity types; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Anyone can view activity types" ON public.forum_activity_types FOR SELECT TO authenticated USING (true);


--
-- Name: forum_badges Anyone can view badges; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Anyone can view badges" ON public.forum_badges FOR SELECT USING (true);


--
-- Name: forum_comment_history Anyone can view comment history; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Anyone can view comment history" ON public.forum_comment_history FOR SELECT USING (true);


--
-- Name: forum_comment_reactions Anyone can view comment reactions; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Anyone can view comment reactions" ON public.forum_comment_reactions FOR SELECT TO authenticated USING (true);


--
-- Name: forum_user_follows Anyone can view follows; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Anyone can view follows" ON public.forum_user_follows FOR SELECT USING (true);


--
-- Name: handlers Anyone can view handlers; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Anyone can view handlers" ON public.handlers FOR SELECT USING (true);


--
-- Name: legal Anyone can view legal documents; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Anyone can view legal documents" ON public.legal FOR SELECT USING (true);


--
-- Name: forum_polls Anyone can view polls; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Anyone can view polls" ON public.forum_polls FOR SELECT USING (true);


--
-- Name: forum_popular_searches Anyone can view popular searches; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Anyone can view popular searches" ON public.forum_popular_searches FOR SELECT USING (true);


--
-- Name: forum_post_history Anyone can view post history; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Anyone can view post history" ON public.forum_post_history FOR SELECT USING (true);


--
-- Name: forum_rate_limit_config Anyone can view rate limit config; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Anyone can view rate limit config" ON public.forum_rate_limit_config FOR SELECT TO authenticated USING (true);


--
-- Name: forum_reputation_actions Anyone can view reputation actions; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Anyone can view reputation actions" ON public.forum_reputation_actions FOR SELECT TO authenticated USING (true);


--
-- Name: forum_reputation_levels Anyone can view reputation levels; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Anyone can view reputation levels" ON public.forum_reputation_levels FOR SELECT TO authenticated USING (true);


--
-- Name: forum_system_messages Anyone can view system messages; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Anyone can view system messages" ON public.forum_system_messages FOR SELECT TO authenticated USING ((is_active = true));


--
-- Name: forum_tags Anyone can view tags; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Anyone can view tags" ON public.forum_tags FOR SELECT USING (true);


--
-- Name: forum_trust_levels Anyone can view trust levels; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Anyone can view trust levels" ON public.forum_trust_levels FOR SELECT USING (true);


--
-- Name: forum_user_badges Anyone can view user badges; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Anyone can view user badges" ON public.forum_user_badges FOR SELECT USING (true);


--
-- Name: forum_user_reputation Anyone can view user reputation; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Anyone can view user reputation" ON public.forum_user_reputation FOR SELECT TO authenticated USING (true);


--
-- Name: forum_comment_reactions Authenticated users can add reactions; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Authenticated users can add reactions" ON public.forum_comment_reactions FOR INSERT TO authenticated WITH CHECK ((( SELECT auth.uid() AS uid) IS NOT NULL));


--
-- Name: forum_reactions Authenticated users can add reactions; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Authenticated users can add reactions" ON public.forum_reactions FOR INSERT TO authenticated WITH CHECK ((profile_id = ( SELECT auth.uid() AS uid)));


--
-- Name: challenges Authenticated users can create challenges; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Authenticated users can create challenges" ON public.challenges FOR INSERT WITH CHECK ((profile_id = ( SELECT auth.uid() AS uid)));


--
-- Name: forum_mentions Authenticated users can create mentions; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Authenticated users can create mentions" ON public.forum_mentions FOR INSERT TO authenticated WITH CHECK ((mentioner_profile_id = ( SELECT auth.uid() AS uid)));


--
-- Name: forum_reports Authenticated users can create reports; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Authenticated users can create reports" ON public.forum_reports FOR INSERT TO authenticated WITH CHECK ((reporter_id = ( SELECT auth.uid() AS uid)));


--
-- Name: forum_tags Authenticated users can create tags; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Authenticated users can create tags" ON public.forum_tags FOR INSERT WITH CHECK ((( SELECT auth.uid() AS uid) IS NOT NULL));


--
-- Name: roles Authenticated users can read roles; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Authenticated users can read roles" ON public.roles FOR SELECT TO authenticated USING (true);


--
-- Name: dynamic_content_translations Authenticated users can read translations; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Authenticated users can read translations" ON public.dynamic_content_translations FOR SELECT TO authenticated USING (true);


--
-- Name: moderation_queue Authenticated users can report content; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Authenticated users can report content" ON public.moderation_queue FOR INSERT WITH CHECK ((auth.uid() = reporter_id));


--
-- Name: forum_poll_votes Authenticated users can vote; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Authenticated users can vote" ON public.forum_poll_votes FOR INSERT TO authenticated WITH CHECK ((profile_id = ( SELECT auth.uid() AS uid)));


--
-- Name: forum_series Authors can create series; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Authors can create series" ON public.forum_series FOR INSERT TO authenticated WITH CHECK ((profile_id = ( SELECT auth.uid() AS uid)));


--
-- Name: forum_series Authors can delete own series; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Authors can delete own series" ON public.forum_series FOR DELETE TO authenticated USING ((profile_id = ( SELECT auth.uid() AS uid)));


--
-- Name: forum_content_experiments Authors can manage their experiments; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Authors can manage their experiments" ON public.forum_content_experiments USING ((EXISTS ( SELECT 1
   FROM public.forum
  WHERE ((forum.id = forum_content_experiments.forum_id) AND (forum.profile_id = ( SELECT auth.uid() AS uid))))));


--
-- Name: forum_series Authors can update own series; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Authors can update own series" ON public.forum_series FOR UPDATE TO authenticated USING ((profile_id = ( SELECT auth.uid() AS uid)));


--
-- Name: forum_author_analytics Authors can view their analytics; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Authors can view their analytics" ON public.forum_author_analytics FOR SELECT USING ((profile_id = ( SELECT auth.uid() AS uid)));


--
-- Name: forum_post_analytics Authors can view their post analytics; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Authors can view their post analytics" ON public.forum_post_analytics FOR SELECT USING ((EXISTS ( SELECT 1
   FROM public.forum
  WHERE ((forum.id = forum_post_analytics.forum_id) AND (forum.profile_id = ( SELECT auth.uid() AS uid))))));


--
-- Name: categories Categories are viewable by everyone; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Categories are viewable by everyone" ON public.categories FOR SELECT USING ((is_active = true));


--
-- Name: community_fridges Community fridges are viewable by everyone; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Community fridges are viewable by everyone" ON public.community_fridges FOR SELECT USING (true);


--
-- Name: forum_conversations Conversation owners can update; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Conversation owners can update" ON public.forum_conversations FOR UPDATE USING ((created_by = ( SELECT auth.uid() AS uid)));


--
-- Name: location_update_queue Enable insert for authenticated users; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Enable insert for authenticated users" ON public.location_update_queue FOR INSERT TO authenticated WITH CHECK (true);


--
-- Name: telegram_user_activity Enable insert for authenticated users; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Enable insert for authenticated users" ON public.telegram_user_activity FOR INSERT TO authenticated WITH CHECK (true);


--
-- Name: forms Enable insert for authenticated users only; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Enable insert for authenticated users only" ON public.forms FOR INSERT WITH CHECK ((( SELECT auth.role() AS role) = 'authenticated'::text));


--
-- Name: address Enable read access for all users; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Enable read access for all users" ON public.address FOR SELECT USING (true);


--
-- Name: challenge_activities Enable read access for all users; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Enable read access for all users" ON public.challenge_activities FOR SELECT USING (true);


--
-- Name: challenges Enable read access for all users; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Enable read access for all users" ON public.challenges FOR SELECT USING (true);


--
-- Name: comments Enable read access for all users; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Enable read access for all users" ON public.comments FOR SELECT USING (true);


--
-- Name: countries Enable read access for all users; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Enable read access for all users" ON public.countries FOR SELECT USING (true);


--
-- Name: forms Enable read access for all users; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Enable read access for all users" ON public.forms FOR SELECT USING (true);


--
-- Name: forum Enable read access for all users; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Enable read access for all users" ON public.forum FOR SELECT USING (true);


--
-- Name: languages Enable read access for all users; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Enable read access for all users" ON public.languages FOR SELECT USING (true);


--
-- Name: reviews Enable read access for all users; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Enable read access for all users" ON public.reviews FOR SELECT USING (true);


--
-- Name: telegram_user_activity Enable read access for all users; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Enable read access for all users" ON public.telegram_user_activity FOR SELECT USING (true);


--
-- Name: views Enable read access for all users; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Enable read access for all users" ON public.views FOR SELECT USING (true);


--
-- Name: location_update_queue Enable read access for authenticated users; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Enable read access for authenticated users" ON public.location_update_queue FOR SELECT TO authenticated USING (true);


--
-- Name: location_update_queue Enable update for authenticated users; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Enable update for authenticated users" ON public.location_update_queue FOR UPDATE TO authenticated USING (true);


--
-- Name: translation_errors Errors readable by authenticated users; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Errors readable by authenticated users" ON public.translation_errors FOR SELECT USING ((( SELECT auth.uid() AS uid) IS NOT NULL));


--
-- Name: organization_members Members can view their organizations or admins all; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Members can view their organizations or admins all" ON public.organization_members FOR SELECT USING (((user_id = auth.uid()) OR public.is_admin()));


--
-- Name: forum_moderator_logs Moderators can create mod logs; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Moderators can create mod logs" ON public.forum_moderator_logs FOR INSERT TO authenticated WITH CHECK ((EXISTS ( SELECT 1
   FROM (public.user_roles ur
     JOIN public.roles r ON ((ur.role_id = r.id)))
  WHERE ((ur.profile_id = ( SELECT auth.uid() AS uid)) AND (r.name = ANY (ARRAY['admin'::text, 'super_admin'::text, 'moderator'::text]))))));


--
-- Name: forum_moderation_notes Moderators can create moderation notes; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Moderators can create moderation notes" ON public.forum_moderation_notes FOR INSERT TO authenticated WITH CHECK (public.is_admin());


--
-- Name: forum_moderation_notes Moderators can update moderation notes; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Moderators can update moderation notes" ON public.forum_moderation_notes FOR UPDATE TO authenticated USING (public.is_admin()) WITH CHECK (public.is_admin());


--
-- Name: forum_moderation_queue Moderators can update queue items; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Moderators can update queue items" ON public.forum_moderation_queue FOR UPDATE TO authenticated USING (public.is_admin()) WITH CHECK (public.is_admin());


--
-- Name: forum_reports Moderators can update reports; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Moderators can update reports" ON public.forum_reports FOR UPDATE TO authenticated USING ((EXISTS ( SELECT 1
   FROM public.profiles
  WHERE (profiles.id = ( SELECT auth.uid() AS uid)))));


--
-- Name: forum_moderator_logs Moderators can view all mod logs; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Moderators can view all mod logs" ON public.forum_moderator_logs FOR SELECT USING (((EXISTS ( SELECT 1
   FROM (public.user_roles ur
     JOIN public.roles r ON ((ur.role_id = r.id)))
  WHERE ((ur.profile_id = auth.uid()) AND (r.name = ANY (ARRAY['admin'::text, 'superadmin'::text, 'moderator'::text]))))) OR public.is_admin()));


--
-- Name: forum_moderation_notes Moderators can view moderation notes; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Moderators can view moderation notes" ON public.forum_moderation_notes FOR SELECT TO authenticated USING (public.is_admin());


--
-- Name: forum_moderation_queue Moderators can view moderation queue; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Moderators can view moderation queue" ON public.forum_moderation_queue FOR SELECT TO authenticated USING (public.is_admin());


--
-- Name: forum_moderation_stats Moderators can view moderation stats; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Moderators can view moderation stats" ON public.forum_moderation_stats FOR SELECT TO authenticated USING (public.is_admin());


--
-- Name: posts_image_backup Only authenticated users can view image backups; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Only authenticated users can view image backups" ON public.posts_image_backup FOR SELECT USING ((( SELECT auth.uid() AS uid) IS NOT NULL));


--
-- Name: orphaned_storage_cleanup Only service role can access orphaned_storage_cleanup; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Only service role can access orphaned_storage_cleanup" ON public.orphaned_storage_cleanup USING (false) WITH CHECK (false);


--
-- Name: rooms Participants can create rooms; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Participants can create rooms" ON public.rooms FOR INSERT WITH CHECK (((sharer = ( SELECT auth.uid() AS uid)) OR (requester = ( SELECT auth.uid() AS uid))));


--
-- Name: forum_messages Participants can send messages; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Participants can send messages" ON public.forum_messages FOR INSERT WITH CHECK (((sender_id = ( SELECT auth.uid() AS uid)) AND (EXISTS ( SELECT 1
   FROM public.forum_conversation_participants
  WHERE ((forum_conversation_participants.conversation_id = forum_messages.conversation_id) AND (forum_conversation_participants.profile_id = ( SELECT auth.uid() AS uid)))))));


--
-- Name: room_participants Participants can send messages; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Participants can send messages" ON public.room_participants FOR INSERT WITH CHECK ((( SELECT auth.uid() AS uid) = profile_id));


--
-- Name: rooms Participants can update rooms; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Participants can update rooms" ON public.rooms FOR UPDATE USING (((sharer = ( SELECT auth.uid() AS uid)) OR (requester = ( SELECT auth.uid() AS uid))));


--
-- Name: forum_conversation_participants Participants can view conversation members; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Participants can view conversation members" ON public.forum_conversation_participants FOR SELECT USING ((EXISTS ( SELECT 1
   FROM public.forum_conversation_participants fcp
  WHERE ((fcp.conversation_id = forum_conversation_participants.conversation_id) AND (fcp.profile_id = ( SELECT auth.uid() AS uid))))));


--
-- Name: forum_messages Participants can view messages; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Participants can view messages" ON public.forum_messages FOR SELECT USING ((EXISTS ( SELECT 1
   FROM public.forum_conversation_participants
  WHERE ((forum_conversation_participants.conversation_id = forum_messages.conversation_id) AND (forum_conversation_participants.profile_id = ( SELECT auth.uid() AS uid))))));


--
-- Name: room_participants Participants can view messages; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Participants can view messages" ON public.room_participants FOR SELECT USING ((( SELECT auth.uid() AS uid) = profile_id));


--
-- Name: rooms Participants can view rooms; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Participants can view rooms" ON public.rooms FOR SELECT USING (((sharer = ( SELECT auth.uid() AS uid)) OR (requester = ( SELECT auth.uid() AS uid))));


--
-- Name: forum_polls Post author can create polls; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Post author can create polls" ON public.forum_polls FOR INSERT TO authenticated WITH CHECK ((EXISTS ( SELECT 1
   FROM public.forum
  WHERE ((forum.id = forum_polls.forum_id) AND (forum.profile_id = ( SELECT auth.uid() AS uid))))));


--
-- Name: forum_polls Post author can delete polls; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Post author can delete polls" ON public.forum_polls FOR DELETE TO authenticated USING ((EXISTS ( SELECT 1
   FROM public.forum
  WHERE ((forum.id = forum_polls.forum_id) AND (forum.profile_id = ( SELECT auth.uid() AS uid))))));


--
-- Name: forum_polls Post author can update polls; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Post author can update polls" ON public.forum_polls FOR UPDATE TO authenticated USING ((EXISTS ( SELECT 1
   FROM public.forum
  WHERE ((forum.id = forum_polls.forum_id) AND (forum.profile_id = ( SELECT auth.uid() AS uid))))));


--
-- Name: email_templates Public read for active templates; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Public read for active templates" ON public.email_templates FOR SELECT USING ((is_active = true));


--
-- Name: translation_change_log Public read on change log; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Public read on change log" ON public.translation_change_log FOR SELECT USING (true);


--
-- Name: content_translations Public read translations; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Public read translations" ON public.content_translations FOR SELECT TO authenticated, anon USING (true);


--
-- Name: forum_messages Senders can edit their messages; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Senders can edit their messages" ON public.forum_messages FOR UPDATE USING ((sender_id = ( SELECT auth.uid() AS uid)));


--
-- Name: image_upload_metrics Service can insert metrics; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Service can insert metrics" ON public.image_upload_metrics FOR INSERT WITH CHECK (true);


--
-- Name: email_templates Service role bypass for email templates; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Service role bypass for email templates" ON public.email_templates USING ((auth.role() = 'service_role'::text));


--
-- Name: email_template_versions Service role bypass for template versions; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Service role bypass for template versions" ON public.email_template_versions USING ((auth.role() = 'service_role'::text));


--
-- Name: audit_logs Service role can insert audit logs; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Service role can insert audit logs" ON public.audit_logs FOR INSERT WITH CHECK (true);


--
-- Name: email_logs Service role can insert email logs; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Service role can insert email logs" ON public.email_logs FOR INSERT TO service_role WITH CHECK (true);


--
-- Name: in_app_notifications Service role can insert in-app notifications; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Service role can insert in-app notifications" ON public.in_app_notifications FOR INSERT WITH CHECK (((auth.jwt() ->> 'role'::text) = 'service_role'::text));


--
-- Name: user_notifications Service role can insert notifications; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Service role can insert notifications" ON public.user_notifications FOR INSERT TO authenticated WITH CHECK (true);


--
-- Name: translation_change_log Service role can insert translation_change_log; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Service role can insert translation_change_log" ON public.translation_change_log FOR INSERT TO service_role WITH CHECK (true);


--
-- Name: translation_versions Service role can insert translation_versions; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Service role can insert translation_versions" ON public.translation_versions FOR INSERT TO service_role WITH CHECK (true);


--
-- Name: translations Service role can insert translations; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Service role can insert translations" ON public.translations FOR INSERT TO service_role WITH CHECK (true);


--
-- Name: device_attestations Service role can manage attestations; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Service role can manage attestations" ON public.device_attestations TO service_role USING (true) WITH CHECK (true);


--
-- Name: email_circuit_breaker_state Service role can manage circuit breaker state; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Service role can manage circuit breaker state" ON public.email_circuit_breaker_state TO service_role USING (true) WITH CHECK (true);


--
-- Name: compressed_images Service role can manage compressed_images; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Service role can manage compressed_images" ON public.compressed_images TO service_role USING (true) WITH CHECK (true);


--
-- Name: app_config Service role can manage config; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Service role can manage config" ON public.app_config TO service_role USING (true);


--
-- Name: notification_digest_queue Service role can manage digest queue; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Service role can manage digest queue" ON public.notification_digest_queue USING (((auth.jwt() ->> 'role'::text) = 'service_role'::text)) WITH CHECK (((auth.jwt() ->> 'role'::text) = 'service_role'::text));


--
-- Name: email_queue Service role can manage email queue; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Service role can manage email queue" ON public.email_queue TO service_role USING (true) WITH CHECK (true);


--
-- Name: email_suppressions Service role can manage email suppressions; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Service role can manage email suppressions" ON public.email_suppressions USING (((auth.jwt() ->> 'role'::text) = 'service_role'::text)) WITH CHECK (((auth.jwt() ->> 'role'::text) = 'service_role'::text));


--
-- Name: email_health_events Service role can manage health events; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Service role can manage health events" ON public.email_health_events TO service_role USING (true) WITH CHECK (true);


--
-- Name: email_provider_health_history Service role can manage health history; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Service role can manage health history" ON public.email_provider_health_history TO service_role USING (true) WITH CHECK (true);


--
-- Name: image_compressions Service role can manage image_compressions; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Service role can manage image_compressions" ON public.image_compressions TO service_role USING (true) WITH CHECK (true);


--
-- Name: email_provider_metrics Service role can manage metrics; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Service role can manage metrics" ON public.email_provider_metrics TO service_role USING (true) WITH CHECK (true);


--
-- Name: notification_delivery_log Service role can manage notification logs; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Service role can manage notification logs" ON public.notification_delivery_log USING (((auth.jwt() ->> 'role'::text) = 'service_role'::text)) WITH CHECK (((auth.jwt() ->> 'role'::text) = 'service_role'::text));


--
-- Name: notification_queue Service role can manage notification queue; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Service role can manage notification queue" ON public.notification_queue USING (((auth.jwt() ->> 'role'::text) = 'service_role'::text)) WITH CHECK (((auth.jwt() ->> 'role'::text) = 'service_role'::text));


--
-- Name: email_provider_quota Service role can manage quota data; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Service role can manage quota data" ON public.email_provider_quota TO service_role USING (true) WITH CHECK (true);


--
-- Name: content_translations Service role can manage translations; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Service role can manage translations" ON public.content_translations TO service_role USING (true) WITH CHECK (true);


--
-- Name: email_logs Service role can update email logs; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Service role can update email logs" ON public.email_logs FOR UPDATE TO service_role USING (true) WITH CHECK (true);


--
-- Name: translations Service role can update translations; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Service role can update translations" ON public.translations FOR UPDATE TO service_role USING (true) WITH CHECK (true);


--
-- Name: display_name_overrides Service role full access; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Service role full access" ON public.display_name_overrides TO service_role USING (true) WITH CHECK (true);


--
-- Name: email_audit_log Service role full access; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Service role full access" ON public.email_audit_log TO service_role USING (true) WITH CHECK (true);


--
-- Name: notification_preferences Service role full access; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Service role full access" ON public.notification_preferences TO service_role USING (true) WITH CHECK (true);


--
-- Name: translation_queue Service role full access; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Service role full access" ON public.translation_queue USING ((auth.role() = 'service_role'::text));


--
-- Name: user_events_2025_12 Service role full access; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Service role full access" ON public.user_events_2025_12 TO service_role USING (true) WITH CHECK (true);


--
-- Name: user_events_2026_01 Service role full access; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Service role full access" ON public.user_events_2026_01 TO service_role USING (true) WITH CHECK (true);


--
-- Name: user_events_2026_02 Service role full access; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Service role full access" ON public.user_events_2026_02 TO service_role USING (true) WITH CHECK (true);


--
-- Name: email_bounce_events Service role full access on bounce events; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Service role full access on bounce events" ON public.email_bounce_events USING (true) WITH CHECK (true);


--
-- Name: email_provider_monthly_quota Service role full access on monthly quota; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Service role full access on monthly quota" ON public.email_provider_monthly_quota USING (true) WITH CHECK (true);


--
-- Name: email_suppression_list Service role full access on suppression list; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Service role full access on suppression list" ON public.email_suppression_list USING (true) WITH CHECK (true);


--
-- Name: email_delivery_log Service role full access to delivery logs; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Service role full access to delivery logs" ON public.email_delivery_log TO service_role USING (true) WITH CHECK (true);


--
-- Name: notification_digest_queue Service role full access to digest queue; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Service role full access to digest queue" ON public.notification_digest_queue TO service_role USING (true) WITH CHECK (true);


--
-- Name: experiment_assignments Service role full access to experiment_assignments; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Service role full access to experiment_assignments" ON public.experiment_assignments TO service_role USING (true) WITH CHECK (true);


--
-- Name: experiments Service role full access to experiments; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Service role full access to experiments" ON public.experiments TO service_role USING (true) WITH CHECK (true);


--
-- Name: feature_flag_overrides Service role full access to feature_flag_overrides; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Service role full access to feature_flag_overrides" ON public.feature_flag_overrides TO service_role USING (true) WITH CHECK (true);


--
-- Name: email_provider_health_metrics Service role full access to health metrics; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Service role full access to health metrics" ON public.email_provider_health_metrics TO service_role USING (true) WITH CHECK (true);


--
-- Name: location_update_queue Service role full access to location_update_queue; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Service role full access to location_update_queue" ON public.location_update_queue TO service_role USING (true) WITH CHECK (true);


--
-- Name: notification_queue Service role full access to notification_queue; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Service role full access to notification_queue" ON public.notification_queue TO service_role USING (true) WITH CHECK (true);


--
-- Name: pending_operations Service role full access to pending_operations; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Service role full access to pending_operations" ON public.pending_operations TO service_role USING (true) WITH CHECK (true);


--
-- Name: notification_settings Service role full access to settings; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Service role full access to settings" ON public.notification_settings TO service_role USING (true) WITH CHECK (true);


--
-- Name: sync_checkpoints Service role full access to sync_checkpoints; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Service role full access to sync_checkpoints" ON public.sync_checkpoints TO service_role USING (true) WITH CHECK (true);


--
-- Name: user_activity_summary Service role full access to user_activity_summary; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Service role full access to user_activity_summary" ON public.user_activity_summary TO service_role USING (true) WITH CHECK (true);


--
-- Name: user_events Service role full access to user_events; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Service role full access to user_events" ON public.user_events TO service_role USING (true) WITH CHECK (true);


--
-- Name: translation_usage_analytics Service role has full access to analytics; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Service role has full access to analytics" ON public.translation_usage_analytics TO service_role USING (true) WITH CHECK (true);


--
-- Name: dynamic_content_translations Service role has full access to translations; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Service role has full access to translations" ON public.dynamic_content_translations TO service_role USING (true) WITH CHECK (true);


--
-- Name: legal_documents Service role manages legal documents; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Service role manages legal documents" ON public.legal_documents TO service_role USING (true);


--
-- Name: api_analytics Service role only for api_analytics; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Service role only for api_analytics" ON public.api_analytics USING (false);


--
-- Name: forum_activities System can create activities; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "System can create activities" ON public.forum_activities FOR INSERT WITH CHECK ((profile_id = ( SELECT auth.uid() AS uid)));


--
-- Name: forum_notifications System can create forum notifications; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "System can create forum notifications" ON public.forum_notifications FOR INSERT TO authenticated WITH CHECK (true);


--
-- Name: forum_comment_history System can insert comment history; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "System can insert comment history" ON public.forum_comment_history FOR INSERT TO authenticated WITH CHECK (true);


--
-- Name: forum_post_history System can insert post history; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "System can insert post history" ON public.forum_post_history FOR INSERT TO authenticated WITH CHECK (true);


--
-- Name: mfa_verification_attempts System can manage MFA attempts; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "System can manage MFA attempts" ON public.mfa_verification_attempts USING ((profile_id = ( SELECT auth.uid() AS uid)));


--
-- Name: forum_user_stats System can manage forum user stats; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "System can manage forum user stats" ON public.forum_user_stats TO authenticated USING (true) WITH CHECK (true);


--
-- Name: forum_rate_limits System can manage rate limits; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "System can manage rate limits" ON public.forum_rate_limits USING ((profile_id = ( SELECT auth.uid() AS uid)));


--
-- Name: rate_limits System can manage rate limits; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "System can manage rate limits" ON public.rate_limits USING ((( SELECT auth.uid() AS uid) IS NOT NULL));


--
-- Name: telegram_user_states System can manage telegram states; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "System can manage telegram states" ON public.telegram_user_states USING ((( SELECT auth.uid() AS uid) IS NOT NULL));


--
-- Name: forum_user_badges System can manage user badges; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "System can manage user badges" ON public.forum_user_badges FOR INSERT TO authenticated WITH CHECK (true);


--
-- Name: translations Translations are publicly readable; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Translations are publicly readable" ON public.translations FOR SELECT USING (true);


--
-- Name: room_participants User can remove themselves from room; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "User can remove themselves from room" ON public.room_participants FOR DELETE USING ((( SELECT auth.uid() AS uid) = profile_id));


--
-- Name: challenge_participants Users can accept challenges; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Users can accept challenges" ON public.challenge_participants FOR INSERT TO authenticated WITH CHECK ((( SELECT auth.uid() AS uid) = profile_id));


--
-- Name: forum_search_history Users can add to search history; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Users can add to search history" ON public.forum_search_history FOR INSERT TO authenticated WITH CHECK ((profile_id = ( SELECT auth.uid() AS uid)));


--
-- Name: blocked_users Users can block other users; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Users can block other users" ON public.blocked_users FOR INSERT WITH CHECK (((auth.uid() = user_id) AND (user_id <> blocked_user_id)));


--
-- Name: forum_user_blocks Users can block others; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Users can block others" ON public.forum_user_blocks FOR INSERT WITH CHECK ((( SELECT auth.uid() AS uid) = blocker_id));


--
-- Name: forum_search_history Users can clear own search history; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Users can clear own search history" ON public.forum_search_history FOR DELETE TO authenticated USING ((profile_id = ( SELECT auth.uid() AS uid)));


--
-- Name: challenge_activities Users can create challenge activities; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Users can create challenge activities" ON public.challenge_activities FOR INSERT WITH CHECK (((user_accepted_challenge = ( SELECT auth.uid() AS uid)) OR (user_completed_challenge = ( SELECT auth.uid() AS uid)) OR (user_rejected_challenge = ( SELECT auth.uid() AS uid))));


--
-- Name: forum_bookmark_collections Users can create collections; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Users can create collections" ON public.forum_bookmark_collections FOR INSERT WITH CHECK ((( SELECT auth.uid() AS uid) = profile_id));


--
-- Name: comments Users can create comments; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Users can create comments" ON public.comments FOR INSERT WITH CHECK ((user_id = ( SELECT auth.uid() AS uid)));


--
-- Name: forum_conversations Users can create conversations; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Users can create conversations" ON public.forum_conversations FOR INSERT WITH CHECK ((created_by = ( SELECT auth.uid() AS uid)));


--
-- Name: forum Users can create forum posts; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Users can create forum posts" ON public.forum FOR INSERT WITH CHECK ((profile_id = ( SELECT auth.uid() AS uid)));


--
-- Name: forum_drafts Users can create own drafts; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Users can create own drafts" ON public.forum_drafts FOR INSERT TO authenticated WITH CHECK ((profile_id = ( SELECT auth.uid() AS uid)));


--
-- Name: forum_user_follows Users can create own follows; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Users can create own follows" ON public.forum_user_follows FOR INSERT TO authenticated WITH CHECK ((follower_id = ( SELECT auth.uid() AS uid)));


--
-- Name: forum_subscriptions Users can create own subscriptions; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Users can create own subscriptions" ON public.forum_subscriptions FOR INSERT TO authenticated WITH CHECK ((profile_id = ( SELECT auth.uid() AS uid)));


--
-- Name: post_reports Users can create reports; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Users can create reports" ON public.post_reports FOR INSERT TO authenticated WITH CHECK ((( SELECT auth.uid() AS uid) = reporter_id));


--
-- Name: reports Users can create reports; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Users can create reports" ON public.reports FOR INSERT WITH CHECK ((profile_id = ( SELECT auth.uid() AS uid)));


--
-- Name: reviews Users can create reviews; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Users can create reviews" ON public.reviews FOR INSERT WITH CHECK ((profile_id = ( SELECT auth.uid() AS uid)));


--
-- Name: forum_saved_searches Users can create saved searches; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Users can create saved searches" ON public.forum_saved_searches FOR INSERT TO authenticated WITH CHECK ((profile_id = ( SELECT auth.uid() AS uid)));


--
-- Name: user_addresses Users can delete own address; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Users can delete own address" ON public.user_addresses FOR DELETE USING ((profile_id = auth.uid()));


--
-- Name: forum_drafts Users can delete own drafts; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Users can delete own drafts" ON public.forum_drafts FOR DELETE TO authenticated USING ((profile_id = ( SELECT auth.uid() AS uid)));


--
-- Name: forum_user_follows Users can delete own follows; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Users can delete own follows" ON public.forum_user_follows FOR DELETE TO authenticated USING ((follower_id = ( SELECT auth.uid() AS uid)));


--
-- Name: forum_notifications Users can delete own forum notifications; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Users can delete own forum notifications" ON public.forum_notifications FOR DELETE TO authenticated USING ((recipient_id = ( SELECT auth.uid() AS uid)));


--
-- Name: handlers Users can delete own handlers; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Users can delete own handlers" ON public.handlers FOR DELETE USING ((profile_id = ( SELECT auth.uid() AS uid)));


--
-- Name: forum_mentions Users can delete own mentions; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Users can delete own mentions" ON public.forum_mentions FOR DELETE TO authenticated USING ((mentioner_profile_id = ( SELECT auth.uid() AS uid)));


--
-- Name: user_notifications Users can delete own notifications; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Users can delete own notifications" ON public.user_notifications FOR DELETE USING ((recipient_id = ( SELECT auth.uid() AS uid)));


--
-- Name: forum_reading_history Users can delete own reading history; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Users can delete own reading history" ON public.forum_reading_history FOR DELETE TO authenticated USING ((profile_id = ( SELECT auth.uid() AS uid)));


--
-- Name: forum_saved_searches Users can delete own saved searches; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Users can delete own saved searches" ON public.forum_saved_searches FOR DELETE TO authenticated USING ((profile_id = ( SELECT auth.uid() AS uid)));


--
-- Name: forum_subscriptions Users can delete own subscriptions; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Users can delete own subscriptions" ON public.forum_subscriptions FOR DELETE TO authenticated USING ((profile_id = ( SELECT auth.uid() AS uid)));


--
-- Name: forum_bookmark_collections Users can delete their collections; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Users can delete their collections" ON public.forum_bookmark_collections FOR DELETE USING ((( SELECT auth.uid() AS uid) = profile_id));


--
-- Name: device_tokens Users can delete their own device tokens; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Users can delete their own device tokens" ON public.device_tokens FOR DELETE USING ((( SELECT auth.uid() AS uid) = profile_id));


--
-- Name: challenge_participants Users can delete their own participation; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Users can delete their own participation" ON public.challenge_participants FOR DELETE TO authenticated USING ((( SELECT auth.uid() AS uid) = profile_id));


--
-- Name: forum_user_badges Users can feature own badges; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Users can feature own badges" ON public.forum_user_badges FOR UPDATE TO authenticated USING ((profile_id = ( SELECT auth.uid() AS uid)));


--
-- Name: user_addresses Users can insert own address; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Users can insert own address" ON public.user_addresses FOR INSERT WITH CHECK ((profile_id = auth.uid()));


--
-- Name: user_events Users can insert own events; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Users can insert own events" ON public.user_events FOR INSERT TO authenticated WITH CHECK ((user_id = ( SELECT auth.uid() AS uid)));


--
-- Name: handlers Users can insert own handlers; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Users can insert own handlers" ON public.handlers FOR INSERT WITH CHECK ((profile_id = ( SELECT auth.uid() AS uid)));


--
-- Name: user_locale_preferences Users can insert own locale preferences; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Users can insert own locale preferences" ON public.user_locale_preferences FOR INSERT WITH CHECK ((user_id = ( SELECT auth.uid() AS uid)));


--
-- Name: notification_preferences Users can insert own notification preferences; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Users can insert own notification preferences" ON public.notification_preferences FOR INSERT TO authenticated WITH CHECK ((auth.uid() = user_id));


--
-- Name: user_preferences Users can insert own preferences; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Users can insert own preferences" ON public.user_preferences FOR INSERT TO authenticated WITH CHECK ((profile_id = ( SELECT auth.uid() AS uid)));


--
-- Name: profile_stats Users can insert own profile stats; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Users can insert own profile stats" ON public.profile_stats FOR INSERT WITH CHECK ((( SELECT auth.uid() AS uid) = profile_id));


--
-- Name: forum_reading_history Users can insert own reading history; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Users can insert own reading history" ON public.forum_reading_history FOR INSERT TO authenticated WITH CHECK ((profile_id = ( SELECT auth.uid() AS uid)));


--
-- Name: forum_reading_progress Users can insert own reading progress; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Users can insert own reading progress" ON public.forum_reading_progress FOR INSERT TO authenticated WITH CHECK ((profile_id = ( SELECT auth.uid() AS uid)));


--
-- Name: device_tokens Users can insert their own device tokens; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Users can insert their own device tokens" ON public.device_tokens FOR INSERT WITH CHECK ((( SELECT auth.uid() AS uid) = profile_id));


--
-- Name: email_preferences Users can insert their own email preferences; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Users can insert their own email preferences" ON public.email_preferences FOR INSERT TO authenticated WITH CHECK ((( SELECT auth.uid() AS uid) = profile_id));


--
-- Name: views Users can insert views; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Users can insert views" ON public.views FOR INSERT TO authenticated WITH CHECK (true);


--
-- Name: forum_conversation_participants Users can join conversations they're invited to; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Users can join conversations they're invited to" ON public.forum_conversation_participants FOR INSERT WITH CHECK ((profile_id = ( SELECT auth.uid() AS uid)));


--
-- Name: forum_feed_preferences Users can manage their feed preferences; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Users can manage their feed preferences" ON public.forum_feed_preferences USING ((profile_id = ( SELECT auth.uid() AS uid)));


--
-- Name: forum_feed_read_status Users can manage their read status; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Users can manage their read status" ON public.forum_feed_read_status USING ((profile_id = ( SELECT auth.uid() AS uid)));


--
-- Name: forum_recurring_posts Users can manage their recurring posts; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Users can manage their recurring posts" ON public.forum_recurring_posts USING ((profile_id = ( SELECT auth.uid() AS uid)));


--
-- Name: forum_scheduled_posts Users can manage their scheduled posts; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Users can manage their scheduled posts" ON public.forum_scheduled_posts USING ((profile_id = ( SELECT auth.uid() AS uid)));


--
-- Name: forum_message_read_receipts Users can mark messages as read; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Users can mark messages as read" ON public.forum_message_read_receipts FOR INSERT WITH CHECK ((profile_id = ( SELECT auth.uid() AS uid)));


--
-- Name: forum_message_reactions Users can react to messages; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Users can react to messages" ON public.forum_message_reactions FOR INSERT WITH CHECK ((profile_id = ( SELECT auth.uid() AS uid)));


--
-- Name: mfa_configuration Users can read own MFA config or admins all; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Users can read own MFA config or admins all" ON public.mfa_configuration FOR SELECT USING (((profile_id = ( SELECT auth.uid() AS uid)) OR public.is_admin_jsonb()));


--
-- Name: mfa_sessions Users can read own MFA sessions or admins all; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Users can read own MFA sessions or admins all" ON public.mfa_sessions FOR SELECT USING (((profile_id = ( SELECT auth.uid() AS uid)) OR public.is_admin_jsonb()));


--
-- Name: user_addresses Users can read own address; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Users can read own address" ON public.user_addresses FOR SELECT USING ((profile_id = auth.uid()));


--
-- Name: email_audit_log Users can read own audit events; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Users can read own audit events" ON public.email_audit_log FOR SELECT TO authenticated USING (((user_id = auth.uid()) OR (target_user_id = auth.uid())));


--
-- Name: forum_notifications Users can read own forum notifications; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Users can read own forum notifications" ON public.forum_notifications FOR SELECT TO authenticated USING ((recipient_id = ( SELECT auth.uid() AS uid)));


--
-- Name: user_locale_preferences Users can read own locale preferences; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Users can read own locale preferences" ON public.user_locale_preferences FOR SELECT USING ((user_id = ( SELECT auth.uid() AS uid)));


--
-- Name: notification_preferences Users can read own notification preferences; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Users can read own notification preferences" ON public.notification_preferences FOR SELECT TO authenticated USING ((auth.uid() = user_id));


--
-- Name: notification_settings Users can read own notification settings; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Users can read own notification settings" ON public.notification_settings FOR SELECT TO authenticated USING ((auth.uid() = user_id));


--
-- Name: user_roles Users can read own roles; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Users can read own roles" ON public.user_roles FOR SELECT USING ((profile_id = auth.uid()));


--
-- Name: email_preferences Users can read their own email preferences; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Users can read their own email preferences" ON public.email_preferences FOR SELECT TO authenticated USING ((( SELECT auth.uid() AS uid) = profile_id));


--
-- Name: forum_announcement_analytics Users can record analytics; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Users can record analytics" ON public.forum_announcement_analytics FOR INSERT TO authenticated WITH CHECK (true);


--
-- Name: forum_reactions Users can remove own reactions; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Users can remove own reactions" ON public.forum_reactions FOR DELETE TO authenticated USING ((profile_id = ( SELECT auth.uid() AS uid)));


--
-- Name: forum_comment_reactions Users can remove their own reactions; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Users can remove their own reactions" ON public.forum_comment_reactions FOR DELETE TO authenticated USING ((( SELECT auth.uid() AS uid) = profile_id));


--
-- Name: forum_message_reactions Users can remove their reactions; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Users can remove their reactions" ON public.forum_message_reactions FOR DELETE USING ((profile_id = ( SELECT auth.uid() AS uid)));


--
-- Name: forum_poll_votes Users can remove their votes; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Users can remove their votes" ON public.forum_poll_votes FOR DELETE TO authenticated USING ((profile_id = ( SELECT auth.uid() AS uid)));


--
-- Name: forum_moderation_queue Users can report content; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Users can report content" ON public.forum_moderation_queue FOR INSERT TO authenticated WITH CHECK ((( SELECT auth.uid() AS uid) = reporter_id));


--
-- Name: organizations Users can see own organizations or admins all; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Users can see own organizations or admins all" ON public.organizations FOR SELECT USING (((EXISTS ( SELECT 1
   FROM public.organization_members
  WHERE ((organization_members.organization_id = organizations.id) AND (organization_members.user_id = ( SELECT auth.uid() AS uid))))) OR public.is_admin_jsonb()));


--
-- Name: forum_user_blocks Users can unblock; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Users can unblock" ON public.forum_user_blocks FOR DELETE USING ((( SELECT auth.uid() AS uid) = blocker_id));


--
-- Name: blocked_users Users can unblock users; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Users can unblock users" ON public.blocked_users FOR DELETE USING ((auth.uid() = user_id));


--
-- Name: mfa_configuration Users can update own MFA configuration; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Users can update own MFA configuration" ON public.mfa_configuration FOR UPDATE USING ((profile_id = ( SELECT auth.uid() AS uid)));


--
-- Name: challenge_activities Users can update own activities; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Users can update own activities" ON public.challenge_activities FOR UPDATE USING (((user_accepted_challenge = ( SELECT auth.uid() AS uid)) OR (user_completed_challenge = ( SELECT auth.uid() AS uid)) OR (user_rejected_challenge = ( SELECT auth.uid() AS uid))));


--
-- Name: user_addresses Users can update own address; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Users can update own address" ON public.user_addresses FOR UPDATE USING ((profile_id = auth.uid()));


--
-- Name: forum_drafts Users can update own drafts; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Users can update own drafts" ON public.forum_drafts FOR UPDATE TO authenticated USING ((profile_id = ( SELECT auth.uid() AS uid)));


--
-- Name: forum_notifications Users can update own forum notifications; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Users can update own forum notifications" ON public.forum_notifications FOR UPDATE TO authenticated USING ((recipient_id = ( SELECT auth.uid() AS uid)));


--
-- Name: handlers Users can update own handlers; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Users can update own handlers" ON public.handlers FOR UPDATE USING ((profile_id = ( SELECT auth.uid() AS uid)));


--
-- Name: user_locale_preferences Users can update own locale preferences; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Users can update own locale preferences" ON public.user_locale_preferences FOR UPDATE USING ((user_id = ( SELECT auth.uid() AS uid)));


--
-- Name: room_participants Users can update own messages; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Users can update own messages" ON public.room_participants FOR UPDATE USING ((( SELECT auth.uid() AS uid) = profile_id));


--
-- Name: notification_preferences Users can update own notification preferences; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Users can update own notification preferences" ON public.notification_preferences FOR UPDATE TO authenticated USING ((auth.uid() = user_id)) WITH CHECK ((auth.uid() = user_id));


--
-- Name: notifications Users can update own notifications; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Users can update own notifications" ON public.notifications FOR UPDATE TO authenticated USING ((( SELECT auth.uid() AS uid) = profile_id));


--
-- Name: user_notifications Users can update own notifications; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Users can update own notifications" ON public.user_notifications FOR UPDATE USING ((recipient_id = ( SELECT auth.uid() AS uid)));


--
-- Name: user_preferences Users can update own preferences; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Users can update own preferences" ON public.user_preferences FOR UPDATE TO authenticated USING ((profile_id = ( SELECT auth.uid() AS uid))) WITH CHECK ((profile_id = ( SELECT auth.uid() AS uid)));


--
-- Name: profile_stats Users can update own profile stats; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Users can update own profile stats" ON public.profile_stats FOR UPDATE USING ((( SELECT auth.uid() AS uid) = profile_id));


--
-- Name: forum_reading_progress Users can update own reading progress; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Users can update own reading progress" ON public.forum_reading_progress FOR UPDATE TO authenticated USING ((profile_id = ( SELECT auth.uid() AS uid)));


--
-- Name: reviews Users can update own reviews; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Users can update own reviews" ON public.reviews FOR UPDATE USING ((profile_id = ( SELECT auth.uid() AS uid)));


--
-- Name: forum_saved_searches Users can update own saved searches; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Users can update own saved searches" ON public.forum_saved_searches FOR UPDATE TO authenticated USING ((profile_id = ( SELECT auth.uid() AS uid)));


--
-- Name: forum_subscriptions Users can update own subscriptions; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Users can update own subscriptions" ON public.forum_subscriptions FOR UPDATE TO authenticated USING ((profile_id = ( SELECT auth.uid() AS uid)));


--
-- Name: translation_sync_status Users can update own sync status; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Users can update own sync status" ON public.translation_sync_status USING ((user_id = ( SELECT auth.uid() AS uid)));


--
-- Name: forum_bookmark_collections Users can update their collections; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Users can update their collections" ON public.forum_bookmark_collections FOR UPDATE USING ((( SELECT auth.uid() AS uid) = profile_id));


--
-- Name: device_tokens Users can update their own device tokens; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Users can update their own device tokens" ON public.device_tokens FOR UPDATE USING ((( SELECT auth.uid() AS uid) = profile_id));


--
-- Name: email_preferences Users can update their own email preferences; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Users can update their own email preferences" ON public.email_preferences FOR UPDATE TO authenticated USING ((( SELECT auth.uid() AS uid) = profile_id));


--
-- Name: in_app_notifications Users can update their own in-app notifications; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Users can update their own in-app notifications" ON public.in_app_notifications FOR UPDATE USING ((auth.uid() = user_id)) WITH CHECK ((auth.uid() = user_id));


--
-- Name: challenge_participants Users can update their own participation; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Users can update their own participation" ON public.challenge_participants FOR UPDATE TO authenticated USING ((( SELECT auth.uid() AS uid) = profile_id));


--
-- Name: forum_conversation_participants Users can update their own participation; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Users can update their own participation" ON public.forum_conversation_participants FOR UPDATE USING ((profile_id = ( SELECT auth.uid() AS uid)));


--
-- Name: notification_settings Users can upsert own notification settings; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Users can upsert own notification settings" ON public.notification_settings TO authenticated USING ((auth.uid() = user_id)) WITH CHECK ((auth.uid() = user_id));


--
-- Name: forum_announcements Users can view active announcements; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Users can view active announcements" ON public.forum_announcements FOR SELECT TO authenticated USING (((is_active = true) AND (is_published = true) AND (starts_at <= now()) AND ((ends_at IS NULL) OR (ends_at > now()))));


--
-- Name: experiments Users can view active experiments; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Users can view active experiments" ON public.experiments FOR SELECT USING ((status = 'running'::text));


--
-- Name: challenge_participants Users can view all participants; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Users can view all participants" ON public.challenge_participants FOR SELECT USING (true);


--
-- Name: profile_stats Users can view all profile stats; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Users can view all profile stats" ON public.profile_stats FOR SELECT USING (true);


--
-- Name: forum_message_reactions Users can view message reactions; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Users can view message reactions" ON public.forum_message_reactions FOR SELECT USING ((EXISTS ( SELECT 1
   FROM (public.forum_messages fm
     JOIN public.forum_conversation_participants fcp ON ((fcp.conversation_id = fm.conversation_id)))
  WHERE ((fm.id = forum_message_reactions.message_id) AND (fcp.profile_id = ( SELECT auth.uid() AS uid))))));


--
-- Name: email_delivery_log Users can view own delivery logs; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Users can view own delivery logs" ON public.email_delivery_log FOR SELECT TO authenticated USING ((user_id = auth.uid()));


--
-- Name: forum_drafts Users can view own drafts; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Users can view own drafts" ON public.forum_drafts FOR SELECT TO authenticated USING ((profile_id = ( SELECT auth.uid() AS uid)));


--
-- Name: user_events Users can view own events; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Users can view own events" ON public.user_events FOR SELECT TO authenticated USING ((user_id = ( SELECT auth.uid() AS uid)));


--
-- Name: image_upload_metrics Users can view own metrics; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Users can view own metrics" ON public.image_upload_metrics FOR SELECT USING ((auth.uid() = user_id));


--
-- Name: notification_queue Users can view own notifications; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Users can view own notifications" ON public.notification_queue FOR SELECT TO authenticated USING ((user_id = ( SELECT auth.uid() AS uid)));


--
-- Name: notifications Users can view own notifications; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Users can view own notifications" ON public.notifications FOR SELECT TO authenticated USING ((( SELECT auth.uid() AS uid) = profile_id));


--
-- Name: user_notifications Users can view own notifications; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Users can view own notifications" ON public.user_notifications FOR SELECT USING ((recipient_id = ( SELECT auth.uid() AS uid)));


--
-- Name: display_name_overrides Users can view own override; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Users can view own override" ON public.display_name_overrides FOR SELECT TO authenticated USING ((user_id = auth.uid()));


--
-- Name: user_preferences Users can view own preferences; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Users can view own preferences" ON public.user_preferences FOR SELECT TO authenticated USING ((profile_id = ( SELECT auth.uid() AS uid)));


--
-- Name: user_rate_limits Users can view own rate limits; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Users can view own rate limits" ON public.user_rate_limits FOR SELECT USING ((auth.uid() = user_id));


--
-- Name: forum_reading_history Users can view own reading history; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Users can view own reading history" ON public.forum_reading_history FOR SELECT TO authenticated USING ((profile_id = ( SELECT auth.uid() AS uid)));


--
-- Name: forum_reading_progress Users can view own reading progress; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Users can view own reading progress" ON public.forum_reading_progress FOR SELECT TO authenticated USING ((profile_id = ( SELECT auth.uid() AS uid)));


--
-- Name: post_reports Users can view own reports or admins all; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Users can view own reports or admins all" ON public.post_reports FOR SELECT USING (((reporter_id = ( SELECT auth.uid() AS uid)) OR public.is_admin()));


--
-- Name: forum_reports Users can view own reports or moderators all; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Users can view own reports or moderators all" ON public.forum_reports FOR SELECT USING (((reporter_id = ( SELECT auth.uid() AS uid)) OR (EXISTS ( SELECT 1
   FROM public.profiles
  WHERE (profiles.id = ( SELECT auth.uid() AS uid))))));


--
-- Name: forum_saved_searches Users can view own saved searches; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Users can view own saved searches" ON public.forum_saved_searches FOR SELECT TO authenticated USING ((profile_id = ( SELECT auth.uid() AS uid)));


--
-- Name: forum_search_history Users can view own search history; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Users can view own search history" ON public.forum_search_history FOR SELECT TO authenticated USING ((profile_id = ( SELECT auth.uid() AS uid)));


--
-- Name: forum_subscriptions Users can view own subscriptions; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Users can view own subscriptions" ON public.forum_subscriptions FOR SELECT TO authenticated USING ((profile_id = ( SELECT auth.uid() AS uid)));


--
-- Name: forum_activities Users can view public activities; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Users can view public activities" ON public.forum_activities FOR SELECT USING (((is_public = true) OR (profile_id = ( SELECT auth.uid() AS uid)) OR (target_profile_id = ( SELECT auth.uid() AS uid))));


--
-- Name: forum_message_read_receipts Users can view read receipts in their conversations; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Users can view read receipts in their conversations" ON public.forum_message_read_receipts FOR SELECT USING ((EXISTS ( SELECT 1
   FROM (public.forum_messages fm
     JOIN public.forum_conversation_participants fcp ON ((fcp.conversation_id = fm.conversation_id)))
  WHERE ((fm.id = forum_message_read_receipts.message_id) AND (fcp.profile_id = ( SELECT auth.uid() AS uid))))));


--
-- Name: forum_conversations Users can view their conversations; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Users can view their conversations" ON public.forum_conversations FOR SELECT USING ((EXISTS ( SELECT 1
   FROM public.forum_conversation_participants
  WHERE ((forum_conversation_participants.conversation_id = forum_conversations.id) AND (forum_conversation_participants.profile_id = ( SELECT auth.uid() AS uid))))));


--
-- Name: blocked_users Users can view their own blocked users; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Users can view their own blocked users" ON public.blocked_users FOR SELECT USING ((auth.uid() = user_id));


--
-- Name: forum_user_blocks Users can view their own blocks; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Users can view their own blocks" ON public.forum_user_blocks FOR SELECT USING ((( SELECT auth.uid() AS uid) = blocker_id));


--
-- Name: device_tokens Users can view their own device tokens; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Users can view their own device tokens" ON public.device_tokens FOR SELECT USING ((( SELECT auth.uid() AS uid) = profile_id));


--
-- Name: in_app_notifications Users can view their own in-app notifications; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Users can view their own in-app notifications" ON public.in_app_notifications FOR SELECT USING ((auth.uid() = user_id));


--
-- Name: notification_delivery_log Users can view their own notification logs; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Users can view their own notification logs" ON public.notification_delivery_log FOR SELECT USING ((auth.uid() = user_id));


--
-- Name: notification_queue Users can view their own queued notifications; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Users can view their own queued notifications" ON public.notification_queue FOR SELECT USING ((auth.uid() = user_id));


--
-- Name: moderation_queue Users can view their own reports; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Users can view their own reports" ON public.moderation_queue FOR SELECT USING ((auth.uid() = reporter_id));


--
-- Name: forum_reputation_history Users can view their own reputation history; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Users can view their own reputation history" ON public.forum_reputation_history FOR SELECT USING ((profile_id = ( SELECT auth.uid() AS uid)));


--
-- Name: forum_user_warnings Users can view their own warnings; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Users can view their own warnings" ON public.forum_user_warnings FOR SELECT USING ((profile_id = ( SELECT auth.uid() AS uid)));


--
-- Name: forum_publication_queue Users can view their publication queue items; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Users can view their publication queue items" ON public.forum_publication_queue FOR SELECT USING (((EXISTS ( SELECT 1
   FROM public.forum_scheduled_posts fsp
  WHERE ((fsp.id = forum_publication_queue.scheduled_post_id) AND (fsp.profile_id = ( SELECT auth.uid() AS uid))))) OR (EXISTS ( SELECT 1
   FROM public.forum_recurring_posts frp
  WHERE ((frp.id = forum_publication_queue.recurring_post_id) AND (frp.profile_id = ( SELECT auth.uid() AS uid)))))));


--
-- Name: forum_poll_votes Users can view votes; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Users can view votes" ON public.forum_poll_votes FOR SELECT TO authenticated USING (((profile_id = ( SELECT auth.uid() AS uid)) OR (EXISTS ( SELECT 1
   FROM public.forum_polls
  WHERE ((forum_polls.id = forum_poll_votes.poll_id) AND (forum_polls.is_anonymous = false))))));


--
-- Name: forum_announcement_dismissals Users manage their dismissals; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Users manage their dismissals" ON public.forum_announcement_dismissals USING ((profile_id = ( SELECT auth.uid() AS uid)));


--
-- Name: forum_series View published series or own; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "View published series or own" ON public.forum_series FOR SELECT USING (((is_published = true) OR (profile_id = ( SELECT auth.uid() AS uid))));


--
-- Name: forum_series_posts View published series posts or manage own; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "View published series posts or manage own" ON public.forum_series_posts USING (((EXISTS ( SELECT 1
   FROM public.forum_series s
  WHERE ((s.id = forum_series_posts.series_id) AND (s.is_published = true)))) OR (EXISTS ( SELECT 1
   FROM public.forum_series s
  WHERE ((s.id = forum_series_posts.series_id) AND (s.profile_id = ( SELECT auth.uid() AS uid)))))));


--
-- Name: post_activity_logs activity_logs_service_policy; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY activity_logs_service_policy ON public.post_activity_logs TO service_role USING (true) WITH CHECK (true);


--
-- Name: address; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.address ENABLE ROW LEVEL SECURITY;

--
-- Name: admin_audit_log; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.admin_audit_log ENABLE ROW LEVEL SECURITY;

--
-- Name: api_analytics; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.api_analytics ENABLE ROW LEVEL SECURITY;

--
-- Name: app_config; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.app_config ENABLE ROW LEVEL SECURITY;

--
-- Name: app_version_requirements app_version_admin_delete; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY app_version_admin_delete ON public.app_version_requirements FOR DELETE USING (public.is_admin());


--
-- Name: app_version_requirements app_version_admin_insert; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY app_version_admin_insert ON public.app_version_requirements FOR INSERT WITH CHECK ((EXISTS ( SELECT 1
   FROM (public.user_roles ur
     JOIN public.roles r ON ((ur.role_id = r.id)))
  WHERE ((ur.profile_id = ( SELECT auth.uid() AS uid)) AND (r.name = 'admin'::text)))));


--
-- Name: app_version_requirements app_version_admin_update; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY app_version_admin_update ON public.app_version_requirements FOR UPDATE USING (public.is_admin());


--
-- Name: app_version_requirements app_version_public_read; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY app_version_public_read ON public.app_version_requirements FOR SELECT USING (true);


--
-- Name: app_version_requirements; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.app_version_requirements ENABLE ROW LEVEL SECURITY;

--
-- Name: audience_segments; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.audience_segments ENABLE ROW LEVEL SECURITY;

--
-- Name: audit_logs; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.audit_logs ENABLE ROW LEVEL SECURITY;

--
-- Name: audit_logs audit_logs_admin_view; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY audit_logs_admin_view ON public.audit_logs FOR SELECT USING (public.is_admin());


--
-- Name: automation_enrollments; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.automation_enrollments ENABLE ROW LEVEL SECURITY;

--
-- Name: blocked_users; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.blocked_users ENABLE ROW LEVEL SECURITY;

--
-- Name: bookmarks; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.bookmarks ENABLE ROW LEVEL SECURITY;

--
-- Name: bookmarks bookmarks_delete_own; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY bookmarks_delete_own ON public.bookmarks FOR DELETE USING ((profile_id = auth.uid()));


--
-- Name: bookmarks bookmarks_insert_own; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY bookmarks_insert_own ON public.bookmarks FOR INSERT WITH CHECK ((profile_id = auth.uid()));


--
-- Name: bookmarks bookmarks_select_own; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY bookmarks_select_own ON public.bookmarks FOR SELECT USING ((profile_id = auth.uid()));


--
-- Name: campaign_recipients; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.campaign_recipients ENABLE ROW LEVEL SECURITY;

--
-- Name: categories; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.categories ENABLE ROW LEVEL SECURITY;

--
-- Name: challenge_activities; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.challenge_activities ENABLE ROW LEVEL SECURITY;

--
-- Name: challenge_participants; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.challenge_participants ENABLE ROW LEVEL SECURITY;

--
-- Name: challenges; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.challenges ENABLE ROW LEVEL SECURITY;

--
-- Name: challenges challenges_delete_policy; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY challenges_delete_policy ON public.challenges FOR DELETE USING (((profile_id = ( SELECT auth.uid() AS uid)) OR public.is_admin_jsonb()));


--
-- Name: challenges challenges_update_policy; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY challenges_update_policy ON public.challenges FOR UPDATE USING (((profile_id = ( SELECT auth.uid() AS uid)) OR public.is_admin_jsonb()));


--
-- Name: comments; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.comments ENABLE ROW LEVEL SECURITY;

--
-- Name: comments comments_delete_policy; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY comments_delete_policy ON public.comments FOR DELETE USING ((user_id = ( SELECT auth.uid() AS uid)));


--
-- Name: comments comments_update_policy; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY comments_update_policy ON public.comments FOR UPDATE USING ((user_id = ( SELECT auth.uid() AS uid)));


--
-- Name: community_fridges; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.community_fridges ENABLE ROW LEVEL SECURITY;

--
-- Name: compressed_images; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.compressed_images ENABLE ROW LEVEL SECURITY;

--
-- Name: content_translations; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.content_translations ENABLE ROW LEVEL SECURITY;

--
-- Name: countries; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.countries ENABLE ROW LEVEL SECURITY;

--
-- Name: crm_customer_notes; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.crm_customer_notes ENABLE ROW LEVEL SECURITY;

--
-- Name: crm_customer_tag_assignments; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.crm_customer_tag_assignments ENABLE ROW LEVEL SECURITY;

--
-- Name: crm_customer_tags; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.crm_customer_tags ENABLE ROW LEVEL SECURITY;

--
-- Name: crm_customers; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.crm_customers ENABLE ROW LEVEL SECURITY;

--
-- Name: daily_stats; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.daily_stats ENABLE ROW LEVEL SECURITY;

--
-- Name: daily_stats daily_stats_all_service; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY daily_stats_all_service ON public.daily_stats TO service_role USING (true) WITH CHECK (true);


--
-- Name: daily_stats daily_stats_select_admin; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY daily_stats_select_admin ON public.daily_stats FOR SELECT USING (public.is_admin());


--
-- Name: device_attestations; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.device_attestations ENABLE ROW LEVEL SECURITY;

--
-- Name: device_attestations device_attestations_own_view; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY device_attestations_own_view ON public.device_attestations FOR SELECT USING ((user_id = ( SELECT auth.uid() AS uid)));


--
-- Name: device_tokens; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.device_tokens ENABLE ROW LEVEL SECURITY;

--
-- Name: display_name_overrides; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.display_name_overrides ENABLE ROW LEVEL SECURITY;

--
-- Name: dynamic_content_translations; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.dynamic_content_translations ENABLE ROW LEVEL SECURITY;

--
-- Name: email_audit_log; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.email_audit_log ENABLE ROW LEVEL SECURITY;

--
-- Name: email_automation_flows; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.email_automation_flows ENABLE ROW LEVEL SECURITY;

--
-- Name: email_automation_queue; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.email_automation_queue ENABLE ROW LEVEL SECURITY;

--
-- Name: email_automation_queue email_automation_queue_admin_access; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY email_automation_queue_admin_access ON public.email_automation_queue USING ((public.is_admin() OR (( SELECT (auth.jwt() ->> 'role'::text)) = 'service_role'::text)));


--
-- Name: email_bounce_events; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.email_bounce_events ENABLE ROW LEVEL SECURITY;

--
-- Name: email_circuit_breaker_state; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.email_circuit_breaker_state ENABLE ROW LEVEL SECURITY;

--
-- Name: email_circuit_breaker_state email_circuit_breaker_state_admin_all_policy; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY email_circuit_breaker_state_admin_all_policy ON public.email_circuit_breaker_state USING (public.is_admin_jsonb());


--
-- Name: email_dead_letter_queue; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.email_dead_letter_queue ENABLE ROW LEVEL SECURITY;

--
-- Name: email_dead_letter_queue email_dead_letter_queue_admin_policy; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY email_dead_letter_queue_admin_policy ON public.email_dead_letter_queue USING (public.is_admin_jsonb());


--
-- Name: email_delivery_log; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.email_delivery_log ENABLE ROW LEVEL SECURITY;

--
-- Name: email_health_events; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.email_health_events ENABLE ROW LEVEL SECURITY;

--
-- Name: email_health_events email_health_events_select_policy; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY email_health_events_select_policy ON public.email_health_events FOR SELECT TO authenticated USING (true);


--
-- Name: email_logs; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.email_logs ENABLE ROW LEVEL SECURITY;

--
-- Name: email_logs email_logs_select_policy; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY email_logs_select_policy ON public.email_logs FOR SELECT USING (((recipient_id = ( SELECT auth.uid() AS uid)) OR public.is_admin_jsonb()));


--
-- Name: email_preferences; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.email_preferences ENABLE ROW LEVEL SECURITY;

--
-- Name: email_provider_health_history; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.email_provider_health_history ENABLE ROW LEVEL SECURITY;

--
-- Name: email_provider_health_metrics; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.email_provider_health_metrics ENABLE ROW LEVEL SECURITY;

--
-- Name: email_provider_metrics; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.email_provider_metrics ENABLE ROW LEVEL SECURITY;

--
-- Name: email_provider_metrics email_provider_metrics_select_policy; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY email_provider_metrics_select_policy ON public.email_provider_metrics FOR SELECT TO authenticated USING (true);


--
-- Name: email_provider_monthly_quota; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.email_provider_monthly_quota ENABLE ROW LEVEL SECURITY;

--
-- Name: email_provider_quota; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.email_provider_quota ENABLE ROW LEVEL SECURITY;

--
-- Name: email_provider_stats; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.email_provider_stats ENABLE ROW LEVEL SECURITY;

--
-- Name: email_queue; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.email_queue ENABLE ROW LEVEL SECURITY;

--
-- Name: email_suppression_list; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.email_suppression_list ENABLE ROW LEVEL SECURITY;

--
-- Name: email_suppressions; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.email_suppressions ENABLE ROW LEVEL SECURITY;

--
-- Name: email_template_versions; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.email_template_versions ENABLE ROW LEVEL SECURITY;

--
-- Name: email_templates; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.email_templates ENABLE ROW LEVEL SECURITY;

--
-- Name: email_templates email_templates_admin_access; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY email_templates_admin_access ON public.email_templates USING ((public.is_admin() OR (( SELECT (auth.jwt() ->> 'role'::text)) = 'service_role'::text)));


--
-- Name: experiment_assignments; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.experiment_assignments ENABLE ROW LEVEL SECURITY;

--
-- Name: experiment_assignments experiment_assignments_own_view; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY experiment_assignments_own_view ON public.experiment_assignments FOR SELECT USING ((user_id = ( SELECT auth.uid() AS uid)));


--
-- Name: experiments; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.experiments ENABLE ROW LEVEL SECURITY;

--
-- Name: feature_flag_overrides; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.feature_flag_overrides ENABLE ROW LEVEL SECURITY;

--
-- Name: feature_flag_overrides feature_flag_overrides_own_view; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY feature_flag_overrides_own_view ON public.feature_flag_overrides FOR SELECT USING ((user_id = ( SELECT auth.uid() AS uid)));


--
-- Name: feature_flags; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.feature_flags ENABLE ROW LEVEL SECURITY;

--
-- Name: precomputed_feed_cells feed_cells_all_service; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY feed_cells_all_service ON public.precomputed_feed_cells TO service_role USING (true) WITH CHECK (true);


--
-- Name: precomputed_feed_cells feed_cells_select_authenticated; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY feed_cells_select_authenticated ON public.precomputed_feed_cells FOR SELECT TO authenticated USING (true);


--
-- Name: feedback; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.feedback ENABLE ROW LEVEL SECURITY;

--
-- Name: feedback feedback_select_policy; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY feedback_select_policy ON public.feedback FOR SELECT TO authenticated USING (((profile_id = ( SELECT auth.uid() AS uid)) OR public.is_admin()));


--
-- Name: forms; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.forms ENABLE ROW LEVEL SECURITY;

--
-- Name: forum; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.forum ENABLE ROW LEVEL SECURITY;

--
-- Name: forum_activities; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.forum_activities ENABLE ROW LEVEL SECURITY;

--
-- Name: forum_activity_types; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.forum_activity_types ENABLE ROW LEVEL SECURITY;

--
-- Name: forum_announcement_analytics; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.forum_announcement_analytics ENABLE ROW LEVEL SECURITY;

--
-- Name: forum_announcement_dismissals; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.forum_announcement_dismissals ENABLE ROW LEVEL SECURITY;

--
-- Name: forum_announcements; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.forum_announcements ENABLE ROW LEVEL SECURITY;

--
-- Name: forum_author_analytics; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.forum_author_analytics ENABLE ROW LEVEL SECURITY;

--
-- Name: forum_badges; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.forum_badges ENABLE ROW LEVEL SECURITY;

--
-- Name: forum_bookmark_collections; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.forum_bookmark_collections ENABLE ROW LEVEL SECURITY;

--
-- Name: forum_bookmark_collections forum_bookmark_collections_select_policy; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY forum_bookmark_collections_select_policy ON public.forum_bookmark_collections FOR SELECT USING (((profile_id = ( SELECT auth.uid() AS uid)) OR (is_private = false)));


--
-- Name: forum_categories; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.forum_categories ENABLE ROW LEVEL SECURITY;

--
-- Name: forum_categories forum_categories_admin_all_policy; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY forum_categories_admin_all_policy ON public.forum_categories USING (public.is_admin_jsonb());


--
-- Name: forum_comment_history; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.forum_comment_history ENABLE ROW LEVEL SECURITY;

--
-- Name: forum_comment_reactions; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.forum_comment_reactions ENABLE ROW LEVEL SECURITY;

--
-- Name: forum_content_experiments; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.forum_content_experiments ENABLE ROW LEVEL SECURITY;

--
-- Name: forum_conversation_participants; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.forum_conversation_participants ENABLE ROW LEVEL SECURITY;

--
-- Name: forum_conversations; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.forum_conversations ENABLE ROW LEVEL SECURITY;

--
-- Name: forum forum_delete_policy; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY forum_delete_policy ON public.forum FOR DELETE USING ((profile_id = ( SELECT auth.uid() AS uid)));


--
-- Name: forum_drafts; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.forum_drafts ENABLE ROW LEVEL SECURITY;

--
-- Name: forum_feed_preferences; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.forum_feed_preferences ENABLE ROW LEVEL SECURITY;

--
-- Name: forum_feed_read_status; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.forum_feed_read_status ENABLE ROW LEVEL SECURITY;

--
-- Name: forum_mentions; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.forum_mentions ENABLE ROW LEVEL SECURITY;

--
-- Name: forum_message_reactions; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.forum_message_reactions ENABLE ROW LEVEL SECURITY;

--
-- Name: forum_message_read_receipts; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.forum_message_read_receipts ENABLE ROW LEVEL SECURITY;

--
-- Name: forum_messages; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.forum_messages ENABLE ROW LEVEL SECURITY;

--
-- Name: forum_moderation_notes; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.forum_moderation_notes ENABLE ROW LEVEL SECURITY;

--
-- Name: forum_moderation_queue; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.forum_moderation_queue ENABLE ROW LEVEL SECURITY;

--
-- Name: forum_moderation_stats; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.forum_moderation_stats ENABLE ROW LEVEL SECURITY;

--
-- Name: forum_moderator_logs; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.forum_moderator_logs ENABLE ROW LEVEL SECURITY;

--
-- Name: forum_notifications; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.forum_notifications ENABLE ROW LEVEL SECURITY;

--
-- Name: forum_poll_options; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.forum_poll_options ENABLE ROW LEVEL SECURITY;

--
-- Name: forum_poll_options forum_poll_options_author_all_policy; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY forum_poll_options_author_all_policy ON public.forum_poll_options TO authenticated USING ((EXISTS ( SELECT 1
   FROM (public.forum_polls p
     JOIN public.forum f ON ((p.forum_id = f.id)))
  WHERE ((p.id = forum_poll_options.poll_id) AND (f.profile_id = ( SELECT auth.uid() AS uid))))));


--
-- Name: forum_poll_votes; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.forum_poll_votes ENABLE ROW LEVEL SECURITY;

--
-- Name: forum_polls; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.forum_polls ENABLE ROW LEVEL SECURITY;

--
-- Name: forum_popular_searches; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.forum_popular_searches ENABLE ROW LEVEL SECURITY;

--
-- Name: forum_post_analytics; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.forum_post_analytics ENABLE ROW LEVEL SECURITY;

--
-- Name: forum_post_history; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.forum_post_history ENABLE ROW LEVEL SECURITY;

--
-- Name: forum_post_tags; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.forum_post_tags ENABLE ROW LEVEL SECURITY;

--
-- Name: forum_post_tags forum_post_tags_owner_all_policy; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY forum_post_tags_owner_all_policy ON public.forum_post_tags USING ((EXISTS ( SELECT 1
   FROM public.forum
  WHERE ((forum.id = forum_post_tags.forum_id) AND (forum.profile_id = ( SELECT auth.uid() AS uid))))));


--
-- Name: forum_publication_queue; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.forum_publication_queue ENABLE ROW LEVEL SECURITY;

--
-- Name: forum_rate_limit_config; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.forum_rate_limit_config ENABLE ROW LEVEL SECURITY;

--
-- Name: forum_rate_limits; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.forum_rate_limits ENABLE ROW LEVEL SECURITY;

--
-- Name: forum_reactions; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.forum_reactions ENABLE ROW LEVEL SECURITY;

--
-- Name: forum_reading_history; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.forum_reading_history ENABLE ROW LEVEL SECURITY;

--
-- Name: forum_reading_progress; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.forum_reading_progress ENABLE ROW LEVEL SECURITY;

--
-- Name: forum_recurring_posts; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.forum_recurring_posts ENABLE ROW LEVEL SECURITY;

--
-- Name: forum_reports; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.forum_reports ENABLE ROW LEVEL SECURITY;

--
-- Name: forum_reputation_actions; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.forum_reputation_actions ENABLE ROW LEVEL SECURITY;

--
-- Name: forum_reputation_history; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.forum_reputation_history ENABLE ROW LEVEL SECURITY;

--
-- Name: forum_reputation_levels; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.forum_reputation_levels ENABLE ROW LEVEL SECURITY;

--
-- Name: forum_saved_searches; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.forum_saved_searches ENABLE ROW LEVEL SECURITY;

--
-- Name: forum_scheduled_posts; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.forum_scheduled_posts ENABLE ROW LEVEL SECURITY;

--
-- Name: forum_search_history; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.forum_search_history ENABLE ROW LEVEL SECURITY;

--
-- Name: forum_series; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.forum_series ENABLE ROW LEVEL SECURITY;

--
-- Name: forum_series_posts; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.forum_series_posts ENABLE ROW LEVEL SECURITY;

--
-- Name: forum_subscriptions; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.forum_subscriptions ENABLE ROW LEVEL SECURITY;

--
-- Name: forum_system_messages; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.forum_system_messages ENABLE ROW LEVEL SECURITY;

--
-- Name: forum_tags; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.forum_tags ENABLE ROW LEVEL SECURITY;

--
-- Name: forum_trust_levels; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.forum_trust_levels ENABLE ROW LEVEL SECURITY;

--
-- Name: forum forum_update_policy; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY forum_update_policy ON public.forum FOR UPDATE USING ((profile_id = ( SELECT auth.uid() AS uid)));


--
-- Name: forum_user_badges; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.forum_user_badges ENABLE ROW LEVEL SECURITY;

--
-- Name: forum_user_blocks; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.forum_user_blocks ENABLE ROW LEVEL SECURITY;

--
-- Name: forum_user_follows; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.forum_user_follows ENABLE ROW LEVEL SECURITY;

--
-- Name: forum_user_reputation; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.forum_user_reputation ENABLE ROW LEVEL SECURITY;

--
-- Name: forum_user_stats; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.forum_user_stats ENABLE ROW LEVEL SECURITY;

--
-- Name: forum_user_warnings; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.forum_user_warnings ENABLE ROW LEVEL SECURITY;

--
-- Name: grok_usage_logs; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.grok_usage_logs ENABLE ROW LEVEL SECURITY;

--
-- Name: handlers; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.handlers ENABLE ROW LEVEL SECURITY;

--
-- Name: image_compressions; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.image_compressions ENABLE ROW LEVEL SECURITY;

--
-- Name: image_upload_metrics; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.image_upload_metrics ENABLE ROW LEVEL SECURITY;

--
-- Name: in_app_notifications; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.in_app_notifications ENABLE ROW LEVEL SECURITY;

--
-- Name: languages; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.languages ENABLE ROW LEVEL SECURITY;

--
-- Name: legal; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.legal ENABLE ROW LEVEL SECURITY;

--
-- Name: legal_documents; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.legal_documents ENABLE ROW LEVEL SECURITY;

--
-- Name: likes; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.likes ENABLE ROW LEVEL SECURITY;

--
-- Name: likes likes_delete_policy; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY likes_delete_policy ON public.likes FOR DELETE TO authenticated USING ((profile_id = ( SELECT auth.uid() AS uid)));


--
-- Name: likes likes_insert_policy; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY likes_insert_policy ON public.likes FOR INSERT TO authenticated WITH CHECK ((profile_id = ( SELECT auth.uid() AS uid)));


--
-- Name: likes likes_select_policy; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY likes_select_policy ON public.likes FOR SELECT USING (true);


--
-- Name: location_update_queue; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.location_update_queue ENABLE ROW LEVEL SECURITY;

--
-- Name: mfa_configuration; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.mfa_configuration ENABLE ROW LEVEL SECURITY;

--
-- Name: mfa_rate_limits; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.mfa_rate_limits ENABLE ROW LEVEL SECURITY;

--
-- Name: mfa_sessions; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.mfa_sessions ENABLE ROW LEVEL SECURITY;

--
-- Name: mfa_verification_attempts; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.mfa_verification_attempts ENABLE ROW LEVEL SECURITY;

--
-- Name: moderation_queue; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.moderation_queue ENABLE ROW LEVEL SECURITY;

--
-- Name: newsletter_campaigns; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.newsletter_campaigns ENABLE ROW LEVEL SECURITY;

--
-- Name: newsletter_subscribers; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.newsletter_subscribers ENABLE ROW LEVEL SECURITY;

--
-- Name: notification_priority_config notification_config_admin_delete; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY notification_config_admin_delete ON public.notification_priority_config FOR DELETE USING (public.is_admin());


--
-- Name: notification_priority_config notification_config_admin_insert; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY notification_config_admin_insert ON public.notification_priority_config FOR INSERT WITH CHECK ((EXISTS ( SELECT 1
   FROM (public.user_roles ur
     JOIN public.roles r ON ((ur.role_id = r.id)))
  WHERE ((ur.profile_id = ( SELECT auth.uid() AS uid)) AND (r.name = 'admin'::text)))));


--
-- Name: notification_priority_config notification_config_admin_update; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY notification_config_admin_update ON public.notification_priority_config FOR UPDATE USING (public.is_admin());


--
-- Name: notification_priority_config notification_config_public_read; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY notification_config_public_read ON public.notification_priority_config FOR SELECT USING (true);


--
-- Name: notification_delivery_log; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.notification_delivery_log ENABLE ROW LEVEL SECURITY;

--
-- Name: notification_digest_queue; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.notification_digest_queue ENABLE ROW LEVEL SECURITY;

--
-- Name: notification_preferences; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.notification_preferences ENABLE ROW LEVEL SECURITY;

--
-- Name: notification_priority_config; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.notification_priority_config ENABLE ROW LEVEL SECURITY;

--
-- Name: notification_queue; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.notification_queue ENABLE ROW LEVEL SECURITY;

--
-- Name: notification_settings; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.notification_settings ENABLE ROW LEVEL SECURITY;

--
-- Name: notifications; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.notifications ENABLE ROW LEVEL SECURITY;

--
-- Name: organization_members; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.organization_members ENABLE ROW LEVEL SECURITY;

--
-- Name: organizations; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.organizations ENABLE ROW LEVEL SECURITY;

--
-- Name: orphaned_storage_cleanup; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.orphaned_storage_cleanup ENABLE ROW LEVEL SECURITY;

--
-- Name: pending_operations; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.pending_operations ENABLE ROW LEVEL SECURITY;

--
-- Name: pending_operations pending_operations_own_access; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY pending_operations_own_access ON public.pending_operations USING ((user_id = ( SELECT auth.uid() AS uid)));


--
-- Name: post_activity_daily_stats; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.post_activity_daily_stats ENABLE ROW LEVEL SECURITY;

--
-- Name: post_activity_daily_stats post_activity_daily_stats_access; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY post_activity_daily_stats_access ON public.post_activity_daily_stats USING ((public.is_admin() OR (( SELECT (auth.jwt() ->> 'role'::text)) = 'service_role'::text)));


--
-- Name: post_activity_logs; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.post_activity_logs ENABLE ROW LEVEL SECURITY;

--
-- Name: post_activity_logs post_activity_logs_insert; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY post_activity_logs_insert ON public.post_activity_logs FOR INSERT WITH CHECK (((actor_id = ( SELECT auth.uid() AS uid)) OR (( SELECT (( SELECT auth.jwt() AS jwt) ->> 'role'::text)) = 'service_role'::text)));


--
-- Name: post_activity_logs post_activity_logs_select; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY post_activity_logs_select ON public.post_activity_logs FOR SELECT USING (((actor_id = auth.uid()) OR (EXISTS ( SELECT 1
   FROM public.posts p
  WHERE ((p.id = post_activity_logs.post_id) AND (p.profile_id = auth.uid())))) OR public.is_admin() OR (( SELECT (auth.jwt() ->> 'role'::text)) = 'service_role'::text)));


--
-- Name: post_reports; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.post_reports ENABLE ROW LEVEL SECURITY;

--
-- Name: post_views; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.post_views ENABLE ROW LEVEL SECURITY;

--
-- Name: post_views post_views_owner_access; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY post_views_owner_access ON public.post_views FOR SELECT USING ((EXISTS ( SELECT 1
   FROM public.posts p
  WHERE ((p.id = post_views.post_id) AND (p.profile_id = ( SELECT auth.uid() AS uid))))));


--
-- Name: posts; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.posts ENABLE ROW LEVEL SECURITY;

--
-- Name: posts posts_delete_policy; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY posts_delete_policy ON public.posts FOR DELETE TO authenticated USING ((profile_id = ( SELECT auth.uid() AS uid)));


--
-- Name: posts_image_backup; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.posts_image_backup ENABLE ROW LEVEL SECURITY;

--
-- Name: posts posts_insert_policy; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY posts_insert_policy ON public.posts FOR INSERT TO authenticated WITH CHECK ((profile_id = ( SELECT auth.uid() AS uid)));


--
-- Name: posts posts_select_policy; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY posts_select_policy ON public.posts FOR SELECT TO authenticated, anon USING (((is_active = true) OR (profile_id = ( SELECT auth.uid() AS uid))));


--
-- Name: posts posts_update_policy; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY posts_update_policy ON public.posts FOR UPDATE TO authenticated USING ((profile_id = ( SELECT auth.uid() AS uid))) WITH CHECK ((profile_id = ( SELECT auth.uid() AS uid)));


--
-- Name: precomputed_feed_cells; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.precomputed_feed_cells ENABLE ROW LEVEL SECURITY;

--
-- Name: profile_stats; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.profile_stats ENABLE ROW LEVEL SECURITY;

--
-- Name: profiles; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;

--
-- Name: rate_limits; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.rate_limits ENABLE ROW LEVEL SECURITY;

--
-- Name: reaction_types; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.reaction_types ENABLE ROW LEVEL SECURITY;

--
-- Name: reports; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.reports ENABLE ROW LEVEL SECURITY;

--
-- Name: reviews; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.reviews ENABLE ROW LEVEL SECURITY;

--
-- Name: roles; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.roles ENABLE ROW LEVEL SECURITY;

--
-- Name: room_participants; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.room_participants ENABLE ROW LEVEL SECURITY;

--
-- Name: rooms; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.rooms ENABLE ROW LEVEL SECURITY;

--
-- Name: sync_checkpoints; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.sync_checkpoints ENABLE ROW LEVEL SECURITY;

--
-- Name: sync_checkpoints sync_checkpoints_own_access; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY sync_checkpoints_own_access ON public.sync_checkpoints USING ((user_id = ( SELECT auth.uid() AS uid)));


--
-- Name: telegram_rate_limits; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.telegram_rate_limits ENABLE ROW LEVEL SECURITY;

--
-- Name: telegram_rate_limits telegram_rate_limits_service; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY telegram_rate_limits_service ON public.telegram_rate_limits USING ((( SELECT (( SELECT auth.jwt() AS jwt) ->> 'role'::text)) = 'service_role'::text));


--
-- Name: telegram_user_activity; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.telegram_user_activity ENABLE ROW LEVEL SECURITY;

--
-- Name: telegram_user_states; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.telegram_user_states ENABLE ROW LEVEL SECURITY;

--
-- Name: translation_analytics; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.translation_analytics ENABLE ROW LEVEL SECURITY;

--
-- Name: translation_cache; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.translation_cache ENABLE ROW LEVEL SECURITY;

--
-- Name: translation_change_log; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.translation_change_log ENABLE ROW LEVEL SECURITY;

--
-- Name: translation_errors; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.translation_errors ENABLE ROW LEVEL SECURITY;

--
-- Name: translation_platform_config; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.translation_platform_config ENABLE ROW LEVEL SECURITY;

--
-- Name: translation_queue; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.translation_queue ENABLE ROW LEVEL SECURITY;

--
-- Name: translation_sync_status; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.translation_sync_status ENABLE ROW LEVEL SECURITY;

--
-- Name: translation_usage_analytics; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.translation_usage_analytics ENABLE ROW LEVEL SECURITY;

--
-- Name: translation_versions; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.translation_versions ENABLE ROW LEVEL SECURITY;

--
-- Name: translations; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.translations ENABLE ROW LEVEL SECURITY;

--
-- Name: user_activity_summary; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.user_activity_summary ENABLE ROW LEVEL SECURITY;

--
-- Name: user_activity_summary user_activity_summary_own_view; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY user_activity_summary_own_view ON public.user_activity_summary FOR SELECT USING ((user_id = ( SELECT auth.uid() AS uid)));


--
-- Name: user_addresses; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.user_addresses ENABLE ROW LEVEL SECURITY;

--
-- Name: user_events; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.user_events ENABLE ROW LEVEL SECURITY;

--
-- Name: user_events_2025_12; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.user_events_2025_12 ENABLE ROW LEVEL SECURITY;

--
-- Name: user_events_2025_12 user_events_2025_12_insert; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY user_events_2025_12_insert ON public.user_events_2025_12 FOR INSERT WITH CHECK ((user_id = ( SELECT auth.uid() AS uid)));


--
-- Name: user_events_2025_12 user_events_2025_12_select; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY user_events_2025_12_select ON public.user_events_2025_12 FOR SELECT USING ((user_id = ( SELECT auth.uid() AS uid)));


--
-- Name: user_events_2026_01; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.user_events_2026_01 ENABLE ROW LEVEL SECURITY;

--
-- Name: user_events_2026_01 user_events_2026_01_insert; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY user_events_2026_01_insert ON public.user_events_2026_01 FOR INSERT WITH CHECK ((user_id = ( SELECT auth.uid() AS uid)));


--
-- Name: user_events_2026_01 user_events_2026_01_select; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY user_events_2026_01_select ON public.user_events_2026_01 FOR SELECT USING ((user_id = ( SELECT auth.uid() AS uid)));


--
-- Name: user_events_2026_02; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.user_events_2026_02 ENABLE ROW LEVEL SECURITY;

--
-- Name: user_events_2026_02 user_events_2026_02_insert; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY user_events_2026_02_insert ON public.user_events_2026_02 FOR INSERT WITH CHECK ((user_id = ( SELECT auth.uid() AS uid)));


--
-- Name: user_events_2026_02 user_events_2026_02_select; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY user_events_2026_02_select ON public.user_events_2026_02 FOR SELECT USING ((user_id = ( SELECT auth.uid() AS uid)));


--
-- Name: user_locale_preferences; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.user_locale_preferences ENABLE ROW LEVEL SECURITY;

--
-- Name: user_notifications; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.user_notifications ENABLE ROW LEVEL SECURITY;

--
-- Name: user_preferences; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.user_preferences ENABLE ROW LEVEL SECURITY;

--
-- Name: user_rate_limits; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.user_rate_limits ENABLE ROW LEVEL SECURITY;

--
-- Name: user_roles; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.user_roles ENABLE ROW LEVEL SECURITY;

--
-- Name: user_roles user_roles_admin_manage; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY user_roles_admin_manage ON public.user_roles USING (false) WITH CHECK (false);


--
-- Name: user_roles user_roles_select_own; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY user_roles_select_own ON public.user_roles FOR SELECT USING ((profile_id = auth.uid()));


--
-- Name: POLICY user_roles_select_own ON user_roles; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON POLICY user_roles_select_own ON public.user_roles IS 'Users can only read their own role assignments. Admin operations require service role client.';


--
-- Name: views; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.views ENABLE ROW LEVEL SECURITY;

--
-- Name: whatsapp_rate_limits; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.whatsapp_rate_limits ENABLE ROW LEVEL SECURITY;

--
-- Name: whatsapp_rate_limits whatsapp_rate_limits_service; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY whatsapp_rate_limits_service ON public.whatsapp_rate_limits USING ((( SELECT (( SELECT auth.jwt() AS jwt) ->> 'role'::text)) = 'service_role'::text));


--
-- Name: whatsapp_user_states; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.whatsapp_user_states ENABLE ROW LEVEL SECURITY;

--
-- Name: whatsapp_user_states whatsapp_user_states_service; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY whatsapp_user_states_service ON public.whatsapp_user_states USING ((( SELECT (( SELECT auth.jwt() AS jwt) ->> 'role'::text)) = 'service_role'::text));


--
-- PostgreSQL database dump complete
--

\unrestrict agQE2P5nhkF2FLfZ1Ji654IdC0IJY6medkfclpBX8aj4qCaTvHkwev08wWfJa0o


-- ============================================================================
-- Cron Jobs (pg_cron)
-- ============================================================================

SELECT cron.schedule('backfill-challenge-translations', '0 3 * * *', '
  SELECT net.http_post(
    url := (SELECT decrypted_secret FROM vault.decrypted_secrets WHERE name = ''automation_project_url'') || ''/functions/v1/api-v1-localization/backfill-challenges'',
    headers := jsonb_build_object(
      ''Content-Type'', ''application/json'',
      ''Authorization'', ''Bearer '' || (SELECT decrypted_secret FROM vault.decrypted_secrets WHERE name = ''automation_anon_key'')
    ),
    body := jsonb_build_object(
      ''mode'', ''incremental'',
      ''limit'', 100,
      ''hoursBack'', 168,
      ''source'', ''cron''
    ),
    timeout_milliseconds := 60000
  ) AS request_id;
  ');
SELECT cron.schedule('backfill-forum-post-translations', '0 4 * * *', '
  SELECT net.http_post(
    url := (SELECT decrypted_secret FROM vault.decrypted_secrets WHERE name = ''automation_project_url'') || ''/functions/v1/api-v1-localization/backfill-forum-posts'',
    headers := jsonb_build_object(
      ''Content-Type'', ''application/json'',
      ''Authorization'', ''Bearer '' || (SELECT decrypted_secret FROM vault.decrypted_secrets WHERE name = ''automation_anon_key'')
    ),
    body := jsonb_build_object(
      ''mode'', ''incremental'',
      ''limit'', 100,
      ''hoursBack'', 48,
      ''source'', ''cron''
    ),
    timeout_milliseconds := 60000
  ) AS request_id;
  ');
SELECT cron.schedule('backfill-post-translations', '0 * * * *', '
  SELECT net.http_post(
    url := (SELECT decrypted_secret FROM vault.decrypted_secrets WHERE name = ''automation_project_url'') || ''/functions/v1/api-v1-localization/backfill-posts'',
    headers := jsonb_build_object(
      ''Content-Type'', ''application/json'',
      ''Authorization'', ''Bearer '' || (SELECT decrypted_secret FROM vault.decrypted_secrets WHERE name = ''automation_anon_key'')
    ),
    body := jsonb_build_object(
      ''mode'', ''incremental'',
      ''limit'', 50,
      ''hoursBack'', 24,
      ''source'', ''cron''
    ),
    timeout_milliseconds := 60000
  ) AS request_id;
  ');
SELECT cron.schedule('backfill-untranslated-challenges', '0 */6 * * *', '
  SELECT net.http_post(
    url := (SELECT decrypted_secret FROM vault.decrypted_secrets WHERE name = ''automation_project_url'') || ''/functions/v1/localization/backfill-challenges'',
    headers := jsonb_build_object(
      ''Content-Type'', ''application/json'',
      ''Authorization'', ''Bearer '' || (SELECT decrypted_secret FROM vault.decrypted_secrets WHERE name = ''automation_anon_key'')
    ),
    body := jsonb_build_object(
      ''mode'', ''full'',
      ''limit'', 50,
      ''onlyUntranslated'', true,
      ''source'', ''cron''
    ),
    timeout_milliseconds := 120000
  ) AS request_id;
  ');
SELECT cron.schedule('backfill-untranslated-forum-posts', '30 */6 * * *', '
  SELECT net.http_post(
    url := (SELECT decrypted_secret FROM vault.decrypted_secrets WHERE name = ''automation_project_url'') || ''/functions/v1/localization/backfill-forum-posts'',
    headers := jsonb_build_object(
      ''Content-Type'', ''application/json'',
      ''Authorization'', ''Bearer '' || (SELECT decrypted_secret FROM vault.decrypted_secrets WHERE name = ''automation_anon_key'')
    ),
    body := jsonb_build_object(
      ''mode'', ''full'',
      ''limit'', 50,
      ''onlyUntranslated'', true,
      ''source'', ''cron''
    ),
    timeout_milliseconds := 120000
  ) AS request_id;
  ');
SELECT cron.schedule('backfill-untranslated-posts', '30 */2 * * *', '
  SELECT net.http_post(
    url := (SELECT decrypted_secret FROM vault.decrypted_secrets WHERE name = ''automation_project_url'') || ''/functions/v1/localization/backfill-posts'',
    headers := jsonb_build_object(
      ''Content-Type'', ''application/json'',
      ''Authorization'', ''Bearer '' || (SELECT decrypted_secret FROM vault.decrypted_secrets WHERE name = ''automation_anon_key'')
    ),
    body := jsonb_build_object(
      ''mode'', ''full'',
      ''limit'', 100,
      ''onlyUntranslated'', true,
      ''source'', ''cron''
    ),
    timeout_milliseconds := 120000
  ) AS request_id;
  ');
SELECT cron.schedule('cleanup-feed-cells', '0 * * * *', 'SELECT cleanup_expired_feed_cells()');
SELECT cron.schedule('cleanup-image-metrics', '0 3 * * 0', 'SELECT cleanup_old_image_metrics();');
SELECT cron.schedule('cleanup-job-run-details', '0 2 * * *', 'DELETE FROM cron.job_run_details WHERE end_time < NOW() - INTERVAL ''3 days''');
SELECT cron.schedule('cleanup-orphan-images', '0 3 * * *', '
  SELECT net.http_post(
    url := (SELECT decrypted_secret FROM vault.decrypted_secrets WHERE name = ''automation_project_url'') || ''/functions/v1/api-v1-images/cleanup'',
    headers := jsonb_build_object(
      ''Content-Type'', ''application/json'',
      ''Authorization'', ''Bearer '' || (SELECT decrypted_secret FROM vault.decrypted_secrets WHERE name = ''cron_secret'')
    ),
    body := jsonb_build_object(
      ''gracePeriodHours'', 24,
      ''batchSize'', 100,
      ''dryRun'', false
    )
  );
  ');
SELECT cron.schedule('cleanup-translation-job-history', '0 5 * * *', 'DELETE FROM translation_backfill_jobs WHERE started_at < NOW() - INTERVAL ''7 days'';');
SELECT cron.schedule('compress-large-images', '* * * * *', 'SELECT invoke_image_compression();');
SELECT cron.schedule('domain-monitor-check', '0 */6 * * *', '
  SELECT net.http_post(
    url := ''https://***REMOVED***/functions/v1/domain-monitor?notify=true'',
    headers := ''{"Content-Type": "application/json"}''::jsonb,
    body := ''{}''::jsonb
  ) AS request_id;
  ');
SELECT cron.schedule('email-circuit-breaker-cleanup', '0 * * * *', '
    UPDATE email_circuit_breaker_state
    SET
      state = ''closed'',
      failures = 0,
      next_retry_time = NULL,
      updated_at = NOW()
    WHERE state = ''open''
      AND next_retry_time IS NOT NULL
      AND next_retry_time < NOW();

    INSERT INTO email_health_events (provider, event_type, severity, message)
    SELECT
      provider,
      ''circuit_breaker_auto_reset'' as event_type,
      ''info'' as severity,
      ''Circuit breaker automatically reset after retry timeout'' as message
    FROM email_circuit_breaker_state
    WHERE state = ''closed''
      AND updated_at > NOW() - INTERVAL ''5 minutes'';
  ');
SELECT cron.schedule('email-dlq-review-alert', '0 9 * * *', '
  INSERT INTO email_health_events (event_type, severity, message, metadata)
  SELECT
    ''dlq_review_needed'' as event_type,
    ''warning'' as severity,
    ''Dead letter queue has '' || COUNT(*) || '' unreviewed emails'' as message,
    jsonb_build_object(
      ''count'', COUNT(*),
      ''oldest_email'', MIN(created_at),
      ''providers_failed'', jsonb_agg(DISTINCT failed_providers)
    ) as metadata
  FROM email_dead_letter_queue
  WHERE reviewed_at IS NULL
  HAVING COUNT(*) > 0;
  ');
SELECT cron.schedule('email-health-events-cleanup', '0 2 * * 0', '
    DELETE FROM email_health_events
    WHERE created_at < NOW() - INTERVAL ''30 days'';

    DELETE FROM email_logs
    WHERE created_at < NOW() - INTERVAL ''90 days'';

    DELETE FROM email_provider_metrics
    WHERE date < CURRENT_DATE - INTERVAL ''90 days'';
  ');
SELECT cron.schedule('email-health-monitoring', '*/5 * * * *', 'SELECT snapshot_provider_health();');
SELECT cron.schedule('email-queue-processor', '* * * * *', 'SELECT public.trigger_email_queue_processing();');
SELECT cron.schedule('email-quota-daily-reset', '0 0 * * *', '
  INSERT INTO email_provider_quota (provider, date, emails_sent, daily_limit, monthly_limit, organization_id)
  SELECT
    p.provider,
    CURRENT_DATE + INTERVAL ''1 day'' as date,
    0 as emails_sent,
    CASE p.provider
      WHEN ''resend'' THEN 100
      WHEN ''brevo'' THEN 300
      WHEN ''aws_ses'' THEN 100
      ELSE 100
    END as daily_limit,
    CASE p.provider
      WHEN ''resend'' THEN 3000
      WHEN ''brevo'' THEN 9000
      WHEN ''aws_ses'' THEN 62000
      ELSE 3000
    END as monthly_limit,
    ''00000000-0000-0000-0000-000000000001''::uuid as organization_id
  FROM UNNEST(ARRAY[''resend'', ''brevo'', ''aws_ses'']) as p(provider)
  WHERE NOT EXISTS (
    SELECT 1 FROM email_provider_quota eq
    WHERE eq.provider = p.provider
      AND eq.date = CURRENT_DATE + INTERVAL ''1 day''
      AND eq.organization_id = ''00000000-0000-0000-0000-000000000001''::uuid
  );
  ');
SELECT cron.schedule('invoke_update_post_coordinates_every_minute', '* * * * *', 'SELECT invoke_update_post_coordinates()');
SELECT cron.schedule('job_update_post_coordinates', '* * * * *', 'SELECT public.invoke_update_post_coordinates()');
SELECT cron.schedule('notification-digest-cleanup', '0 2 * * 0', 'SELECT cleanup_old_digest_queue(7);');
SELECT cron.schedule('notification-digest-daily', '0 9 * * *', 'SELECT trigger_digest_edge_function(''daily'');');
SELECT cron.schedule('notification-digest-hourly', '0 * * * *', 'SELECT trigger_digest_edge_function(''hourly'');');
SELECT cron.schedule('notification-digest-weekly', '0 9 * * 1', 'SELECT trigger_digest_edge_function(''weekly'');');
SELECT cron.schedule('process-automation-queue', '*/5 * * * *', '
  SELECT net.http_post(
    url := (SELECT decrypted_secret FROM vault.decrypted_secrets WHERE name = ''automation_project_url'') || ''/functions/v1/process-automation-queue'',
    headers := jsonb_build_object(
      ''Content-Type'', ''application/json'',
      ''Authorization'', ''Bearer '' || (SELECT decrypted_secret FROM vault.decrypted_secrets WHERE name = ''automation_anon_key'')
    ),
    body := jsonb_build_object(
      ''triggered_at'', NOW(),
      ''source'', ''cron''
    ),
    timeout_milliseconds := 30000
  ) AS request_id;
  ');
SELECT cron.schedule('process-location-updates', '* * * * *', 'SELECT process_location_update_queue();');
SELECT cron.schedule('process-translation-queue', '* * * * *', '
  SELECT net.http_post(
    url := (SELECT decrypted_secret FROM vault.decrypted_secrets WHERE name = ''automation_project_url'') || ''/functions/v1/localization/process-queue'',
    headers := jsonb_build_object(
      ''Content-Type'', ''application/json'',
      ''Authorization'', ''Bearer '' || (SELECT decrypted_secret FROM vault.decrypted_secrets WHERE name = ''automation_anon_key'')
    ),
    body := jsonb_build_object(''limit'', 20),
    timeout_milliseconds := 120000
  ) AS request_id;
  ');
SELECT cron.schedule('recalculate-email-provider-health', '*/15 * * * *', 'SELECT sync_email_provider_stats_internal()');
SELECT cron.schedule('recompress-old-images', '0 4 * * *', '
  SELECT net.http_post(
    url := (SELECT decrypted_secret FROM vault.decrypted_secrets WHERE name = ''automation_project_url'') || ''/functions/v1/recompress-images-cron'',
    headers := jsonb_build_object(
      ''Content-Type'', ''application/json'',
      ''Authorization'', ''Bearer '' || (SELECT decrypted_secret FROM vault.decrypted_secrets WHERE name = ''cron_secret'')
    ),
    body := ''{}''::jsonb
  );
  ');
SELECT cron.schedule('refresh-user-stats-mv', '*/15 * * * *', 'SELECT refresh_user_stats_mv()');
SELECT cron.schedule('reset-daily-email-quotas', '0 0 * * *', 'SELECT reset_daily_email_quotas()');
SELECT cron.schedule('subscription-cleanup-weekly', '0 1 * * 0', 'SELECT billing.cleanup_old_events(90);');
SELECT cron.schedule('subscription-dlq-process', '*/5 * * * *', 'SELECT billing.process_dlq();');
SELECT cron.schedule('subscription-metrics-daily', '0 0 * * *', 'SELECT billing.update_daily_metrics(CURRENT_DATE);');
SELECT cron.schedule('sync-email-provider-stats-hourly', '0 * * * *', 'SELECT trigger_email_provider_sync()');
SELECT cron.schedule('update-daily-stats', '5 0 * * *', 'SELECT update_daily_stats()');
SELECT cron.schedule('update-locations-every-5-minutes', '*/5 * * * *', 'SELECT scheduled_update_locations();');
SELECT cron.schedule('update-locations-every-minute', '* * * * *', 'SELECT scheduled_update_locations();');
SELECT cron.schedule('upstash-health-check-hourly', '0 * * * *', 'SELECT invoke_upstash_health_check();');
